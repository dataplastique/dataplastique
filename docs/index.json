{
	"tree": {
		"name": "packages",
		"nodes": [
			{
				"name": "dataplastique",
				"nodes": [
					{
						"name": "src",
						"nodes": [
							{
								"name": "Spirit.js",
								"src": "packages/dataplastique/src/Spirit.js"
							},
							{
								"name": "index.js",
								"src": "packages/dataplastique/src/index.js"
							}
						],
						"open": false,
						"filenames": "spirit.js index.js"
					}
				],
				"open": false,
				"filenames": "spirit.js index.js"
			},
			{
				"name": "docs",
				"nodes": [
					{
						"name": "src",
						"nodes": [
							{
								"name": "js",
								"nodes": [
									{
										"name": "compiler",
										"nodes": [
											{
												"name": "formatscript.js",
												"src": "packages/docs/src/js/compiler/formatscript.js"
											},
											{
												"name": "index.js",
												"src": "packages/docs/src/js/compiler/index.js"
											},
											{
												"name": "indexfiletree.js",
												"src": "packages/docs/src/js/compiler/indexfiletree.js"
											},
											{
												"name": "parsedocument.js",
												"src": "packages/docs/src/js/compiler/parsedocument.js"
											}
										],
										"open": false,
										"filenames": "formatscript.js index.js indexfiletree.js parsedocument.js"
									},
									{
										"name": "models",
										"nodes": [
											{
												"name": "docs",
												"nodes": [
													{
														"name": "DocModel.js",
														"src": "packages/docs/src/js/models/docs/DocModel.js"
													},
													{
														"name": "EDBMLDocModel.js",
														"src": "packages/docs/src/js/models/docs/EDBMLDocModel.js"
													},
													{
														"name": "JSDocModel.js",
														"src": "packages/docs/src/js/models/docs/JSDocModel.js"
													},
													{
														"name": "MDDocModel.js",
														"src": "packages/docs/src/js/models/docs/MDDocModel.js"
													}
												],
												"open": false,
												"filenames": "docmodel.js edbmldocmodel.js jsdocmodel.js mddocmodel.js"
											},
											{
												"name": "tree",
												"nodes": [
													{
														"name": "FileModel.js",
														"src": "packages/docs/src/js/models/tree/FileModel.js"
													},
													{
														"name": "FolderModel.js",
														"src": "packages/docs/src/js/models/tree/FolderModel.js"
													},
													{
														"name": "NodeModel.js",
														"src": "packages/docs/src/js/models/tree/NodeModel.js"
													},
													{
														"name": "TreeModel.js",
														"src": "packages/docs/src/js/models/tree/TreeModel.js"
													}
												],
												"open": false,
												"filenames": "filemodel.js foldermodel.js nodemodel.js treemodel.js"
											}
										],
										"open": false,
										"filenames": "docmodel.js edbmldocmodel.js jsdocmodel.js mddocmodel.js filemodel.js foldermodel.js nodemodel.js treemodel.js"
									},
									{
										"name": "spirits",
										"nodes": [
											{
												"name": "docs-code",
												"nodes": [
													{
														"name": "CodeSpirit.edbml",
														"src": "packages/docs/src/js/spirits/docs-code/CodeSpirit.edbml"
													},
													{
														"name": "CodeSpirit.js",
														"src": "packages/docs/src/js/spirits/docs-code/CodeSpirit.js"
													},
													{
														"name": "hilite.js",
														"src": "packages/docs/src/js/spirits/docs-code/hilite.js"
													},
													{
														"name": "markup.js",
														"src": "packages/docs/src/js/spirits/docs-code/markup.js"
													}
												],
												"open": false,
												"filenames": "codespirit.edbml codespirit.js hilite.js markup.js"
											},
											{
												"name": "docs-root",
												"nodes": [
													{
														"name": "RootSpirit.js",
														"src": "packages/docs/src/js/spirits/docs-root/RootSpirit.js"
													}
												],
												"open": false,
												"filenames": "rootspirit.js"
											},
											{
												"name": "docs-tree",
												"nodes": [
													{
														"name": "TreeSpirit.edbml",
														"src": "packages/docs/src/js/spirits/docs-tree/TreeSpirit.edbml"
													},
													{
														"name": "TreeSpirit.js",
														"src": "packages/docs/src/js/spirits/docs-tree/TreeSpirit.js"
													}
												],
												"open": false,
												"filenames": "treespirit.edbml treespirit.js"
											}
										],
										"open": false,
										"filenames": "codespirit.edbml codespirit.js hilite.js markup.js rootspirit.js treespirit.edbml treespirit.js"
									},
									{
										"name": "index.js",
										"src": "packages/docs/src/js/index.js"
									}
								],
								"open": false,
								"filenames": "formatscript.js index.js indexfiletree.js parsedocument.js docmodel.js edbmldocmodel.js jsdocmodel.js mddocmodel.js filemodel.js foldermodel.js nodemodel.js treemodel.js codespirit.edbml codespirit.js hilite.js markup.js rootspirit.js treespirit.edbml treespirit.js index.js"
							}
						],
						"open": false,
						"filenames": "formatscript.js index.js indexfiletree.js parsedocument.js docmodel.js edbmldocmodel.js jsdocmodel.js mddocmodel.js filemodel.js foldermodel.js nodemodel.js treemodel.js codespirit.edbml codespirit.js hilite.js markup.js rootspirit.js treespirit.edbml treespirit.js index.js"
					}
				],
				"open": false,
				"filenames": "formatscript.js index.js indexfiletree.js parsedocument.js docmodel.js edbmldocmodel.js jsdocmodel.js mddocmodel.js filemodel.js foldermodel.js nodemodel.js treemodel.js codespirit.edbml codespirit.js hilite.js markup.js rootspirit.js treespirit.edbml treespirit.js index.js"
			},
			{
				"name": "edb",
				"nodes": [
					{
						"name": "src",
						"nodes": [
							{
								"name": "devtools",
								"nodes": [
									{
										"name": "ClassFormatter.js",
										"src": "packages/edb/src/devtools/ClassFormatter.js"
									},
									{
										"name": "Formatter.js",
										"src": "packages/edb/src/devtools/Formatter.js"
									},
									{
										"name": "InstanceFormatter.js",
										"src": "packages/edb/src/devtools/InstanceFormatter.js"
									},
									{
										"name": "index.js",
										"src": "packages/edb/src/devtools/index.js"
									},
									{
										"name": "styling.js",
										"src": "packages/edb/src/devtools/styling.js"
									}
								],
								"open": false,
								"filenames": "classformatter.js formatter.js instanceformatter.js index.js styling.js"
							},
							{
								"name": "output",
								"nodes": [
									{
										"name": "Output.js",
										"src": "packages/edb/src/output/Output.js"
									},
									{
										"name": "scopes.js",
										"src": "packages/edb/src/output/scopes.js"
									}
								],
								"open": false,
								"filenames": "output.js scopes.js"
							},
							{
								"name": "proxy",
								"nodes": [
									{
										"name": "access",
										"nodes": [
											{
												"name": "Access.js",
												"src": "packages/edb/src/proxy/access/Access.js"
											}
										],
										"open": false,
										"filenames": "access.js"
									},
									{
										"name": "handlers",
										"nodes": [
											{
												"name": "observers",
												"nodes": [
													{
														"name": "IObserver.js",
														"src": "packages/edb/src/proxy/handlers/observers/IObserver.js"
													},
													{
														"name": "Observers.js",
														"src": "packages/edb/src/proxy/handlers/observers/Observers.js"
													}
												],
												"open": false,
												"filenames": "iobserver.js observers.js"
											},
											{
												"name": "pipes",
												"nodes": [
													{
														"name": "ArrayPipe.js",
														"src": "packages/edb/src/proxy/handlers/pipes/ArrayPipe.js"
													},
													{
														"name": "Converters.js",
														"src": "packages/edb/src/proxy/handlers/pipes/Converters.js"
													},
													{
														"name": "ObjectPipe.js",
														"src": "packages/edb/src/proxy/handlers/pipes/ObjectPipe.js"
													},
													{
														"name": "Validators.js",
														"src": "packages/edb/src/proxy/handlers/pipes/Validators.js"
													}
												],
												"open": false,
												"filenames": "arraypipe.js converters.js objectpipe.js validators.js"
											},
											{
												"name": "CollectionHandler.js",
												"src": "packages/edb/src/proxy/handlers/CollectionHandler.js"
											},
											{
												"name": "ModelHandler.js",
												"src": "packages/edb/src/proxy/handlers/ModelHandler.js"
											}
										],
										"open": false,
										"filenames": "iobserver.js observers.js arraypipe.js converters.js objectpipe.js validators.js collectionhandler.js modelhandler.js"
									},
									{
										"name": "plugins",
										"nodes": [
											{
												"name": "Plugins.js",
												"src": "packages/edb/src/proxy/plugins/Plugins.js"
											}
										],
										"open": false,
										"filenames": "plugins.js"
									},
									{
										"name": "target",
										"nodes": [
											{
												"name": "Target.js",
												"src": "packages/edb/src/proxy/target/Target.js"
											}
										],
										"open": false,
										"filenames": "target.js"
									},
									{
										"name": "ProxyFactory.js",
										"src": "packages/edb/src/proxy/ProxyFactory.js"
									},
									{
										"name": "ProxyHandler.js",
										"src": "packages/edb/src/proxy/ProxyHandler.js"
									}
								],
								"open": false,
								"filenames": "access.js iobserver.js observers.js arraypipe.js converters.js objectpipe.js validators.js collectionhandler.js modelhandler.js plugins.js target.js proxyfactory.js proxyhandler.js"
							},
							{
								"name": "Collection.js",
								"src": "packages/edb/src/Collection.js"
							},
							{
								"name": "Model.js",
								"src": "packages/edb/src/Model.js"
							},
							{
								"name": "Plugin.js",
								"src": "packages/edb/src/Plugin.js"
							},
							{
								"name": "Proto.js",
								"src": "packages/edb/src/Proto.js"
							},
							{
								"name": "Tree.js",
								"src": "packages/edb/src/Tree.js"
							},
							{
								"name": "index.js",
								"src": "packages/edb/src/index.js"
							}
						],
						"open": false,
						"filenames": "classformatter.js formatter.js instanceformatter.js index.js styling.js output.js scopes.js access.js iobserver.js observers.js arraypipe.js converters.js objectpipe.js validators.js collectionhandler.js modelhandler.js plugins.js target.js proxyfactory.js proxyhandler.js collection.js model.js plugin.js proto.js tree.js index.js"
					}
				],
				"open": false,
				"filenames": "classformatter.js formatter.js instanceformatter.js index.js styling.js output.js scopes.js access.js iobserver.js observers.js arraypipe.js converters.js objectpipe.js validators.js collectionhandler.js modelhandler.js plugins.js target.js proxyfactory.js proxyhandler.js collection.js model.js plugin.js proto.js tree.js index.js"
			},
			{
				"name": "edb-plugins",
				"nodes": [
					{
						"name": "src",
						"nodes": [
							{
								"name": "IOPlugin.js",
								"src": "packages/edb-plugins/src/IOPlugin.js"
							},
							{
								"name": "Tracker.js",
								"src": "packages/edb-plugins/src/Tracker.js"
							},
							{
								"name": "index.js",
								"src": "packages/edb-plugins/src/index.js"
							}
						],
						"open": false,
						"filenames": "ioplugin.js tracker.js index.js"
					}
				],
				"open": false,
				"filenames": "ioplugin.js tracker.js index.js"
			},
			{
				"name": "edbml-cli",
				"nodes": [
					{
						"name": "src",
						"nodes": [
							{
								"name": "Parser.js",
								"src": "packages/edbml-cli/src/Parser.js"
							},
							{
								"name": "index.js",
								"src": "packages/edbml-cli/src/index.js"
							},
							{
								"name": "step1.js",
								"src": "packages/edbml-cli/src/step1.js"
							},
							{
								"name": "step2.js",
								"src": "packages/edbml-cli/src/step2.js"
							},
							{
								"name": "step3.js",
								"src": "packages/edbml-cli/src/step3.js"
							},
							{
								"name": "step4.js",
								"src": "packages/edbml-cli/src/step4.js"
							}
						],
						"open": false,
						"filenames": "parser.js index.js step1.js step2.js step3.js step4.js"
					}
				],
				"open": false,
				"filenames": "parser.js index.js step1.js step2.js step3.js step4.js"
			},
			{
				"name": "edbml-runtime",
				"nodes": [
					{
						"name": "src",
						"nodes": [
							{
								"name": "Out",
								"nodes": [
									{
										"name": "attributes.js",
										"src": "packages/edbml-runtime/src/Out/attributes.js"
									},
									{
										"name": "deferred.js",
										"src": "packages/edbml-runtime/src/Out/deferred.js"
									},
									{
										"name": "fixes.js",
										"src": "packages/edbml-runtime/src/Out/fixes.js"
									},
									{
										"name": "index.js",
										"src": "packages/edbml-runtime/src/Out/index.js"
									},
									{
										"name": "normalize.js",
										"src": "packages/edbml-runtime/src/Out/normalize.js"
									},
									{
										"name": "runnable.js",
										"src": "packages/edbml-runtime/src/Out/runnable.js"
									},
									{
										"name": "safe.js",
										"src": "packages/edbml-runtime/src/Out/safe.js"
									},
									{
										"name": "validate.js",
										"src": "packages/edbml-runtime/src/Out/validate.js"
									}
								],
								"open": false,
								"filenames": "attributes.js deferred.js fixes.js index.js normalize.js runnable.js safe.js validate.js"
							},
							{
								"name": "diffengine",
								"nodes": [
									{
										"name": "compare.js",
										"src": "packages/edbml-runtime/src/diffengine/compare.js"
									},
									{
										"name": "events.js",
										"src": "packages/edbml-runtime/src/diffengine/events.js"
									},
									{
										"name": "filter.js",
										"src": "packages/edbml-runtime/src/diffengine/filter.js"
									},
									{
										"name": "focus.js",
										"src": "packages/edbml-runtime/src/diffengine/focus.js"
									},
									{
										"name": "index.js",
										"src": "packages/edbml-runtime/src/diffengine/index.js"
									},
									{
										"name": "mutate.js",
										"src": "packages/edbml-runtime/src/diffengine/mutate.js"
									},
									{
										"name": "updates.js",
										"src": "packages/edbml-runtime/src/diffengine/updates.js"
									}
								],
								"open": false,
								"filenames": "compare.js events.js filter.js focus.js index.js mutate.js updates.js"
							},
							{
								"name": "index.js",
								"src": "packages/edbml-runtime/src/index.js"
							}
						],
						"open": false,
						"filenames": "attributes.js deferred.js fixes.js index.js normalize.js runnable.js safe.js validate.js compare.js events.js filter.js focus.js index.js mutate.js updates.js index.js"
					}
				],
				"open": false,
				"filenames": "attributes.js deferred.js fixes.js index.js normalize.js runnable.js safe.js validate.js compare.js events.js filter.js focus.js index.js mutate.js updates.js index.js"
			},
			{
				"name": "gui",
				"nodes": [
					{
						"name": "src",
						"nodes": [
							{
								"name": "Config.js",
								"src": "packages/gui/src/Config.js"
							},
							{
								"name": "Const.js",
								"src": "packages/gui/src/Const.js"
							},
							{
								"name": "Cycle.js",
								"src": "packages/gui/src/Cycle.js"
							},
							{
								"name": "Deco.js",
								"src": "packages/gui/src/Deco.js"
							},
							{
								"name": "Guide.js",
								"src": "packages/gui/src/Guide.js"
							},
							{
								"name": "Spirit.js",
								"src": "packages/gui/src/Spirit.js"
							},
							{
								"name": "Store.js",
								"src": "packages/gui/src/Store.js"
							},
							{
								"name": "index.js",
								"src": "packages/gui/src/index.js"
							}
						],
						"open": false,
						"filenames": "config.js const.js cycle.js deco.js guide.js spirit.js store.js index.js"
					}
				],
				"open": false,
				"filenames": "config.js const.js cycle.js deco.js guide.js spirit.js store.js index.js"
			},
			{
				"name": "gui-plugins",
				"nodes": [
					{
						"name": "src",
						"nodes": [
							{
								"name": "att",
								"nodes": [
									{
										"name": "AttPlugin.js",
										"src": "packages/gui-plugins/src/att/AttPlugin.js"
									}
								],
								"open": false,
								"filenames": "attplugin.js"
							},
							{
								"name": "broadcast",
								"nodes": [
									{
										"name": "Broadcast.js",
										"src": "packages/gui-plugins/src/broadcast/Broadcast.js"
									},
									{
										"name": "BroadcastPlugin.js",
										"src": "packages/gui-plugins/src/broadcast/BroadcastPlugin.js"
									}
								],
								"open": false,
								"filenames": "broadcast.js broadcastplugin.js"
							},
							{
								"name": "css",
								"nodes": [
									{
										"name": "CSSPlugin.js",
										"src": "packages/gui-plugins/src/css/CSSPlugin.js"
									}
								],
								"open": false,
								"filenames": "cssplugin.js"
							},
							{
								"name": "dom",
								"nodes": [
									{
										"name": "Crawler.js",
										"src": "packages/gui-plugins/src/dom/Crawler.js"
									},
									{
										"name": "DOMPlugin.js",
										"src": "packages/gui-plugins/src/dom/DOMPlugin.js"
									}
								],
								"open": false,
								"filenames": "crawler.js domplugin.js"
							},
							{
								"name": "event",
								"nodes": [
									{
										"name": "EventPlugin.js",
										"src": "packages/gui-plugins/src/event/EventPlugin.js"
									}
								],
								"open": false,
								"filenames": "eventplugin.js"
							},
							{
								"name": "key",
								"nodes": [
									{
										"name": "Key.js",
										"src": "packages/gui-plugins/src/key/Key.js"
									},
									{
										"name": "KeyPlugin.js",
										"src": "packages/gui-plugins/src/key/KeyPlugin.js"
									}
								],
								"open": false,
								"filenames": "key.js keyplugin.js"
							},
							{
								"name": "life",
								"nodes": [
									{
										"name": "Life.js",
										"src": "packages/gui-plugins/src/life/Life.js"
									},
									{
										"name": "LifePlugin.js",
										"src": "packages/gui-plugins/src/life/LifePlugin.js"
									}
								],
								"open": false,
								"filenames": "life.js lifeplugin.js"
							},
							{
								"name": "script",
								"nodes": [
									{
										"name": "ScriptPlugin.js",
										"src": "packages/gui-plugins/src/script/ScriptPlugin.js"
									}
								],
								"open": false,
								"filenames": "scriptplugin.js"
							},
							{
								"name": "shadow",
								"nodes": [
									{
										"name": "ShadowPlugin.js",
										"src": "packages/gui-plugins/src/shadow/ShadowPlugin.js"
									},
									{
										"name": "Slot.js",
										"src": "packages/gui-plugins/src/shadow/Slot.js"
									},
									{
										"name": "SlotObserver.js",
										"src": "packages/gui-plugins/src/shadow/SlotObserver.js"
									}
								],
								"open": false,
								"filenames": "shadowplugin.js slot.js slotobserver.js"
							},
							{
								"name": "tick",
								"nodes": [
									{
										"name": "TickPlugin.js",
										"src": "packages/gui-plugins/src/tick/TickPlugin.js"
									}
								],
								"open": false,
								"filenames": "tickplugin.js"
							},
							{
								"name": "SpiritPlugin.js",
								"src": "packages/gui-plugins/src/SpiritPlugin.js"
							},
							{
								"name": "TrackerPlugin.js",
								"src": "packages/gui-plugins/src/TrackerPlugin.js"
							},
							{
								"name": "index.js",
								"src": "packages/gui-plugins/src/index.js"
							}
						],
						"open": false,
						"filenames": "attplugin.js broadcast.js broadcastplugin.js cssplugin.js crawler.js domplugin.js eventplugin.js key.js keyplugin.js life.js lifeplugin.js scriptplugin.js shadowplugin.js slot.js slotobserver.js tickplugin.js spiritplugin.js trackerplugin.js index.js"
					}
				],
				"open": false,
				"filenames": "attplugin.js broadcast.js broadcastplugin.js cssplugin.js crawler.js domplugin.js eventplugin.js key.js keyplugin.js life.js lifeplugin.js scriptplugin.js shadowplugin.js slot.js slotobserver.js tickplugin.js spiritplugin.js trackerplugin.js index.js"
			},
			{
				"name": "test",
				"nodes": [
					{
						"name": "src",
						"nodes": [
							{
								"name": "edb",
								"nodes": [
									{
										"name": "Collection.iso.spec.js",
										"src": "packages/test/src/edb/Collection.iso.spec.js"
									},
									{
										"name": "DevTools.web.spec.js",
										"src": "packages/test/src/edb/DevTools.web.spec.js"
									},
									{
										"name": "Model.iso.spec.js",
										"src": "packages/test/src/edb/Model.iso.spec.js"
									},
									{
										"name": "Model.observers.iso.spec.js",
										"src": "packages/test/src/edb/Model.observers.iso.spec.js"
									},
									{
										"name": "Model.output.iso.spec.js",
										"src": "packages/test/src/edb/Model.output.iso.spec.js"
									},
									{
										"name": "Model.pipes.iso.spec.js",
										"src": "packages/test/src/edb/Model.pipes.iso.spec.js"
									},
									{
										"name": "Model.proxy.iso.spec.js",
										"src": "packages/test/src/edb/Model.proxy.iso.spec.js"
									},
									{
										"name": "Plugin.iso.spec.js",
										"src": "packages/test/src/edb/Plugin.iso.spec.js"
									},
									{
										"name": "Tree.iso.spec.js",
										"src": "packages/test/src/edb/Tree.iso.spec.js"
									}
								],
								"open": false,
								"filenames": "collection.iso.spec.js devtools.web.spec.js model.iso.spec.js model.observers.iso.spec.js model.output.iso.spec.js model.pipes.iso.spec.js model.proxy.iso.spec.js plugin.iso.spec.js tree.iso.spec.js"
							},
							{
								"name": "gui",
								"nodes": [
									{
										"name": "edbml",
										"nodes": [
											{
												"name": "attributes.edbml",
												"src": "packages/test/src/gui/edbml/attributes.edbml"
											},
											{
												"name": "expect-equalnode.edbml",
												"src": "packages/test/src/gui/edbml/expect-equalnode.edbml"
											},
											{
												"name": "guid-recycle.edbml",
												"src": "packages/test/src/gui/edbml/guid-recycle.edbml"
											},
											{
												"name": "hello-world.edbml",
												"src": "packages/test/src/gui/edbml/hello-world.edbml"
											},
											{
												"name": "inline-callbacks.edbml",
												"src": "packages/test/src/gui/edbml/inline-callbacks.edbml"
											},
											{
												"name": "io-flemming.edbml",
												"src": "packages/test/src/gui/edbml/io-flemming.edbml"
											},
											{
												"name": "io-johnson.edbml",
												"src": "packages/test/src/gui/edbml/io-johnson.edbml"
											},
											{
												"name": "io-simple.edbml",
												"src": "packages/test/src/gui/edbml/io-simple.edbml"
											},
											{
												"name": "level1.edbml",
												"src": "packages/test/src/gui/edbml/level1.edbml"
											},
											{
												"name": "level2.edbml",
												"src": "packages/test/src/gui/edbml/level2.edbml"
											},
											{
												"name": "level3.edbml",
												"src": "packages/test/src/gui/edbml/level3.edbml"
											},
											{
												"name": "nodes-and-spirits.edbml",
												"src": "packages/test/src/gui/edbml/nodes-and-spirits.edbml"
											},
											{
												"name": "not_wellformed.edbml",
												"src": "packages/test/src/gui/edbml/not_wellformed.edbml"
											},
											{
												"name": "pass-props.edbml",
												"src": "packages/test/src/gui/edbml/pass-props.edbml"
											},
											{
												"name": "problem.edbml",
												"src": "packages/test/src/gui/edbml/problem.edbml"
											},
											{
												"name": "root-updates.edbml",
												"src": "packages/test/src/gui/edbml/root-updates.edbml"
											},
											{
												"name": "xxsfilters.edbml",
												"src": "packages/test/src/gui/edbml/xxsfilters.edbml"
											}
										],
										"open": false,
										"filenames": "attributes.edbml expect-equalnode.edbml guid-recycle.edbml hello-world.edbml inline-callbacks.edbml io-flemming.edbml io-johnson.edbml io-simple.edbml level1.edbml level2.edbml level3.edbml nodes-and-spirits.edbml not_wellformed.edbml pass-props.edbml problem.edbml root-updates.edbml xxsfilters.edbml"
									},
									{
										"name": "models",
										"nodes": [
											{
												"name": "DonkeyModel.js",
												"src": "packages/test/src/gui/models/DonkeyModel.js"
											},
											{
												"name": "NumberCollection.js",
												"src": "packages/test/src/gui/models/NumberCollection.js"
											},
											{
												"name": "PersonCollection.js",
												"src": "packages/test/src/gui/models/PersonCollection.js"
											},
											{
												"name": "PersonModel.js",
												"src": "packages/test/src/gui/models/PersonModel.js"
											}
										],
										"open": false,
										"filenames": "donkeymodel.js numbercollection.js personcollection.js personmodel.js"
									},
									{
										"name": "AttPlugin.web.spec.js",
										"src": "packages/test/src/gui/AttPlugin.web.spec.js"
									},
									{
										"name": "CSSPlugin.web.spec.js",
										"src": "packages/test/src/gui/CSSPlugin.web.spec.js"
									},
									{
										"name": "DOMPlugin.web.spec.js",
										"src": "packages/test/src/gui/DOMPlugin.web.spec.js"
									},
									{
										"name": "IOPlugin.web.spec.js",
										"src": "packages/test/src/gui/IOPlugin.web.spec.js"
									},
									{
										"name": "ScriptPlugin-0.web.spec.js",
										"src": "packages/test/src/gui/ScriptPlugin-0.web.spec.js"
									},
									{
										"name": "ScriptPlugin-1.web.spec.js",
										"src": "packages/test/src/gui/ScriptPlugin-1.web.spec.js"
									},
									{
										"name": "ScriptPlugin-2.web.spec.js",
										"src": "packages/test/src/gui/ScriptPlugin-2.web.spec.js"
									},
									{
										"name": "ScriptPlugin-3.web.spec.js",
										"src": "packages/test/src/gui/ScriptPlugin-3.web.spec.js"
									},
									{
										"name": "Spirit.web.spec.js",
										"src": "packages/test/src/gui/Spirit.web.spec.js"
									}
								],
								"open": false,
								"filenames": "attributes.edbml expect-equalnode.edbml guid-recycle.edbml hello-world.edbml inline-callbacks.edbml io-flemming.edbml io-johnson.edbml io-simple.edbml level1.edbml level2.edbml level3.edbml nodes-and-spirits.edbml not_wellformed.edbml pass-props.edbml problem.edbml root-updates.edbml xxsfilters.edbml donkeymodel.js numbercollection.js personcollection.js personmodel.js attplugin.web.spec.js cssplugin.web.spec.js domplugin.web.spec.js ioplugin.web.spec.js scriptplugin-0.web.spec.js scriptplugin-1.web.spec.js scriptplugin-2.web.spec.js scriptplugin-3.web.spec.js spirit.web.spec.js"
							},
							{
								"name": "util",
								"nodes": [
									{
										"name": "IMapping.iso.spec.js",
										"src": "packages/test/src/util/IMapping.iso.spec.js"
									},
									{
										"name": "Key.iso.spec.js",
										"src": "packages/test/src/util/Key.iso.spec.js"
									},
									{
										"name": "Mapping.iso.spec.js",
										"src": "packages/test/src/util/Mapping.iso.spec.js"
									},
									{
										"name": "Tick.iso.spec.js",
										"src": "packages/test/src/util/Tick.iso.spec.js"
									},
									{
										"name": "Tick.web.spec.js",
										"src": "packages/test/src/util/Tick.web.spec.js"
									},
									{
										"name": "Type.iso.spec.js",
										"src": "packages/test/src/util/Type.iso.spec.js"
									},
									{
										"name": "arrayutils.iso.spec.js",
										"src": "packages/test/src/util/arrayutils.iso.spec.js"
									}
								],
								"open": false,
								"filenames": "imapping.iso.spec.js key.iso.spec.js mapping.iso.spec.js tick.iso.spec.js tick.web.spec.js type.iso.spec.js arrayutils.iso.spec.js"
							},
							{
								"name": "iso.js",
								"src": "packages/test/src/iso.js"
							},
							{
								"name": "web.js",
								"src": "packages/test/src/web.js"
							}
						],
						"open": false,
						"filenames": "collection.iso.spec.js devtools.web.spec.js model.iso.spec.js model.observers.iso.spec.js model.output.iso.spec.js model.pipes.iso.spec.js model.proxy.iso.spec.js plugin.iso.spec.js tree.iso.spec.js attributes.edbml expect-equalnode.edbml guid-recycle.edbml hello-world.edbml inline-callbacks.edbml io-flemming.edbml io-johnson.edbml io-simple.edbml level1.edbml level2.edbml level3.edbml nodes-and-spirits.edbml not_wellformed.edbml pass-props.edbml problem.edbml root-updates.edbml xxsfilters.edbml donkeymodel.js numbercollection.js personcollection.js personmodel.js attplugin.web.spec.js cssplugin.web.spec.js domplugin.web.spec.js ioplugin.web.spec.js scriptplugin-0.web.spec.js scriptplugin-1.web.spec.js scriptplugin-2.web.spec.js scriptplugin-3.web.spec.js spirit.web.spec.js imapping.iso.spec.js key.iso.spec.js mapping.iso.spec.js tick.iso.spec.js tick.web.spec.js type.iso.spec.js arrayutils.iso.spec.js iso.js web.js"
					}
				],
				"open": false,
				"filenames": "collection.iso.spec.js devtools.web.spec.js model.iso.spec.js model.observers.iso.spec.js model.output.iso.spec.js model.pipes.iso.spec.js model.proxy.iso.spec.js plugin.iso.spec.js tree.iso.spec.js attributes.edbml expect-equalnode.edbml guid-recycle.edbml hello-world.edbml inline-callbacks.edbml io-flemming.edbml io-johnson.edbml io-simple.edbml level1.edbml level2.edbml level3.edbml nodes-and-spirits.edbml not_wellformed.edbml pass-props.edbml problem.edbml root-updates.edbml xxsfilters.edbml donkeymodel.js numbercollection.js personcollection.js personmodel.js attplugin.web.spec.js cssplugin.web.spec.js domplugin.web.spec.js ioplugin.web.spec.js scriptplugin-0.web.spec.js scriptplugin-1.web.spec.js scriptplugin-2.web.spec.js scriptplugin-3.web.spec.js spirit.web.spec.js imapping.iso.spec.js key.iso.spec.js mapping.iso.spec.js tick.iso.spec.js tick.web.spec.js type.iso.spec.js arrayutils.iso.spec.js iso.js web.js"
			},
			{
				"name": "util",
				"nodes": [
					{
						"name": "src",
						"nodes": [
							{
								"name": "data",
								"nodes": [
									{
										"name": "IMapping.js",
										"src": "packages/util/src/data/IMapping.js"
									},
									{
										"name": "Mapping.js",
										"src": "packages/util/src/data/Mapping.js"
									}
								],
								"open": false,
								"filenames": "imapping.js mapping.js"
							},
							{
								"name": "deps",
								"nodes": [
									{
										"name": "immutable",
										"nodes": [
											{
												"name": "README.md",
												"src": "packages/util/src/deps/immutable/README.md"
											},
											{
												"name": "immutable.es.js",
												"src": "packages/util/src/deps/immutable/immutable.es.js"
											}
										],
										"open": false,
										"filenames": "readme.md immutable.es.js"
									}
								],
								"open": false,
								"filenames": "readme.md immutable.es.js"
							},
							{
								"name": "errors",
								"nodes": [
									{
										"name": "Custom.js",
										"src": "packages/util/src/errors/Custom.js"
									}
								],
								"open": false,
								"filenames": "custom.js"
							},
							{
								"name": "func",
								"nodes": [
									{
										"name": "arrayutils.js",
										"src": "packages/util/src/func/arrayutils.js"
									},
									{
										"name": "domutils.js",
										"src": "packages/util/src/func/domutils.js"
									}
								],
								"open": false,
								"filenames": "arrayutils.js domutils.js"
							},
							{
								"name": "trash",
								"nodes": [
									{
										"name": "arguments.js",
										"src": "packages/util/src/trash/arguments.js"
									}
								],
								"open": false,
								"filenames": "arguments.js"
							},
							{
								"name": "Class.js",
								"src": "packages/util/src/Class.js"
							},
							{
								"name": "Environment.js",
								"src": "packages/util/src/Environment.js"
							},
							{
								"name": "Immutable.js",
								"src": "packages/util/src/Immutable.js"
							},
							{
								"name": "Key.js",
								"src": "packages/util/src/Key.js"
							},
							{
								"name": "Tick.js",
								"src": "packages/util/src/Tick.js"
							},
							{
								"name": "Type.js",
								"src": "packages/util/src/Type.js"
							},
							{
								"name": "decorators.js",
								"src": "packages/util/src/decorators.js"
							},
							{
								"name": "index.js",
								"src": "packages/util/src/index.js"
							}
						],
						"open": false,
						"filenames": "imapping.js mapping.js readme.md immutable.es.js custom.js arrayutils.js domutils.js arguments.js class.js environment.js immutable.js key.js tick.js type.js decorators.js index.js"
					}
				],
				"open": false,
				"filenames": "imapping.js mapping.js readme.md immutable.es.js custom.js arrayutils.js domutils.js arguments.js class.js environment.js immutable.js key.js tick.js type.js decorators.js index.js"
			}
		],
		"open": false,
		"filenames": "spirit.js index.js formatscript.js index.js indexfiletree.js parsedocument.js docmodel.js edbmldocmodel.js jsdocmodel.js mddocmodel.js filemodel.js foldermodel.js nodemodel.js treemodel.js codespirit.edbml codespirit.js hilite.js markup.js rootspirit.js treespirit.edbml treespirit.js index.js classformatter.js formatter.js instanceformatter.js index.js styling.js output.js scopes.js access.js iobserver.js observers.js arraypipe.js converters.js objectpipe.js validators.js collectionhandler.js modelhandler.js plugins.js target.js proxyfactory.js proxyhandler.js collection.js model.js plugin.js proto.js tree.js index.js ioplugin.js tracker.js index.js parser.js index.js step1.js step2.js step3.js step4.js attributes.js deferred.js fixes.js index.js normalize.js runnable.js safe.js validate.js compare.js events.js filter.js focus.js index.js mutate.js updates.js index.js config.js const.js cycle.js deco.js guide.js spirit.js store.js index.js attplugin.js broadcast.js broadcastplugin.js cssplugin.js crawler.js domplugin.js eventplugin.js key.js keyplugin.js life.js lifeplugin.js scriptplugin.js shadowplugin.js slot.js slotobserver.js tickplugin.js spiritplugin.js trackerplugin.js index.js collection.iso.spec.js devtools.web.spec.js model.iso.spec.js model.observers.iso.spec.js model.output.iso.spec.js model.pipes.iso.spec.js model.proxy.iso.spec.js plugin.iso.spec.js tree.iso.spec.js attributes.edbml expect-equalnode.edbml guid-recycle.edbml hello-world.edbml inline-callbacks.edbml io-flemming.edbml io-johnson.edbml io-simple.edbml level1.edbml level2.edbml level3.edbml nodes-and-spirits.edbml not_wellformed.edbml pass-props.edbml problem.edbml root-updates.edbml xxsfilters.edbml donkeymodel.js numbercollection.js personcollection.js personmodel.js attplugin.web.spec.js cssplugin.web.spec.js domplugin.web.spec.js ioplugin.web.spec.js scriptplugin-0.web.spec.js scriptplugin-1.web.spec.js scriptplugin-2.web.spec.js scriptplugin-3.web.spec.js spirit.web.spec.js imapping.iso.spec.js key.iso.spec.js mapping.iso.spec.js tick.iso.spec.js tick.web.spec.js type.iso.spec.js arrayutils.iso.spec.js iso.js web.js imapping.js mapping.js readme.md immutable.es.js custom.js arrayutils.js domutils.js arguments.js class.js environment.js immutable.js key.js tick.js type.js decorators.js index.js",
		"search": ""
	},
	"docs": {
		"packages/dataplastique/src/Spirit.js": {
			"title": "Spirit",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { channeling as channel, Spirit as Base } from '@dataplastique/gui';\nimport { IOPlugin } from '@dataplastique/edb-plugins';\nimport {\n\tBroadcastPlugin,\n\tScriptPlugin,\n\tShadowPlugin,\n\tEventPlugin,\n\tTickPlugin,\n\tLifePlugin,\n\tAttPlugin,\n\tCSSPlugin,\n\tDOMPlugin,\n\tKeyPlugin,\n\tplugin\n} from '@dataplastique/gui-plugins';\n@channeling('gui-spirit')\n@plugin('att', AttPlugin)\n@plugin('life', LifePlugin)\n@plugin('broadcast', BroadcastPlugin)\n@plugin('css', CSSPlugin)\n@plugin('dom', DOMPlugin)\n@plugin('event', EventPlugin)\n@plugin('io', IOPlugin)\n@plugin('key', KeyPlugin)\n@plugin('script', ScriptPlugin)\n@plugin('shadow', ShadowPlugin)\n@plugin('tick', TickPlugin)\n"
						},
						{
							"line": 27,
							"tags": [],
							"tabs": "\t",
							"desc": "Implement callback methods as expected by the plugins. At some point in the future we should automatically do this via mixins (or traits) or at least have the plugin validate that the required methods are implemented. ",
							"code": "export class Spirit extends Base {\n"
						},
						{
							"line": 33,
							"tags": [
								{
									"name": "@param",
									"type": "{Att}",
									"desc": "a",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Handle attribute changed. ",
							"code": "\tonatt(a) {}\n"
						},
						{
							"line": 38,
							"tags": [
								{
									"name": "@param",
									"type": "{Broadcast}",
									"desc": "b",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Handle broadcast. ",
							"code": "\tonbroadcast(b) {}\n"
						},
						{
							"line": 43,
							"tags": [
								{
									"name": "@param",
									"type": "{Event}",
									"desc": "e",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Handle event. ",
							"code": "\tonevent(e) {}\n"
						},
						{
							"line": 48,
							"tags": [
								{
									"name": "@param",
									"type": "{Model}",
									"desc": "c",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Handle input. ",
							"code": "\toninput(c) {}\n"
						},
						{
							"line": 53,
							"tags": [
								{
									"name": "@param",
									"type": "{Key}",
									"desc": "k",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Handle key. ",
							"code": "\tonkey(k) {}\n"
						},
						{
							"line": 58,
							"tags": [
								{
									"name": "@param",
									"type": "{Life}",
									"desc": "l",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Handle life. ",
							"code": "\tonlife(l) {}\n"
						},
						{
							"line": 63,
							"tags": [
								{
									"name": "@param",
									"type": "{Log}",
									"desc": "l",
									"text": "- TODO: Create this `log` thing!!!"
								}
							],
							"tabs": "\t",
							"desc": "EDBML script executed. ",
							"code": "\tonrun(l) {}\n"
						},
						{
							"line": 68,
							"tags": [
								{
									"name": "@param",
									"type": "{Slot}",
									"desc": "s",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Slot changed in Shadow DOM. ",
							"code": "\tonslot(s) {}\n"
						},
						{
							"line": 73,
							"tags": [
								{
									"name": "@param",
									"type": "{Tick}",
									"desc": "t",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Handke tick. ",
							"code": "\tontick(t) {}\n"
						},
						{
							"line": 78,
							"tags": [
								{
									"name": "@implements",
									"type": "{EventListener}",
									"desc": "",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Event}",
									"desc": "e",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Reroute the call to `onevent` ",
							"code": "\thandleEvent(e) {\n\t\tthis.onevent(e);\n\t}\n}\n"
						},
						{
							"line": 87,
							"tags": [
								{
									"name": "@experimental",
									"type": "",
									"desc": "",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string|Array}",
									"desc": "tag",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Class<Spirit>|Function}",
									"desc": "[thing]",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Class<Spirit>}",
									"desc": "[parent]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Function|undefined}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Add support for \"functional spirit\" to eliminate the use of reserved keywords \n`this`, `super`, `extends` and other such real or imagined leaky abstractions. Also support multiple channelings via nested array structure (same structure as used when populating a Map with entries). ",
							"code": "export function channeling(tag, thing, parent) {\n\tconst decorates = arguments.length === 1;\n\treturn Array.isArray(tag)\n\t\t? tag.forEach(tag => channeling(...tag))\n\t\t: decorates\n\t\t\t? channel(tag)\n\t\t\t: Spirit.is(thing)\n\t\t\t\t? channel(tag, thing)\n\t\t\t\t: thing.call && thing.apply\n\t\t\t\t\t? channel(tag, getclass(thing, parent))\n\t\t\t\t\t: throwup('Expected function');\n}\n"
						}
					]
				},
				{
					"title": "Work in progress ",
					"tabs": "",
					"sections": [
						{
							"line": 111,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "message",
									"text": ""
								},
								{
									"name": "@throws",
									"type": "{TypeError}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function throwup(message) {\n\tthrow new TypeError(message);\n}\n"
						},
						{
							"line": 118,
							"tags": [
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "agent",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Class<Spirit>}",
									"desc": "[Parent]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Class<Spirit>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Work in progress: Subclass is automatically shadowed by a lifcycle agent. These methods should obviously not be handcoded like this (since there are more callbacks to worry about, also the ones from plugins). TODO: At least use `babel-plugin-transform-optional-chaining` to clean up TODO: Move this feature down into `@dataplastique/gui` core package TODO: Once we figure out how to declare expected callback methods in plugins, automatically call that method on agent whenever it is called on spirit. ",
							"code": "function getclass(agent, Parent = Spirit) {\n\tconst ag = 'SYMBOL_GOES_HERE'; \n\treturn class Anonymous extends Parent {\n\t\tdisplayName = agent.name || 'Anonymous'; \n\t\tonconstruct() {\n\t\t\tsuper.onconstruct();\n\t\t\tthis[ag] = agent(this, this); \n\t\t\tthis[ag] && this[ag].onconstruct ? this[ag].onconstruct() : void 0;\n\t\t}\n\t\tonattach() {\n\t\t\tsuper.onattach();\n\t\t\tthis[ag] && this[ag].onattach ? this[ag].onattach() : void 0;\n\t\t}\n\t\tonenter() {\n\t\t\tsuper.onenter();\n\t\t\tthis[ag] && this[ag].onenter ? this[ag].onenter() : void 0;\n\t\t}\n\t\tonready() {\n\t\t\tsuper.onready();\n\t\t\tthis[ag] && this[ag].onready ? this[ag].onready() : void 0;\n\t\t}\n\t\tonrun(log) {\n\t\t\tsuper.onrun(log);\n\t\t\tthis[ag] && this[ag].onrun ? this[ag].onrun(log) : void 0;\n\t\t}\n\t\tondetach() {\n\t\t\tsuper.ondetach();\n\t\t\tthis[ag] && this[ag].ondetach ? this[ag].ondetach : void 0;\n\t\t}\n\t\tonexorcize() {\n\t\t\tsuper.onexorcize();\n\t\t\tthis[ag] && this[ag].onexorcize ? this[ag].onexorcize() : void 0;\n\t\t}\n\t};\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/dataplastique/src/index.js": {
			"title": "index",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { Spirit } from './Spirit';\nexport { Spirit, channeling } from './Spirit';\nexport { boot, attribute } from '@dataplastique/gui';\nexport { SpiritPlugin, plugin } from '@dataplastique/gui-plugins';\nexport { Model, Collection, Plugin, Tree } from '@dataplastique/edb';\nexport { output } from '@dataplastique/edbml-runtime';\nexport { Key, chained } from '@dataplastique/util'; \nexport { Environment } from '@dataplastique/util'; \n"
						},
						{
							"line": 8,
							"tags": [
								{
									"name": "@param",
									"type": "{Element|string}",
									"desc": "arg",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "[cb]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Spirit}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get spirit for element. TODO: Get spirit for CSS selector implicitly scoped from the document root. ",
							"code": "export function get(arg, cb) {\n\treturn Spirit.get(arg, cb);\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/docs/src/js/compiler/formatscript.js": {
			"title": "formatscript",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import prettier from 'prettier';\n"
						},
						{
							"line": 1,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "js",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Prettyprint and remove all non-JSDoc comments. ",
							"code": "export function format(js) {\n\treturn js |> parse |> filter |> strip |> clean |> indent;\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 10,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "js",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "action",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Break script into single lines, apply action to lines, join lines to string. ",
							"code": "const eachline = (js, action) => action(js.split('\\n')).join('\\n');\n"
						},
						{
							"line": 17,
							"tags": [
								{
									"name": "@type",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Prettier opinions. ",
							"code": "const options = {\n\tuseTabs: true,\n\tsingleQuote: true,\n\tprintWidth: 80\n};\n"
						},
						{
							"line": 26,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "js",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string|Error}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Parse the script and prepare to remove comments. ",
							"code": "function parse(js) {\n\treturn prettier.format(js, {\n\t\t...options,\n\t\tparser(text, { babylon }) {\n\t\t\tlet ast;\n\t\t\ttry {\n\t\t\t\tast = babylon(text);\n\t\t\t} catch (exception) {\n\t\t\t\tconsole.error(exception);\n\t\t\t\tast = babylon('');\n\t\t\t}\n\t\t\treturn mark(ast);\n\t\t}\n\t});\n}\n"
						},
						{
							"line": 46,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "ast",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Make comments identical so they can be targeted for deletion. ",
							"code": "function mark(ast) {\n\tconst jsdocs = com => com.value.startsWith('*');\n\tconst header = com => com.value.endsWith('......'); \n\tconst others = com => !jsdocs(com) && !header(com);\n\tconst markit = com => (com.value = 'DELETE');\n\tast.comments.filter(others).forEach(markit);\n\treturn ast;\n}\n"
						},
						{
							"line": 59,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "js",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Delete the lines consist only of (marked) comments. ",
							"code": "function filter(js) {\n\treturn eachline(js, lines => {\n\t\treturn lines.filter(line => {\n\t\t\treturn (line = line.trim()) !== '' && line !== '';\n\t\t});\n\t});\n}\n"
						},
						{
							"line": 71,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "js",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Delete the remaining (marked) comments. ",
							"code": "function strip(js) {\n\tconst block = /\\/\\*\\DELETE\\*\\//g;\n\tconst lines = /\\/\\/\\DELETE/g;\n\treturn [block, lines].reduce((result, regex) => {\n\t\treturn result.replace(regex, '');\n\t}, js);\n}\n"
						},
						{
							"line": 83,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "js",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Remove consecutive empty lines (where comments used to be). ",
							"code": "function clean(js) {\n\tlet was = false;\n\tconst ok = line => (was = line !== '' || !was);\n\treturn eachline(js, lines => {\n\t\treturn lines.filter(ok);\n\t});\n}\n"
						},
						{
							"line": 95,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "js",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "[tabs]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Preserve indent level also on empty lines. In the final rendering, we will style this whitespace with CSS to render the vertical \"line art\", it was however easier to perform this operation now instead of later. ",
							"code": "function indent(js, tabs = '') {\n\tconst empty = line => line === '';\n\tconst level = line => /^\\t*/.exec(line)[0];\n\treturn eachline(js, lines => {\n\t\treturn lines.map(line => {\n\t\t\ttabs = empty(line) ? tabs : level(line);\n\t\t\treturn empty(line) ? tabs : line;\n\t\t});\n\t});\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/docs/src/js/compiler/index.js": {
			"title": "index",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import fs from 'fs';\nimport path from 'path';\nimport { parse } from './parsedocument';\nimport { index } from './indexfiletree';\n"
						},
						{
							"line": 4,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Array<string>}",
									"desc": "files",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "[options]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Result}",
									"desc": "",
									"text": "mapping filename(s) to compiled JS code"
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export function compile(files, options = {}) {\n\tfiles = Array.isArray(files) ? files : [files];\n\tconst docs = begin(Object.create(null), files, options);\n\tconst tree = index(Object.keys(docs));\n\treturn { tree, docs };\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 16,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "result",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<string>}",
									"desc": "files",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "options",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object<string,DocModel>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function begin(result, files, options) {\n\tfiles.forEach(file => {\n\t\tconst text = read(file);\n\t\tconst type = path.extname(file);\n\t\tconst title = path.basename(file, type);\n\t\tresult[file] = parse(type, title, text);\n\t});\n\treturn result;\n}\n"
						},
						{
							"line": 31,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "filepath",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function read(filepath) {\n\treturn fs.readFileSync(filepath, { encoding: 'UTF-8' });\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/docs/src/js/compiler/indexfiletree.js": {
			"title": "indexfiletree",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import TreeModel from '../models/tree/TreeModel';\n"
						},
						{
							"line": 1,
							"tags": [
								{
									"name": "@param",
									"type": "{Array<string>}",
									"desc": "sources",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{TreeModel}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Parse list of strings into directory structure and return the root folder. ",
							"code": "export function index(sources) {\n\tconst steps = [step1, step2, step3, step4, step5];\n\treturn new TreeModel(\n\t\tsteps.reduce((input, nextstep) => {\n\t\t\treturn nextstep(input);\n\t\t}, sources)\n\t);\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 14,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "function step1(sources) {\n\tconst map = Object.create(null);\n\tfunction next(source, parts, map) {\n\t\tlet part = parts.shift();\n\t\tif (!parts.length) {\n\t\t\tmap[part] = source;\n\t\t} else {\n\t\t\tmap[part] = map[part] || Object.create(null);\n\t\t\tnext(source, parts, map[part]);\n\t\t}\n\t}\n\tsources.forEach(src => next(src, src.split('/'), map));\n\treturn map;\n}\nfunction step2(map) {\n\tconst root = { name: '/', nodes: [] };\n\treturn (function next(map, parent, level) {\n\t\tObject.keys(map).forEach(key => {\n\t\t\tlet val = map[key];\n\t\t\tlet node = { name: key };\n\t\t\tif (typeof val === 'object') {\n\t\t\t\tnode.nodes = [];\n\t\t\t\tnode.open = level < 1;\n\t\t\t\tnext(val, node, level + 1);\n\t\t\t} else {\n\t\t\t\tnode.src = val;\n\t\t\t}\n\t\t\tparent.nodes.push(node);\n\t\t});\n\t\treturn parent;\n\t})(map, root, 0);\n}\nfunction step3(folder) {\n\tlet is,\n\t\tnodes = folder.nodes;\n\tconst alpha = (n1, n2) => {\n\t\treturn n1.name < n2.name ? -1 : n1.name > n2.name ? 1 : 0;\n\t};\n\tfolder.nodes = nodes\n\t\t.filter(node => {\n\t\t\treturn (is = node.nodes) ? step3(node) : false;\n\t\t})\n\t\t.sort(alpha)\n\t\t.concat(nodes.filter(node => !node.nodes).sort(alpha));\n\treturn folder;\n}\n"
						},
						{
							"line": 61,
							"tags": [],
							"tabs": "",
							"desc": "Reduce to minimum viable root folder. ",
							"code": "function step4(folder) {\n\twhile (folder.nodes.length === 1 && folder.nodes[0].nodes) {\n\t\tfolder = folder.nodes[0];\n\t}\n\treturn folder;\n}\n"
						},
						{
							"line": 70,
							"tags": [],
							"tabs": "",
							"desc": "Preoptimize search by stamping descendant filenames onto folders. ",
							"code": "function step5(folder) {\n\tfolder.filenames =\n\t\tfolder.filenames ||\n\t\tfolder.nodes\n\t\t\t.map(node => {\n\t\t\t\treturn node.nodes ? step5(node).filenames : node.name.toLowerCase();\n\t\t\t})\n\t\t\t.join(' ');\n\treturn folder;\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/docs/src/js/compiler/parsedocument.js": {
			"title": "parsedocument",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { format } from './formatscript';\nimport JSDocModel from '../models/docs/JSDocModel';\nimport MDDocModel from '../models/docs/MDDocModel';\nimport EDBMLDocModel from '../models/docs/EDBMLDocModel';\n"
						},
						{
							"line": 4,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "title",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "text",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{JSDocModel|MDDocModel}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Parse to model. ",
							"code": "export function parse(type, title, text) {\n\tswitch (type) {\n\t\tcase '.js':\n\t\t\treturn new JSDocModel({\n\t\t\t\ttitle: title,\n\t\t\t\tchapters: getchapters(format(text))\n\t\t\t});\n\t\t\tbreak;\n\t\tcase '.md':\n\t\t\treturn new MDDocModel({\n\t\t\t\ttitle: title,\n\t\t\t\tmarkup: '###TODO'\n\t\t\t});\n\t\t\tbreak;\n\t\tcase '.edbml':\n\t\t\treturn new EDBMLDocModel({\n\t\t\t\ttitle: title,\n\t\t\t\tchapters: getchapters(text)\n\t\t\t});\n\t\t\tbreak;\n\t}\n}\n"
						}
					]
				},
				{
					"title": "Document building ",
					"tabs": "",
					"sections": [
						{
							"line": 34,
							"tags": [
								{
									"name": "@type",
									"type": "{RegExp}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "JSDoc style comment marker. ",
							"code": "const GUTTER = /^\\s+\\* +/;\n"
						},
						{
							"line": 39,
							"tags": [
								{
									"name": "@TODO",
									"type": "Bringback0-9butaddacheckfororderedlistmarkdown",
									"desc": "",
									"text": ""
								},
								{
									"name": "@type",
									"type": "{RegExp}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Regular characters. ",
							"code": "const LETTER = /^[A-Za-z]/;\n"
						},
						{
							"line": 45,
							"tags": [
								{
									"name": "@type",
									"type": "{RegExp}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Strip leading # from header. ",
							"code": "const HEADER = /^#+\\s*/;\n"
						},
						{
							"line": 50,
							"tags": [
								{
									"name": "@type",
									"type": "{RegExp}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Comment to mark a chapter: Single line comment with some text followed by at least four dots. Chars } and { and , and ; may precede the comment. ",
							"code": "const CHAPTER = /^[\\s|{|}|,|;]*\\/\\/\\s*[A-Za-z0-9 ]*\\s*\\.{4,}$/;\n"
						},
						{
							"line": 57,
							"tags": [
								{
									"name": "@type",
									"type": "{RegExp}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Extract chapter title (from regexp above). ",
							"code": "const TITLE = /[A-Za-z0-9]+ [A-Za-z0-9 ]*/;\n"
						},
						{
							"line": 62,
							"tags": [
								{
									"name": "@type",
									"type": "{RegExp}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Hello. ",
							"code": "const HELLO = /^[\\s|{|}|,|;]*/;\n"
						},
						{
							"line": 67,
							"tags": [
								{
									"name": "@type",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "We'll replace newlines in texttual comments with a space. ",
							"code": "const SPACE = ' ';\n"
						},
						{
							"line": 72,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "source",
									"text": ""
								},
								{
									"name": "@return",
									"type": "{Array<ChapterModel>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Parse source code to chapters. ",
							"code": "function getchapters(source) {\n\tlet comment = false;\n\tlet chapter = null;\n\tlet section = null;\n\tlet chapters = [];\n\tlet sections = [];\n\tconst nextchapter = (title = '', tabs = '') => {\n\t\tif (chapter) {\n\t\t\tchapter.sections = sections;\n\t\t\tchapters.push(chapter);\n\t\t}\n\t\tchapter = {\n\t\t\ttitle: title,\n\t\t\ttabs: tabs\n\t\t};\n\t\tsections = [];\n\t};\n\tconst nextsection = line => {\n\t\tif (section && interesting(section)) {\n\t\t\tsections.push(section);\n\t\t}\n\t\tsection = {\n\t\t\tline: line || 0,\n\t\t\ttags: [],\n\t\t\ttabs: '',\n\t\t\tdesc: '',\n\t\t\tcode: ''\n\t\t};\n\t};\n\tconst indentlevel = line => {\n\t\treturn /^\\t*/.exec(line)[0];\n\t};\n\tnextsection();\n\tnextchapter();\n\tsource.split('\\n').forEach((line, index) => {\n\t\tlet md,\n\t\t\ttrim = line.trim();\n\t\tif (comment) {\n\t\t\tif (trim.startsWith('*/')) {\n\t\t\t\tcomment = false;\n\t\t\t} else {\n\t\t\t\tif (trim === '*') {\n\t\t\t\t\tsection.desc += '\\n\\n';\n\t\t\t\t} else {\n\t\t\t\t\tmd = line.replace(GUTTER, '');\n\t\t\t\t\tswitch (md[0]) {\n\t\t\t\t\t\tcase '@':\n\t\t\t\t\t\t\tconst json = gettag(md);\n\t\t\t\t\t\t\tsection.tags.push(json);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '#':\n\t\t\t\t\t\t\tsection.desc += '\\n' + md + '\\n\\n';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tif (!md.match(LETTER)) {\n\t\t\t\t\t\t\t\tsection.desc += '\\n';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsection.desc += encode(md) + SPACE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (line.match(CHAPTER)) {\n\t\t\t\tlet title = TITLE.exec(line);\n\t\t\t\tlet tabs = indentlevel(line);\n\t\t\t\tsection.tabs = tabs;\n\t\t\t\tnextsection(index);\n\t\t\t\tnextchapter(title ? title[0] : '', tabs);\n\t\t\t\tsection.code += HELLO.exec(line);\n\t\t\t} else {\n\t\t\t\tif (trim.startsWith('/**')) {\n\t\t\t\t\tsection.tabs = indentlevel(line);\n\t\t\t\t\tcomment = true;\n\t\t\t\t\tnextsection(index);\n\t\t\t\t} else {\n\t\t\t\t\tsection.code += line + '\\n';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\tnextsection();\n\tnextchapter();\n\treturn chapters;\n}\n"
						},
						{
							"line": 162,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "section",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Dispose sections without any code or comments. ",
							"code": "function interesting({ code, desc }) {\n\treturn !!(code.trim() + desc.trim()).length;\n}\n"
						},
						{
							"line": 170,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "md",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Compute JSON for TagModel constructor argument. ",
							"code": "function gettag(md) {\n\tconst parts = md.split(/ +/); \n\tconst json = {\n\t\tname: '',\n\t\ttype: '',\n\t\tdesc: '', \n\t\ttext: ''\n\t};\n\tparts.forEach(part => {\n\t\tswitch (part[0]) {\n\t\t\tcase '@':\n\t\t\t\tjson.name = part;\n\t\t\t\tbreak;\n\t\t\tcase '{':\n\t\t\t\tjson.type = part; \n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (json.type.endsWith('}')) {\n\t\t\t\t\thello(json, part);\n\t\t\t\t} else {\n\t\t\t\t\tjson.type += part;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t});\n\tjson.text = json.text.trim(); \n\treturn json;\n}\n"
						},
						{
							"line": 203,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "json",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "part",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: Work much on this. ",
							"code": "function hello(json, part) {\n\tswitch (json.name) {\n\t\tcase '@return':\n\t\tcase '@returns':\n\t\t\tjson.text += part + ' ';\n\t\t\tbreak;\n\t\tcase '@param':\n\t\t\tif (json.desc) {\n\t\t\t\tjson.text += part + ' ';\n\t\t\t} else {\n\t\t\t\tjson.desc += part;\n\t\t\t}\n\t\t\tbreak;\n\t}\n}\n"
						},
						{
							"line": 223,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "string",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Encode string as HTML. ",
							"code": "function encode(string) {\n\treturn string\n\t\t.replace(/&(?!\\w+;)/g, '&amp;')\n\t\t.replace(/</g, '&lt;')\n\t\t.replace(/>/g, '&gt;');\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/docs/src/js/index.js": {
			"title": "index",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import RootSpirit from './spirits/docs-root/RootSpirit';\nimport TreeSpirit from './spirits/docs-tree/TreeSpirit';\nimport CodeSpirit from './spirits/docs-code/CodeSpirit';\nimport { channeling, boot as bootstrap } from 'dataplastique';\n"
						},
						{
							"line": 4,
							"tags": [],
							"tabs": "",
							"desc": "Boot everything. ",
							"code": "export function boot() {\n\tchanneling([\n\t\t['docs-root', RootSpirit],\n\t\t['docs-tree', TreeSpirit],\n\t\t['docs-code', CodeSpirit]\n\t]);\n\tbootstrap(...arguments);\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/docs/src/js/models/docs/DocModel.js": {
			"title": "DocModel",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { Model } from 'dataplastique';\n"
						},
						{
							"line": 1,
							"tags": [],
							"tabs": "",
							"desc": "Document base. ",
							"code": "export default class DocModel extends Model {\n\tstatic model() {\n\t\treturn {\n\t\t\ttype: String\n\t\t};\n\t}\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/docs/src/js/models/docs/EDBMLDocModel.js": {
			"title": "EDBMLDocModel",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import JSDocModel from './JSDocModel';\n"
						},
						{
							"line": 1,
							"tags": [],
							"tabs": "",
							"desc": "EDBML document. ",
							"code": "export default class EDBMLDocModel extends JSDocModel {\n\ttype = 'text/edbml';\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/docs/src/js/models/docs/JSDocModel.js": {
			"title": "JSDocModel",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import DocModel from './DocModel';\nimport { Model } from 'dataplastique';\nimport { Collection } from 'dataplastique';\n"
						},
						{
							"line": 3,
							"tags": [],
							"tabs": "",
							"desc": "JavaScript document. ",
							"code": "export default class JSDocModel extends DocModel {\n\ttype = 'text/javascript';\n\tstatic model() {\n\t\treturn {\n\t\t\ttitle: String,\n\t\t\tchapters: Collection.$of(ChapterModel)\n\t\t};\n\t}\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 16,
							"tags": [],
							"tabs": "",
							"desc": "Hello. ",
							"code": "class ChapterModel extends Model {\n\tstatic model() {\n\t\treturn {\n\t\t\ttitle: String,\n\t\t\ttabs: String,\n\t\t\tsections: Collection.$of(SectionModel)\n\t\t};\n\t}\n}\n"
						},
						{
							"line": 28,
							"tags": [],
							"tabs": "",
							"desc": "Hello. ",
							"code": "class SectionModel extends Model {\n\tstatic model() {\n\t\treturn {\n\t\t\tline: Number,\n\t\t\ttabs: String,\n\t\t\thead: String,\n\t\t\tdesc: String,\n\t\t\tcode: String,\n\t\t\ttags: Collection.$of(TagModel)\n\t\t};\n\t}\n}\n"
						},
						{
							"line": 43,
							"tags": [],
							"tabs": "",
							"desc": "Modelling a JSDoc `@whatever` statement. ",
							"code": "class TagModel extends Model {\n\tstatic model() {\n\t\treturn {\n\t\t\ttext: String,\n\t\t\tdesc: String,\n\t\t\tname: String,\n\t\t\ttype: String\n\t\t};\n\t}\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/docs/src/js/models/docs/MDDocModel.js": {
			"title": "MDDocModel",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import DocModel from './DocModel';\n"
						},
						{
							"line": 1,
							"tags": [],
							"tabs": "",
							"desc": "Markdown document. ",
							"code": "export default class MDDocModel extends DocModel {\n\ttype = 'text/markdown';\n\tstatic model() {\n\t\treturn {\n\t\t\ttitle: String,\n\t\t\tmarkup: String\n\t\t};\n\t}\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/docs/src/js/models/tree/FileModel.js": {
			"title": "FileModel",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import NodeModel from './NodeModel';\n"
						},
						{
							"line": 1,
							"tags": [],
							"tabs": "\t",
							"desc": "File model. ",
							"code": "export default class FileModel extends NodeModel {\n"
						},
						{
							"line": 5,
							"tags": [
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Interface. ",
							"code": "\tstatic model() {\n\t\treturn {\n\t\t\tsrc: String, \n\t\t\ttype: String, \n\t\t\twhat: String, \n\t\t\tselected: Boolean\n\t\t};\n\t}\n"
						},
						{
							"line": 17,
							"tags": [
								{
									"name": "@param",
									"type": "{String}",
									"desc": "term",
									"text": ""
								},
								{
									"name": "@return",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Filename matches term? Used in search. ",
							"code": "\tmatches(term) {\n\t\treturn this.name.toLowerCase().includes(term.trim().toLowerCase());\n\t}\n"
						},
						{
							"line": 25,
							"tags": [
								{
									"name": "@returns",
									"type": "{String}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Compute CSS classname. ",
							"code": "\tclassname() {\n\t\treturn (\n\t\t\t'file' +\n\t\t\t(this.selected ? ' selected' : '') +\n\t\t\t(this.focused ? ' focused' : '')\n\t\t);\n\t}\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/docs/src/js/models/tree/FolderModel.js": {
			"title": "FolderModel",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { Model } from 'dataplastique';\nimport { Collection } from 'dataplastique';\nimport NodeModel from './NodeModel';\nimport FileModel from './FileModel';\n"
						},
						{
							"line": 4,
							"tags": [],
							"tabs": "\t",
							"desc": "Folder model. ",
							"code": "export default class FolderModel extends NodeModel {\n"
						},
						{
							"line": 8,
							"tags": [
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Interface. ",
							"code": "\tstatic model() {\n\t\treturn {\n\t\t\topen: Boolean,\n\t\t\tfilenames: String, \n\t\t\tnodes: Collection.$of(json => (json.nodes ? FolderModel : FileModel))\n\t\t};\n\t}\n"
						},
						{
							"line": 19,
							"tags": [],
							"tabs": "\t",
							"desc": "Stamp reverse relationships. ",
							"code": "\tonconstruct() {\n\t\tsuper.onconstruct();\n\t\tthis.nodes.forEach(node => (node.$parent = this));\n\t\tthis.open = false; \n\t}\n"
						},
						{
							"line": 27,
							"tags": [
								{
									"name": "@param",
									"type": "{String}",
									"desc": "term",
									"text": ""
								},
								{
									"name": "@return",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Search for filesname in this and descendant folders. ",
							"code": "\tmatches(term) {\n\t\treturn this.filenames.includes(term.trim().toLowerCase());\n\t}\n"
						},
						{
							"line": 35,
							"tags": [
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Compute CSS classname. ",
							"code": "\tclassname() {\n\t\treturn (\n\t\t\t'folder' + (this.open ? ' open' : '') + (this.focused ? ' focused' : '')\n\t\t);\n\t}\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/docs/src/js/models/tree/NodeModel.js": {
			"title": "NodeModel",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { Model } from 'dataplastique';\n"
						},
						{
							"line": 1,
							"tags": [
								{
									"name": "@see",
									"type": "{FileModel}",
									"desc": "",
									"text": ""
								},
								{
									"name": "@see",
									"type": "{FolderModel}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Base model for files and folders. ",
							"code": "export default class NodeModel extends Model {\n"
						},
						{
							"line": 7,
							"tags": [
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Interface. ",
							"code": "\tstatic model() {\n\t\treturn {\n\t\t\tname: String,\n\t\t\tresult: Boolean,\n\t\t\tfocused: Boolean,\n\t\t\t$parent: NodeModel\n\t\t};\n\t}\n"
						},
						{
							"line": 19,
							"tags": [
								{
									"name": "@returns",
									"type": "{NodeModel}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Previous sibling. ",
							"code": "\tprev() {\n\t\treturn this.sibling(-1);\n\t}\n"
						},
						{
							"line": 26,
							"tags": [
								{
									"name": "@returns",
									"type": "{NodeModel}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Next sibling. ",
							"code": "\tnext() {\n\t\treturn this.sibling(+1);\n\t}\n"
						},
						{
							"line": 33,
							"tags": [
								{
									"name": "@param",
									"type": "{number}",
									"desc": "index",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{NodeModel}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Sibling at relative index. ",
							"code": "\tsibling(index) {\n\t\tif (this.$parent) {\n\t\t\tlet siblings = this.$parent.nodes;\n\t\t\tlet i = siblings.indexOf(this);\n\t\t\tlet n = siblings[i + index];\n\t\t\treturn n || null;\n\t\t}\n\t\treturn null;\n\t}\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/docs/src/js/models/tree/TreeModel.js": {
			"title": "TreeModel",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import NodeModel from './NodeModel';\nimport FolderModel from './FolderModel';\n"
						},
						{
							"line": 2,
							"tags": [],
							"tabs": "\t",
							"desc": "Tree model. ",
							"code": "export default class TreeModel extends FolderModel {\n"
						},
						{
							"line": 6,
							"tags": [
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Interface. ",
							"code": "\tstatic model() {\n\t\treturn {\n\t\t\tsearch: String,\n\t\t\tfocusnode: NodeModel,\n\t\t\tselectednode: NodeModel\n\t\t};\n\t}\n"
						},
						{
							"line": 17,
							"tags": [],
							"tabs": "\t",
							"desc": "Hello. ",
							"code": "\tonconstruct() {\n\t\tsuper.onconstruct();\n\t\tthis.search = '';\n\t\tthis.addObserver(this);\n\t}\n"
						},
						{
							"line": 25,
							"tags": [
								{
									"name": "@param",
									"type": "{Model}",
									"desc": "model",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{*}",
									"desc": "newval",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{*}",
									"desc": "oldval",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Set default focus while searching. ",
							"code": "\tonpoke(model, name, newval, oldval = '') {\n\t\tif (name === 'search') {\n\t\t\tnewval = newval.trim();\n\t\t\toldval = oldval.trim();\n\t\t\tif (newval.length !== oldval.length) {\n\t\t\t\tthis.search = newval;\n\t\t\t} else {\n\t\t\t\tthis._focusdefault(newval);\n\t\t\t}\n\t\t}\n\t}\n"
						},
						{
							"line": 43,
							"tags": [
								{
									"name": "@param",
									"type": "{String}",
									"desc": "src",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{this}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Focus node to match current document. ",
							"code": "\tonload(src) {\n\t\tlet node;\n\t\tif (src && (node = node = this._getnode(src))) {\n\t\t\tthis._select(node);\n\t\t\tthis._focus(node);\n\t\t}\n\t\treturn this;\n\t}\n"
						},
						{
							"line": 56,
							"tags": [
								{
									"name": "@param",
									"type": "{String}",
									"desc": "key",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "On navigation key pressed, move focus to next node. ",
							"code": "\tmovefocus(key) {\n\t\tlet next = this._nextfocus(key, this.focusnode);\n\t\tif (next) {\n\t\t\tthis._focus(next);\n\t\t}\n\t}\n"
						}
					]
				},
				{
					"title": "Private ",
					"tabs": "\t",
					"sections": [
						{
							"line": 67,
							"tags": [
								{
									"name": "@param",
									"type": "{NodeModel}",
									"desc": "newnode",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Set selected node. Unselect old node. ",
							"code": "\t_select(newnode) {\n\t\tlet oldnode;\n\t\tif ((oldnode = this.selectednode)) {\n\t\t\toldnode.selected = false;\n\t\t}\n\t\tthis.selectednode = newnode;\n\t\tnewnode.selected = true;\n\t}\n"
						},
						{
							"line": 79,
							"tags": [
								{
									"name": "@param",
									"type": "{NodeModel}",
									"desc": "newnode",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Set focused node. Unfocus old node. ",
							"code": "\t_focus(newnode) {\n\t\tlet oldnode;\n\t\tif ((oldnode = this.focusnode)) {\n\t\t\toldnode.focused = false;\n\t\t}\n\t\tif ((this.focusnode = newnode || null)) {\n\t\t\tnewnode.focused = true;\n\t\t\twhile ((newnode = newnode.$parent)) {\n\t\t\t\tnewnode.open = true;\n\t\t\t}\n\t\t}\n\t}\n"
						},
						{
							"line": 95,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "query",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\t_focusdefault(query) {\n\t\tlet files = this._matchingfiles(query);\n\t\tif (files.indexOf(this.focusnode) === -1) {\n\t\t\tthis._focus(files[0]);\n\t\t}\n\t}\n"
						},
						{
							"line": 104,
							"tags": [
								{
									"name": "@param",
									"type": "{String}",
									"desc": "key",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{NodeModel}",
									"desc": "node",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{NodeModel}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Find next node. Somewhat recursively if there's a search going on. ",
							"code": "\t_nextfocus(key, node) {\n\t\tlet next;\n\t\tlet nodes;\n\t\tlet q = this.search;\n\t\tconst isopen = node => node.nodes && (node.open || (q && node.matches(q)));\n\t\tconst hasnodes = node => node.nodes && node.nodes.length;\n\t\tconst hasparent = node => node.$parent && node.$parent !== this;\n\t\tswitch (key) {\n\t\t\tcase 'Up':\n\t\t\t\tif ((next = node.prev())) {\n\t\t\t\t\twhile (isopen(next) && hasnodes(next)) {\n\t\t\t\t\t\tnodes = next.nodes;\n\t\t\t\t\t\tnext = nodes[nodes.length - 1];\n\t\t\t\t\t}\n\t\t\t\t} else if (hasparent(node)) {\n\t\t\t\t\tnext = node.$parent;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'Down':\n\t\t\t\tif (isopen(node)) {\n\t\t\t\t\tnext = node.nodes[0];\n\t\t\t\t} else {\n\t\t\t\t\tnext = node.next();\n\t\t\t\t\twhile (!next && hasparent(node)) {\n\t\t\t\t\t\tnext = node.$parent.next();\n\t\t\t\t\t\tnode = node.$parent;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'Left':\n\t\t\t\tif (node.nodes && isopen(node)) {\n\t\t\t\t\tnode.open = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'Right':\n\t\t\t\tif (node.nodes && !isopen(node)) {\n\t\t\t\t\tnode.open = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tif (next && q) {\n\t\t\tif (!next.matches(q)) {\n\t\t\t\tnext = this._nextfocus(key, next);\n\t\t\t}\n\t\t}\n\t\treturn next;\n\t}\n"
						},
						{
							"line": 157,
							"tags": [
								{
									"name": "@todo",
									"type": "Probablyindexthisonce",
									"desc": "",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{String}",
									"desc": "src",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{NodeModel}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Get node for src. ",
							"code": "\t_getnode(src) {\n\t\tlet hit = null;\n\t\t(function search(folder) {\n\t\t\tfolder.nodes.every(node => {\n\t\t\t\tif (node.src === src) {\n\t\t\t\t\thit = node;\n\t\t\t\t} else if (node.nodes) {\n\t\t\t\t\tsearch(node);\n\t\t\t\t}\n\t\t\t\treturn !hit;\n\t\t\t});\n\t\t})(this);\n\t\treturn hit;\n\t}\n"
						},
						{
							"line": 177,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "query",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<NodeModel>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "\t_matchingfiles(query) {\n\t\tlet files = [];\n\t\t(function index(folder) {\n\t\t\tfolder.nodes.forEach(node => {\n\t\t\t\tif (node.nodes) {\n\t\t\t\t\tindex(node);\n\t\t\t\t} else if (node.matches(query)) {\n\t\t\t\t\tfiles.push(node);\n\t\t\t\t}\n\t\t\t});\n\t\t})(this);\n\t\treturn files;\n\t}\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/docs/src/js/spirits/docs-code/CodeSpirit.edbml": {
			"title": "CodeSpirit",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import hilite from './hilite';\nimport markup from './markup';\n\n"
						},
						{
							"line": 3,
							"tags": [
								{
									"name": "@param",
									"type": "{DocModel}",
									"desc": "[doc]",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export default function(doc) {\n\t<article>\n\t\tif (doc) {\n\t\t\t<h1>${doc.title}</h1>\n\t\t\tconst syntax = hilite(doc.type);\n\t\t\tswitch(doc.type) {\n\t\t\t\tcase 'text/javascript':\n\t\t\t\tcase 'text/edbml':\n\t\t\t\t\trenderScript(doc, syntax);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t</article>\n}\n\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 23,
							"tags": [
								{
									"name": "@param",
									"type": "{DocumentModel}",
									"desc": "doc",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Collection<ChapterModel>}",
									"desc": "doc.chapters",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "syntax",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "function renderScript({ chapters }, syntax) {\n\n\tchapters.forEach(renderChapter);\n\n"
						},
						{
							"line": 32,
							"tags": [
								{
									"name": "@param",
									"type": "{ChapterModel}",
									"desc": "chapter",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Render chapter with potential title. ",
							"code": "\tfunction renderChapter({ title, sections, tabs }) {\n\t\tif(title) {\n\t\t\trenderSection({ desc: '## ' + title, tabs });\n\t\t}\n\t\tsections.forEach(renderSection);\n\t}\n\t\n"
						},
						{
							"line": 43,
							"tags": [
								{
									"name": "@param",
									"type": "{SectionModel|Object}",
									"desc": "section",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\tfunction renderSection({ desc, code, tags, line, tabs }) {\n\t\t@data-line = line;\n\t\t<section @data-line>\n\t\t\t<div class=\"docs\">\n\t\t\t\t<div class=\"desc\">\n\t\t\t\t\tout(markup(desc));\n\t\t\t\t</div>\n\t\t\t\trenderTags(tags);\n\t\t\t</div>\n\t\t\t<div class=\"code\">\n\t\t\t\t<code>\n\t\t\t\t\tout(code ? syntax(code) : '');\n\t\t\t\t\t<span class=\"indent\">\n\t\t\t\t\t\tout(tabs);\n\t\t\t\t\t</span>\n\t\t\t\t</code>\n\t\t\t</div>\n\t\t</section>\n\t}\n\n"
						},
						{
							"line": 66,
							"tags": [
								{
									"name": "@param",
									"type": "{Collection<TagModel>}",
									"desc": "tags",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\tfunction renderTags(tags) {\n\t\tif(tags && tags.length) {\n\t\t\t<ol class=\"tags\">\n\t\t\t\ttags.forEach(renderTag);\n\t\t\t</ol>\n\t\t}\n\t}\n\n"
						},
						{
							"line": 77,
							"tags": [
								{
									"name": "@param",
									"type": "{TagModel}",
									"desc": "tag",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "\tfunction renderTag({name, type, desc, text}) {\n\t\t<li class=\"tag\">\n\t\t\t<span class=\"name\">${name}</span>\n\t\t\tif(type) {\n\t\t\t\t<span class=\"type\">${type}</span>\n\t\t\t}\n\t\t\tif (desc) {\n\t\t\t\t<span class=\"desc\">\n\t\t\t\t\tout(markup(desc));\n\t\t\t\t</span>\n\t\t\t}\n\t\t\tif (text) {\n\t\t\t\t<span class=\"text\">\n\t\t\t\t\tout(markup(text));\n\t\t\t\t</span>\n\t\t\t}\n\t\t</li>\n\t}\n}\n\n"
						}
					]
				}
			],
			"type": "text/edbml"
		},
		"packages/docs/src/js/spirits/docs-code/CodeSpirit.js": {
			"title": "CodeSpirit",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import edbml from './CodeSpirit.edbml.js';\nimport DocModel from '../../models/docs/DocModel';\nimport MDDocModel from '../../models/docs/MDDocModel';\nimport EDBMLDocModel from '../../models/docs/EDBMLDocModel';\nimport JSDocModel from '../../models/docs/JSDocModel';\n"
						},
						{
							"line": 5,
							"tags": [
								{
									"name": "@param",
									"type": "{Spirit}",
									"desc": "spirit",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{ScriptPlugin}",
									"desc": "spirit.script",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{IOPlugin}",
									"desc": "spirit.io",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{DOMPlugin}",
									"desc": "spirit.dom",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "spirit.element",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export default function CodeSpirit({ script, io, dom, element }) {\n\treturn {\n\t\tonattach() {\n\t\t\tscript.load(edbml);\n\t\t\tio.on({ MDDocModel, EDBMLDocModel, JSDocModel }, doc => {\n\t\t\t\tscript.run(doc);\n\t\t\t});\n\t\t},\n\t\tonrun() {\n\t\t\telement.scrollTop = 0;\n\t\t\tif (!lineart.done) {\n\t\t\t\tlineart(dom.q('.code code'));\n\t\t\t}\n\t\t}\n\t};\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 30,
							"tags": [
								{
									"name": "@param",
									"type": "{HTMLCodeElement}",
									"desc": "code",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Compute `background-image` for `span.indent` to render indent-level lines. ",
							"code": "function lineart(code) {\n\tif (code) {\n\t\taddrule(getrule(getresolver(code)));\n\t\tlineart.done = true;\n\t}\n}\n"
						},
						{
							"line": 40,
							"tags": [
								{
									"name": "@param",
									"type": "{HTMLCodeElement}",
									"desc": "code",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Function}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get CSS declaration resolver. ",
							"code": "function getresolver(code) {\n\tconst props = getComputedStyle(code, null);\n\tconst getit = name => props.getPropertyValue(name);\n\treturn name => getit(name) || getit('-moz-' + name);\n}\n"
						},
						{
							"line": 50,
							"tags": [
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "resolve",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Compute and inject CSS rule. ",
							"code": "function getrule(resolve) {\n\treturn `.indent, .code code:after { background: url(\"${draw(\n\t\tfontshorthand(resolve),\n\t\tdecorationals(resolve)\n\t)}\"); }`;\n}\n"
						},
						{
							"line": 61,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "rule",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Adding new CSS rule. TODO: In theme sheet! TODO: On theme change! ",
							"code": "function addrule(rule) {\n\tconst sheet = document.styleSheets[0];\n\tsheet.insertRule(rule, sheet.cssRules.length);\n}\n"
						},
						{
							"line": 71,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "font",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Draw the line art as Base64. ",
							"code": "function draw(font, [linecolor, tabsize]) {\n\tconst canvas = document.createElement('canvas');\n\tconst context = canvas.getContext('2d');\n\tcontext.font = font;\n\t(tabwidth => {\n\t\tcanvas.height = 100;\n\t\tcanvas.width = tabwidth * tabsize;\n\t\tcontext.fillStyle = linecolor;\n\t\tcontext.fillRect(0, 0, 1, 100);\n\t})(context.measureText('\\t').width);\n\treturn canvas.toDataURL('image/png');\n}\n"
						},
						{
							"line": 88,
							"tags": [
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "resolve",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Resolve typography shorthand. ",
							"code": "function fontshorthand(resolve) {\n\treturn ['font-weight', 'font-style', 'font-size', 'font-family']\n\t\t.map(resolve)\n\t\t.join(' ');\n}\n"
						},
						{
							"line": 98,
							"tags": [
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "resolve",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<string>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Resolve tab size and line color (`border-left-color` has been hijacked to control the line art color). ",
							"code": "function decorationals(resolve) {\n\treturn ['border-left-color', 'tab-size'].map(resolve);\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/docs/src/js/spirits/docs-code/hilite.js": {
			"title": "hilite",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "const indent = html => html.replace(/^(\\s+)/, '<span class=\"indent\">$1</span>');\nconst inline = html => `<span class=\"line\">${html}</span>`;\n"
						},
						{
							"line": 2,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Function}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "The highlighter. There can be only one. ",
							"code": "export default function hilite(type) {\n\treturn code => format(Prism.highlight(code.trimRight(), lookup(type)));\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 11,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Function}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get highlighter for file type. ",
							"code": "function lookup(type) {\n\tswitch (type) {\n\t\tcase 'text/javascript':\n\t\t\treturn Prism.languages.javascript;\n\t\tcase 'text/edbml':\n\t\t\treturn Prism.languages.jsx;\n\t\tdefault:\n\t\t\treturn Prism.languages.text;\n\t}\n}\n"
						},
						{
							"line": 26,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "html",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Line art formatting. \n- Wrap leading whitespace in `span.indent` (so we can style it) \n- Wrap each individual line in `span.line` (to control lineheight) ",
							"code": "function format(html) {\n\treturn html\n\t\t.split('\\n')\n\t\t.map(indent)\n\t\t.map(inline)\n\t\t.join('');\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/docs/src/js/spirits/docs-code/markup.js": {
			"title": "markup",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "const converter = new showdown.Converter({ simplifiedAutoLink: true });\n"
						},
						{
							"line": 1,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "markdown",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Convert Markdown to markup. ",
							"code": "export default function markup(markdown) {\n\treturn converter.makeHtml(markdown || '');\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/docs/src/js/spirits/docs-root/RootSpirit.js": {
			"title": "RootSpirit",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import JSDocModel from '../../models/docs/JSDocModel';\nimport MDDocModel from '../../models/docs/MDDocModel';\nimport EDBMLDocModel from '../../models/docs/EDBMLDocModel';\nimport TreeModel from '../../models/tree/TreeModel';\n"
						},
						{
							"line": 4,
							"tags": [
								{
									"name": "@type",
									"type": "{Map<string,Object>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "let docs = null;\n"
						},
						{
							"line": 8,
							"tags": [
								{
									"name": "@type",
									"type": "{TreeModel}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "let tree = null;\n"
						},
						{
							"line": 12,
							"tags": [
								{
									"name": "@param",
									"type": "{Spirit}",
									"desc": "spirit",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{EventPlugin}",
									"desc": "spirit.event",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export default function RootSpirit() {\n\tconst hash = (location.hash || '#').slice(1);\n\tfetch('index.json').then(response => {\n\t\tif (response.ok) {\n\t\t\taddEventListener('hashchange', () => {\n\t\t\t\tload(location.hash.slice(1));\n\t\t\t});\n\t\t\tresponse\n\t\t\t\t.json()\n\t\t\t\t.then(json => {\n\t\t\t\t\tdocs = new Map(Object.entries(json.docs));\n\t\t\t\t\ttree = new TreeModel(json.tree).onload(hash).output();\n\t\t\t\t})\n\t\t\t\t.then(() => {\n\t\t\t\t\tif (hash) {\n\t\t\t\t\t\tload(hash);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.catch(x => {\n\t\t\t\t\tconsole.error(x);\n\t\t\t\t});\n\t\t} else {\n\t\t\tthrow new Error('Wrong answer', e.message);\n\t\t}\n\t});\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 43,
							"tags": [
								{
									"name": "@param",
									"type": "{String}",
									"desc": "path",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Instruct the Tree to update the position and then output the relevant data as a {Document}. Unless it's the first rendering, we break this up with a timeout for instant feedback in the tree (in case syntax hiliting is slow). TODO: Handle 404 somewhat more elegantly here ",
							"code": "function load(path) {\n\tconst success = docs.has(path);\n\tdocument.title = `Docs — ${success ? name(path) : 404}`;\n\tif (success) {\n\t\ttree.onload(path);\n\t\tfunction output() {\n\t\t\tconst json = docs.get(path);\n\t\t\tnew (model(json))(json).output();\n\t\t}\n\t\tif (load.next) {\n\t\t\tsetTimeout(output, 10);\n\t\t} else {\n\t\t\tload.next = true;\n\t\t\toutput();\n\t\t}\n\t} else {\n\t\tconsole.error(404, path);\n\t}\n}\n"
						},
						{
							"line": 69,
							"tags": [
								{
									"name": "@param",
									"type": "{object}",
									"desc": "json",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Constructor}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get approriate model for given data. ",
							"code": "function model(json) {\n\treturn {\n\t\t'text/javascript': JSDocModel,\n\t\t'text/edbml': EDBMLDocModel,\n\t\t'text/markdown': MDDocModel\n\t}[json.type];\n}\n"
						},
						{
							"line": 81,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "path",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Produce file name from full path. ",
							"code": "function name(path) {\n\tlet cuts = path.split('/');\n\tlet name = cuts.pop() || '';\n\tif ((cuts = name.split('.')).length) {\n\t\tcuts.pop();\n\t}\n\treturn cuts.join('.');\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/docs/src/js/spirits/docs-tree/TreeSpirit.edbml": {
			"title": "TreeSpirit",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [
								{
									"name": "@param",
									"type": "{TreeModel}",
									"desc": "[tree]",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export default function(tree) {\n\tif(tree) {\n\t\t<header guid=\"header\">\n\t\t\trenderHeader(tree);\n\t\t</header>\n\t\t<nav guid=\"nav\">\n\t\t\trenderNodes(tree.nodes, tree.search);\n\t\t</nav>\n\t}\n}\n\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 16,
							"tags": [
								{
									"name": "@param",
									"type": "{TreeModel}",
									"desc": "tree",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function renderHeader(tree) {\n\t<form>\n\t\t<input placeholder=\"Search filename\" guid=\"search\" type=\"text\" +\n\t\t\tautocomplete=\"off\" spellcheck=\"false\" placeholder=\"Search files\" +\n\t\t\tvalue=\"${tree.search}\" on:input=\"${tree.search = value}\"/>\n\t</form>\n\t<menu>\n\t\t<li>\n\t\t\t<button class=\"icon icon-sidebar\" title=\"Toggle SideBar\"></button>\n\t\t</li>\n\t</menu>\n}\n\n"
						},
						{
							"line": 32,
							"tags": [
								{
									"name": "@param",
									"type": "{Collection<FileModel|FolderModel>}",
									"desc": "nodes",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "search",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function renderNodes(nodes, search) {\n\tconst visible = node => !search || node.matches(search);\n\tconst present = node => renderNode(node, search);\n\t<ul>\n\t\tnodes.filter(visible).forEach(present);\n\t</ul>\n}\n\n"
						},
						{
							"line": 44,
							"tags": [
								{
									"name": "@param",
									"type": "{FileModel|FolderModel}",
									"desc": "next",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "search",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function renderNode(node, search) {\n\t<li guid=\"${node.$id}\" class=\"${node.classname()}\">\n\t\tswitch (node.constructor.name) {\n\t\t\tcase 'FileModel':\n\t\t\t\t<a class=\"label\" href=\"#${node.src}\">${node.name}</a>\n\t\t\t\tbreak;\n\t\t\tcase 'FolderModel':\n\t\t\t\t<span guid=\"${node.$id}-span\" class=\"label\" +\n\t\t\t\t\ton:click=\"${node.open = !node.open}\">${node.name}</span>\n\t\t\t\tif(search || node.open) {\n\t\t\t\t\trenderNodes(node.nodes, search);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t</li>\n}\n\n"
						}
					]
				}
			],
			"type": "text/edbml"
		},
		"packages/docs/src/js/spirits/docs-tree/TreeSpirit.js": {
			"title": "TreeSpirit",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import TreeModel from '../../models/tree/TreeModel';\nimport edbml from './TreeSpirit.edbml.js';\n"
						},
						{
							"line": 2,
							"tags": [
								{
									"name": "@param",
									"type": "{Spirit}",
									"desc": "spirit",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{IOPlugin}",
									"desc": "spirit.io",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{ScriptPlugin}",
									"desc": "spirit.script",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Spirit of the file navigator. ",
							"code": "export default function TreeSpirit({ io, script }) {\n\tscript.load(edbml);\n\tio.on(TreeModel, tree => {\n\t\tscript.run(tree);\n\t});\n}\n\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edb-plugins/src/IOPlugin.js": {
			"title": "IOPlugin",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import Tracker from './Tracker';\nimport { Model } from '@dataplastique/edb';\nimport { IMap } from '@dataplastique/util';\n"
						},
						{
							"line": 3,
							"tags": [
								{
									"name": "@type",
									"type": "{Symbol}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Workaroundy timestamp thing. ",
							"code": "const timestamp = Symbol.for('dataplastique:timestamp');\n"
						},
						{
							"line": 8,
							"tags": [],
							"tabs": "\t",
							"desc": "\n\n",
							"code": "export default class IOPlugin extends Tracker() {\n"
						},
						{
							"line": 12,
							"tags": [
								{
									"name": "@param",
									"type": "{IList<Function|IMap<Function,Function>>}",
									"desc": "pattern",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "handler",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{boolean}",
									"desc": "[one]",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\t$on(pattern, handler, one) {\n\t\tconnect(pattern);\n\t}\n"
						},
						{
							"line": 20,
							"tags": [
								{
									"name": "@param",
									"type": "{IList<Function|IMap<Function,Function>>}",
									"desc": "pattern",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "handler",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\t$off(pattern, handler) {\n\t\tdisconnect(pattern);\n\t}\n"
						},
						{
							"line": 27,
							"tags": [
								{
									"name": "@param",
									"type": "{Model}",
									"desc": "model",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "\tstatic oninput(model) {\n\t\tconst target = model.constructor;\n\t\tthis.map()\n\t\t\t.filter((handlers, pattern) => matches(pattern, target))\n\t\t\t.forEach((handlers, pattern) => {\n\t\t\t\ttrigger(handlers, collect(pattern, target));\n\t\t\t});\n\t}\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 39,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "const notnull = input => input !== null;\nconst isclass = input => typeof input === 'function';\nconst tomodel = input => (isclass(input) ? input : input.toList());\nconst outside = klass => !!klass.output();\nconst gettime = klass => klass[timestamp];\n"
						},
						{
							"line": 45,
							"tags": [
								{
									"name": "@param",
									"type": "{IList<Function|IMap<Function,Function>>}",
									"desc": "types",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Connect plugin to models. ",
							"code": "function connect(types) {\n\tconst models = types.map(tomodel).flatten();\n\tmodels.forEach(model => model.connect(IOPlugin));\n}\n"
						},
						{
							"line": 53,
							"tags": [
								{
									"name": "@param",
									"type": "{Array<Function|Object<Function,Function>>}",
									"desc": "types",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: Compare with flattened map and only disconnect if model is one entry ",
							"code": "function disconnect(types) {\n\tconsole.error('TODO!');\n}\n"
						},
						{
							"line": 60,
							"tags": [
								{
									"name": "@param",
									"type": "{IList}",
									"desc": "pattern",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Class<Model>}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function matches(pattern, target) {\n\treturn pattern.reduce((does, next) => {\n\t\treturn does || (IMap.isMap(next) ? next.includes(target) : next === target);\n\t}, false);\n}\n"
						},
						{
							"line": 70,
							"tags": [
								{
									"name": "@param",
									"type": "{Set<Function>}",
									"desc": "set",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<Class<Model>>}",
									"desc": "args",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "If all expected output has been collected, poke the associated handlers. ",
							"code": "function trigger(set, args) {\n\tif (args.every(notnull)) {\n\t\tset.forEach(handler => handler(...args));\n\t}\n}\n"
						},
						{
							"line": 80,
							"tags": [
								{
									"name": "@param",
									"type": "{IList}",
									"desc": "pattern",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Class<Model>}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<Class<Model>>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Collect output. ",
							"code": "function collect(pattern, target) {\n\treturn pattern.reduce((args, next) => {\n\t\treturn args.concat(output(IMap.isMap(next) ? latest(next) : next));\n\t}, []);\n}\n"
						},
						{
							"line": 91,
							"tags": [
								{
									"name": "@param",
									"type": "{IMap<Class<Model>,Class<Model>>}",
									"desc": "map",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Class<Model>|null}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "From types in map, get the one that was output most recently (if any). ",
							"code": "function latest(map) {\n\treturn map\n\t\t.toList()\n\t\t.filter(outside)\n\t\t.maxBy(gettime);\n}\n"
						},
						{
							"line": 102,
							"tags": [
								{
									"name": "@param",
									"type": "{Class<Model>|undefined}",
									"desc": "C",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Model|null}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get output of given type (or `null` if not). ",
							"code": "function output(C) {\n\treturn C ? C.output() : null;\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edb-plugins/src/Tracker.js": {
			"title": "Tracker",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { Plugin } from '@dataplastique/edb';\nimport { IMapping } from '@dataplastique/util';\nimport { chained, flatten, asarray, immutable } from '@dataplastique/util';\n"
						},
						{
							"line": 3,
							"tags": [
								{
									"name": "@param",
									"type": "{Class<Plugin>}",
									"desc": "[superclass]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Class<Plugin>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "TODO: Is this thing even used??? \n\nClass-mixin for tracking callbacks associated to \"patterns\" that are really just arrays of anything. The host class is expected to define some behavior. ",
							"code": "export default function(superclass = Plugin) {\n"
						},
						{
							"line": 12,
							"tags": [
								{
									"name": "@type",
									"type": "IMapping<IList,ISet<Function|Object>>",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t\t",
							"desc": "Tracking patterns and associated handlers. ",
							"code": "\tconst handlers = new IMapping();\n\treturn class Tracker extends superclass {\n"
						},
						{
							"line": 18,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Array}",
									"desc": "pattern",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Function|Object}",
									"desc": "handler",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{boolean}",
									"desc": "[once]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{this}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t\t",
							"desc": "Add handler for args. ",
							"code": "\t\t@chained\n\t\ton(pattern, handler = this.host) {\n\t\t\tpattern = normalize(pattern);\n\t\t\thandlers.add(pattern, handler);\n\t\t\tthis.$on(pattern, handler);\n\t\t}\n"
						},
						{
							"line": 31,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Array}",
									"desc": "pattern",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Function|Object}",
									"desc": "handler",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{this}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t\t",
							"desc": "Remove handler for args. ",
							"code": "\t\t@chained\n\t\toff(pattern, handler = this.host) {\n\t\t\tpattern = normalize(pattern);\n\t\t\thandlers.del(pattern, handler);\n\t\t\tthis.$off(pattern, handler);\n\t\t}\n"
						},
						{
							"line": 43,
							"tags": [
								{
									"name": "@param",
									"type": "{*|Array<*>}",
									"desc": "pattern",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Function|Object}",
									"desc": "handler",
									"text": ""
								}
							],
							"tabs": "\t\t",
							"desc": "Add handler for args to be removed once invoked. ",
							"code": "\t\t@chained\n\t\tonce(pattern, handler = this.host) {\n\t\t\tconsole.log('TODO!');\n\t\t}\n"
						},
						{
							"line": 52,
							"tags": [
								{
									"name": "@param",
									"type": "{truthy}",
									"desc": "on",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array}",
									"desc": "pattern",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Function|Object}",
									"desc": "handler",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{this}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t\t",
							"desc": "Add or remove all based on truthy first param. ",
							"code": "\t\t@chained\n\t\tshift(on, ...rest) {\n\t\t\tif (!!on) {\n\t\t\t\tthis.on(...rest);\n\t\t\t} else {\n\t\t\t\tthis.off(...rest);\n\t\t\t}\n\t\t}\n"
						},
						{
							"line": 67,
							"tags": [
								{
									"name": "@param",
									"type": "{*|Array<*>}",
									"desc": "pattern",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Function|Object}",
									"desc": "handler",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t\t",
							"desc": "Has handler for pattern registered? ",
							"code": "\t\thas(pattern, handler = this.host) {\n\t\t\treturn handlers.has(pattern, handler);\n\t\t}\n"
						}
					]
				},
				{
					"title": "Privileged ",
					"tabs": "\t\t",
					"sections": [
						{
							"line": 77,
							"tags": [
								{
									"name": "@param",
									"type": "{Array<*>}",
									"desc": "pattern",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Function|Object}",
									"desc": "handler",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{boolean}",
									"desc": "[once]",
									"text": ""
								}
							],
							"tabs": "\t\t",
							"desc": "Subclass must implement. ",
							"code": "\t\t$on(pattern, handler, once) {\n\t\t\timplementationError(this);\n\t\t}\n"
						},
						{
							"line": 86,
							"tags": [
								{
									"name": "@param",
									"type": "{Array<*>}",
									"desc": "pattern",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Function|Object}",
									"desc": "handler",
									"text": ""
								}
							],
							"tabs": "\t\t",
							"desc": "Subclass must implement. ",
							"code": "\t\t$off(pattern, handler) {\n\t\t\timplementationError(this);\n\t\t}\n"
						}
					]
				},
				{
					"title": "Static ",
					"tabs": "\t\t",
					"sections": [
						{
							"line": 95,
							"tags": [
								{
									"name": "@returns",
									"type": "{IMap<IList,ISet<Function>>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get the map of patterns and handlers. ",
							"code": "\t\tstatic map() {\n\t\t\treturn handlers.map;\n\t\t}\n\t};\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 105,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Array}",
									"desc": "pattern",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{IList}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function normalize(pattern) {\n\treturn immutable(flatten(asarray(pattern)));\n}\n"
						},
						{
							"line": 112,
							"tags": [
								{
									"name": "@param",
									"type": "{Plugin}",
									"desc": "plugin",
									"text": ""
								},
								{
									"name": "@throws",
									"type": "{Error}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "A required method was not defined in the subclass. TODO: Create some kind of ES7 decorator for this. ",
							"code": "function implementationError(plugin) {\n\tthrow new Error(`${plugin} expected an implementation`);\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edb-plugins/src/index.js": {
			"title": "index",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "export { default as Tracker } from './Tracker';\nexport { default as IOPlugin } from './IOPlugin';\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edb/src/Collection.js": {
			"title": "Collection",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import Proto from './Proto';\nimport { approximate } from './proxy/ProxyFactory';\n"
						},
						{
							"line": 2,
							"tags": [],
							"tabs": "\t",
							"desc": "\n\n",
							"code": "export default class Collection extends Proto(class extends Array {}) {\n"
						},
						{
							"line": 6,
							"tags": [
								{
									"name": "@param",
									"type": "{...*}",
									"desc": "args",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Proxy}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\tconstructor(...args) {\n\t\treturn approximate(super(), Object.create(null), args);\n\t}\n"
						},
						{
							"line": 13,
							"tags": [
								{
									"name": "@type",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Identification. ",
							"code": "\tget [Symbol.toStringTag]() {\n\t\treturn 'Collection';\n\t}\n"
						},
						{
							"line": 20,
							"tags": [
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "More identification. ",
							"code": "\ttoString() {\n\t\treturn `[collection ${this.constructor.name}]`;\n\t}\n"
						}
					]
				},
				{
					"title": "Static ",
					"tabs": "\t",
					"sections": [
						{
							"line": 28,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto|Function|null}",
									"desc": "cons",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Class<Collection>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Create anonymous collection of given type. TODO: Via symbol so that `import { Collection, of } from 'dataplastique'` ",
							"code": "\tstatic $of(cons) {\n\t\treturn class extends this {\n\t\t\tstatic collection() {\n\t\t\t\treturn cons;\n\t\t\t}\n\t\t};\n\t}\n"
						},
						{
							"line": 41,
							"tags": [
								{
									"name": "@param",
									"type": "{IMap}",
									"desc": "map",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Imap|null}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Model type interface. ",
							"code": "\tstatic model(map) {\n\t\treturn null;\n\t}\n"
						},
						{
							"line": 49,
							"tags": [
								{
									"name": "@returns",
									"type": "{Proto|Function|null}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Collection type interface. ",
							"code": "\tstatic collection() {\n\t\treturn null;\n\t}\n"
						},
						{
							"line": 56,
							"tags": [
								{
									"name": "@param",
									"type": "{IMap}",
									"desc": "map",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{IMap|null}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Framework internal. ",
							"code": "\tstatic [Symbol.for('@dataplastique/objectpipe')](map) {\n\t\treturn this.model(...arguments);\n\t}\n"
						},
						{
							"line": 64,
							"tags": [
								{
									"name": "@returns",
									"type": "{Proto|Function|null}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Framework internal. ",
							"code": "\tstatic [Symbol.for('@dataplastique/arraypipe')]() {\n\t\treturn this.collection();\n\t}\n"
						},
						{
							"line": 71,
							"tags": [
								{
									"name": "@type",
									"type": "{Array}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Should `map` and `reduce` to simple array (and not Collection). ",
							"code": "\tstatic get [Symbol.species]() {\n\t\treturn Array;\n\t}\n"
						},
						{
							"line": 78,
							"tags": [
								{
									"name": "@type",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Identification for ducks: Identify as Model. ",
							"code": "\tstatic get isModelConstructor() {\n\t\treturn true;\n\t}\n"
						},
						{
							"line": 85,
							"tags": [
								{
									"name": "@type",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Identification for ducks: Identify as Collection. ",
							"code": "\tstatic get isCollectionConstructor() {\n\t\treturn true;\n\t}\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edb/src/Model.js": {
			"title": "Model",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import Proto from './Proto';\nimport { install } from './devtools/';\nimport { approximate } from './proxy/ProxyFactory';\n"
						},
						{
							"line": 3,
							"tags": [],
							"tabs": "\t",
							"desc": "\n\n",
							"code": "export default class Model extends Proto() {\n"
						},
						{
							"line": 7,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "[object]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Proxy}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\tconstructor(object = Object.create(null)) {\n\t\treturn approximate(super(), object);\n\t}\n"
						},
						{
							"line": 14,
							"tags": [
								{
									"name": "@type",
									"type": "{String}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Identification. ",
							"code": "\tget [Symbol.toStringTag]() {\n\t\treturn 'Model';\n\t}\n"
						},
						{
							"line": 21,
							"tags": [
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "More identification. ",
							"code": "\ttoString() {\n\t\treturn `[model ${this.constructor.name}]`;\n\t}\n"
						}
					]
				},
				{
					"title": "Static ",
					"tabs": "\t",
					"sections": [
						{
							"line": 29,
							"tags": [
								{
									"name": "@param",
									"type": "{IMap}",
									"desc": "map",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Imap|null}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Model type interface. TODO: Perhaps look at [Vue](https://vuejs.org/v2/guide/components.html#Prop-Validation) to finalize the syntax for required status and default value. ",
							"code": "\tstatic model(map) {\n\t\treturn null;\n\t}\n"
						},
						{
							"line": 39,
							"tags": [
								{
									"name": "@param",
									"type": "{IMap}",
									"desc": "map",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{IMap|null}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Framework internal. ",
							"code": "\tstatic [Symbol.for('@dataplastique/objectpipe')](map) {\n\t\treturn this.model(...arguments);\n\t}\n"
						},
						{
							"line": 47,
							"tags": [
								{
									"name": "@type",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Identification for ducks. ",
							"code": "\tstatic get isModelConstructor() {\n\t\treturn true;\n\t}\n"
						},
						{
							"line": 54,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "thing",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{*}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: Is this used??? ",
							"code": "\tstatic cast(thing) {\n\t\treturn thing;\n\t}\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edb/src/Plugin.js": {
			"title": "Plugin",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import Proto from './Proto';\nimport { Type } from '@dataplastique/util';\nimport { approximate, registerPlugin } from './proxy/ProxyFactory';\n"
						},
						{
							"line": 3,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "key",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Class<Plugin>}",
									"desc": "PluginC",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Function}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Decorator to assign plugins for a Proto constructor (so a class decorator). TODO: Support some `override` arg to bypass previous assignment to same key. ",
							"code": "export function plugin(key, PluginC) {\n\treturn function plugged(ProtoC) {\n\t\tregisterPlugin(ProtoC, key, PluginC);\n\t};\n}\n"
						},
						{
							"line": 15,
							"tags": [],
							"tabs": "\t",
							"desc": "Plugin. ",
							"code": "export default class Plugin extends Proto() {\n"
						},
						{
							"line": 19,
							"tags": [
								{
									"name": "@type",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Plugins are by default not observable. Make sure to toggle this property if the plugins primary function is to store some kind of observable state. Also, the plugin cannot enforce type safety before this is toggled `true`, although this behavior should probably be controlled by a saparate flag. TODO: Separate flag! ",
							"code": "\tget $observable() {\n\t\treturn false;\n\t}\n"
						},
						{
							"line": 30,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "[object]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Proxy}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\tconstructor(object = Object.create(null)) {\n\t\tconst proxy = approximate(super(), object);\n\t\tconfirmhost(proxy, proxy.host);\n\t\treturn proxy;\n\t}\n"
						},
						{
							"line": 39,
							"tags": [
								{
									"name": "@type",
									"type": "{String}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Identification. ",
							"code": "\tget [Symbol.toStringTag]() {\n\t\treturn 'Plugin';\n\t}\n"
						},
						{
							"line": 46,
							"tags": [
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "More identification. ",
							"code": "\ttoString() {\n\t\treturn `[plugin ${this.constructor.name}]`;\n\t}\n"
						}
					]
				},
				{
					"title": "Static ",
					"tabs": "\t",
					"sections": [
						{
							"line": 54,
							"tags": [
								{
									"name": "@returns",
									"type": "{Class<Proto>|null}",
									"desc": "",
									"text": "- use `null` to simply bypass this restriction"
								}
							],
							"tabs": "\t",
							"desc": "Return a constructor here to make the Plugin only accept this type of host. ",
							"code": "\tstatic host() {\n\t\treturn null;\n\t}\n"
						},
						{
							"line": 61,
							"tags": [
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": "- If `false`, the Plugin is newed up with the host."
								}
							],
							"tabs": "\t",
							"desc": "Plugin is lazy? It will then not be instantiated until it is accessed. ",
							"code": "\tstatic lazy() {\n\t\treturn true;\n\t}\n"
						},
						{
							"line": 68,
							"tags": [
								{
									"name": "@param",
									"type": "{IMap}",
									"desc": "map",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Imap|null}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Plugin type interface. Equivalent to `static model` on {Model} classes. Note that the plugin must be toggled `$observable` for this to work out. ",
							"code": "\tstatic plugin(map) {\n\t\treturn null;\n\t}\n"
						},
						{
							"line": 77,
							"tags": [
								{
									"name": "@param",
									"type": "{IMap}",
									"desc": "map",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{IMap|null}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Framework internal. ",
							"code": "\tstatic [Symbol.for('@dataplastique/objectpipe')](map) {\n\t\treturn this.plugin(...arguments);\n\t}\n"
						},
						{
							"line": 85,
							"tags": [
								{
									"name": "@type",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Identification for ducks. ",
							"code": "\tstatic get isPluginConstructor() {\n\t\treturn true;\n\t}\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 94,
							"tags": [
								{
									"name": "@param",
									"type": "{Plugin}",
									"desc": "plugin",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "inputhost",
									"text": ""
								},
								{
									"name": "@throws",
									"type": "{TypeError}",
									"desc": "",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Proto}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function confirmhost(plugin, inputhost) {\n\tconst accepthost = plugin.constructor.host();\n\treturn accepthost === null || accepthost.is(inputhost)\n\t\t? inputhost\n\t\t: badhost(plugin, accepthost, inputhost);\n}\n"
						},
						{
							"line": 106,
							"tags": [
								{
									"name": "@throws",
									"type": "{TypeError}",
									"desc": "",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Plugin}",
									"desc": "plugin",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Constructor}",
									"desc": "accepthost",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{*}",
									"desc": "inputhost",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function badhost(plugin, accepthost, inputhost) {\n\tthrow new TypeError(\n\t\t`${plugin.constructor.name} \n\t\texpected a ${accepthost.name} host, got: ${inputhost}`\n\t);\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edb/src/Proto.js": {
			"title": "Proto",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import * as Output from './output/Output';\nimport { registerPlugin } from './proxy/ProxyFactory';\nimport { Type } from '@dataplastique/util';\nimport { chained } from '@dataplastique/util';\n"
						},
						{
							"line": 4,
							"tags": [
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "[superclass]",
									"text": "Constructor"
								},
								{
									"name": "@returns",
									"type": "{Proxy}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t\t",
							"desc": "",
							"code": "export default function mixin(superclass = class {}) {\n\treturn class Proto extends superclass {\n"
						},
						{
							"line": 10,
							"tags": [
								{
									"name": "@type",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t\t",
							"desc": "",
							"code": "\t\tget $observable() {\n\t\t\treturn true;\n\t\t}\n"
						},
						{
							"line": 16,
							"tags": [
								{
									"name": "@type",
									"type": "{String}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t\t",
							"desc": "Identification. ",
							"code": "\t\tget [Symbol.toStringTag]() {\n\t\t\treturn this.constructor.name;\n\t\t}\n"
						},
						{
							"line": 23,
							"tags": [
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t\t",
							"desc": "More identification. This should probably be rethinked once `Symbol.toStringTag` works... ",
							"code": "\t\ttoString() {\n\t\t\treturn `[proto ${this.constructor.name}]`;\n\t\t}\n"
						},
						{
							"line": 31,
							"tags": [],
							"tabs": "\t\t",
							"desc": "Painless constructor: No need to worry about constructor arguments. Whatever you would perform in the `constructor`, do it here instead. Subclass will decide, when it is appropriate to invoke this method. ",
							"code": "\t\tonconstruct() {}\n"
						},
						{
							"line": 37,
							"tags": [],
							"tabs": "\t\t",
							"desc": "Called when the {Proto} is about to be disposed. ",
							"code": "\t\tondestruct() {}\n"
						},
						{
							"line": 41,
							"tags": [
								{
									"name": "@returns",
									"type": "{this}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t\t",
							"desc": "Assign plugin to this single instance (not all instances of this class) TODO: Actually go ahead and implement this! ",
							"code": "\t\t@chained\n\t\tplugin(prefix, Plugin) {\n\t\t\tregisterPlugin(this, prefix, Plugin);\n\t\t}\n"
						},
						{
							"line": 50,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "prefix",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Class<Plugin>}",
									"desc": "Plugin",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{this}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t\t",
							"desc": "Assign plugin to this instance, overriding any previous assignment. TODO: Actually go ahead and implement this! ",
							"code": "\t\t@chained\n\t\tpluginOverride(prefix, Plugin) {\n\t\t\tregisterPlugin(this, prefix, Plugin, true);\n\t\t}\n"
						},
						{
							"line": 61,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Symbol}",
									"desc": "[scope]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{this}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t\t",
							"desc": "Output this instance. ",
							"code": "\t\t@chained\n\t\toutput(scope) {\n\t\t\tOutput.output(this, scope);\n\t\t}\n"
						},
						{
							"line": 70,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Symbol}",
									"desc": "[scope]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{this}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t\t",
							"desc": "Revoke this instance. ",
							"code": "\t\t@chained\n\t\trevoke(scope) {\n\t\t\tOutput.revoke(this, scope);\n\t\t}\n"
						}
					]
				},
				{
					"title": "Static ",
					"tabs": "\t\t",
					"sections": [
						{
							"line": 80,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "tree",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Map<string,Class<Proto>>}",
									"desc": "map",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Proto}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t\t",
							"desc": "",
							"code": "\t\tstatic sync(tree, map) {\n\t\t\treturn new this.constructor();\n\t\t}\n"
						},
						{
							"line": 88,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "thing",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t\t",
							"desc": "Some given thing is an instance of this class? ",
							"code": "\t\tstatic is(thing) {\n\t\t\treturn typeof thing === 'object' && thing instanceof this;\n\t\t}\n"
						},
						{
							"line": 96,
							"tags": [
								{
									"name": "@returns",
									"type": "{Proto}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t\t",
							"desc": "Get latest output (instance of this type). ",
							"code": "\t\tstatic output() {\n\t\t\treturn Output.get(this);\n\t\t}\n"
						},
						{
							"line": 103,
							"tags": [
								{
									"name": "@returns",
									"type": "{number}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t\t",
							"desc": "",
							"code": "\t\tstatic timestamp() {\n\t\t\treturn Output.timestamp(this);\n\t\t}\n"
						},
						{
							"line": 109,
							"tags": [
								{
									"name": "@param",
									"type": "{InputHandler}",
									"desc": "handler",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Constructor}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t\t",
							"desc": "TODO: confirm interface. ",
							"code": "\t\t@chained\n\t\tstatic connect(handler) {\n\t\t\tOutput.connect(\n\t\t\t\tthis,\n\t\t\t\thandler\n\t\t\t);\n\t\t}\n"
						},
						{
							"line": 121,
							"tags": [
								{
									"name": "@param",
									"type": "{InputHandler}",
									"desc": "handler",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Constructor}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t\t",
							"desc": "TODO: confirm interface. ",
							"code": "\t\t@chained\n\t\tstatic disconnect(handler) {\n\t\t\tOutput.disconnect(this, handler);\n\t\t}\n"
						},
						{
							"line": 130,
							"tags": [
								{
									"name": "@type",
									"type": "{String}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t\t",
							"desc": "Identification. ",
							"code": "\t\tstatic get [Symbol.toStringTag]() {\n\t\t\treturn `[class ${this.name}]`;\n\t\t}\n"
						},
						{
							"line": 137,
							"tags": [
								{
									"name": "@returns",
									"type": "{String}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t\t",
							"desc": "Because the above doesn't seem to work. ",
							"code": "\t\tstatic toString() {\n\t\t\treturn this[Symbol.toStringTag];\n\t\t}\n"
						},
						{
							"line": 144,
							"tags": [
								{
									"name": "@type",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t\t",
							"desc": "Identification for ducks. ",
							"code": "\t\tstatic get isProtoConstructor() {\n\t\t\treturn true;\n\t\t}\n"
						},
						{
							"line": 151,
							"tags": [
								{
									"name": "@returns",
									"type": "{null}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "The subclass will reroute this method call to another method. It has to do with property type checking and transformations. ",
							"code": "\t\tstatic [Symbol.for('@dataplastique/objectpipe')]() {\n\t\t\treturn null;\n\t\t}\n\t};\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edb/src/Tree.js": {
			"title": "Tree",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "\t",
							"desc": "Parsing Model structuobj into JSON-like objects and objtoobj them later on. We'll need a special format the capture the Model-aspects of a Collection. ",
							"code": "export default class Tree {\n"
						},
						{
							"line": 5,
							"tags": [
								{
									"name": "@type",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Since the tree is likely to be used in decoupled contexts, this semver could in theory be used to handle future breaking changes. ",
							"code": "\t$version = '0.0.1';\n"
						},
						{
							"line": 11,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "proto",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Tree}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Create tree from Proto instance (Model or a Collection). TODO: Handle treifyive tree structuobj (so graphs). ",
							"code": "\tstatic encode(proto) {\n\t\treturn Object.assign(new Tree(), simple(treeify(proto)));\n\t}\n"
						},
						{
							"line": 20,
							"tags": [
								{
									"name": "@param",
									"type": "{Tree|Object}",
									"desc": "tree",
									"text": "- Something that looks like a tree."
								},
								{
									"name": "@param",
									"type": "{Object<string,Class<Proto>>}",
									"desc": "map",
									"text": "- Match classname to constructor"
								},
								{
									"name": "@returns",
									"type": "{Proto}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Parse Tree structure into a Proto instance (Model or Collection). ",
							"code": "\tstatic decode(tree, map = {}) {\n\t\treturn johnson(tree, map);\n\t}\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 30,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "const constr = thing => thing.constructor;\nconst isobjt = thing => typeof thing === 'object';\nconst islist = thing => Array.isArray(thing);\nconst ismodl = thing => isobjt(thing) && constr(thing).isModelConstructor;\nconst iscoll = thing => islist(thing) && constr(thing).isCollectionConstructor;\nconst istree = thing => isobjt(thing) && thing.$tree && thing.$meta;\nconst treify = thing => (ismodl(thing) ? treeify(thing) : thing);\nconst simple = thing => JSON.parse(JSON.stringify(thing));\nconst recoll = proto => (iscoll(proto) ? proto.map(treify) : undefined);\nconst proper = proto => (iscoll(proto) ? normal : Boolean);\nconst normal = ([key]) => key !== 'length' && isNaN(Number(key));\nconst recall = (array, map) => array.map(thing => invoke(thing, map));\nconst invoke = (thing, map) => (istree(thing) ? johnson(thing, map) : thing);\n"
						}
					]
				},
				{
					"title": "Model to Tree ",
					"tabs": "",
					"sections": [
						{
							"line": 45,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "proto",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: Cannot use `constructor.name` because tools like Rollup changes it :/ ",
							"code": "function treeify(proto) {\n\treturn {\n\t\t$tree: true,\n\t\t$meta: {\n\t\t\t$cl: constr(proto).name,\n\t\t\t$id: proto.$id\n\t\t},\n\t\t$model: remodel(proto),\n\t\t$collection: recoll(proto)\n\t};\n}\n"
						},
						{
							"line": 61,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "proto",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function remodel(proto) {\n\treturn Object.entries(proto)\n\t\t.filter(proper(proto))\n\t\t.reduce(subtree, {});\n}\n"
						},
						{
							"line": 70,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "object",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array}",
									"desc": "entry",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function subtree(object, [key, val]) {\n\treturn Object.assign(object, {\n\t\t[key]: treify(val)\n\t});\n}\n"
						}
					]
				},
				{
					"title": "Tree to Model ",
					"tabs": "",
					"sections": [
						{
							"line": 81,
							"tags": [
								{
									"name": "@param",
									"type": "{Tree|Object}",
									"desc": "tree",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object<string,Class<Proto>>}",
									"desc": "map",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{undefined}",
									"desc": "impl",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Proto}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: Improved function naming ",
							"code": "function johnson({ $meta, $model, $collection }, map, impl) {\n\treturn (impl = map[$meta.$cl])\n\t\t? svendson($model, $collection, map, impl)\n\t\t: missing($meta.$cl);\n}\n"
						},
						{
							"line": 93,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "$model",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array|undefined}",
									"desc": "$collection",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object<string,Class<Proto>>}",
									"desc": "map",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Class<Proto>}",
									"desc": "impl",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Proto}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: Improved function naming TODO: Supobjs potential observers during this (newup) operation! ",
							"code": "function svendson($model, $collection, map, impl) {\n\treturn Object.assign(\n\t\t$collection ? new impl(...recall($collection, map)) : new impl(),\n\t\tjurgenson($model, map)\n\t);\n}\n"
						},
						{
							"line": 108,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "$model",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object<string,Class<Proto>>}",
									"desc": "map",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: Improved function naming ",
							"code": "function jurgenson($model, map) {\n\treturn Object.entries($model).reduce((obj, [key, val]) => {\n\t\treturn Object.assign(obj, {\n\t\t\t[key]: invoke(val, map)\n\t\t});\n\t}, {});\n}\n"
						},
						{
							"line": 121,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "classname",
									"text": ""
								},
								{
									"name": "@throws",
									"type": "{Error}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function missing(classname) {\n\tthrow new Error(`\"${classname}\" must map to a class constructor`);\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edb/src/devtools/ClassFormatter.js": {
			"title": "ClassFormatter",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { simple, dimmed, indent, double } from './styling';\n"
						},
						{
							"line": 1,
							"tags": [
								{
									"name": "@param",
									"type": "{Class<Proto>}",
									"desc": "Model",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "[config]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export function head(Model, config) {\n\treturn ['div', simple, `class ${Model.name}`];\n}\n"
						},
						{
							"line": 9,
							"tags": [
								{
									"name": "@param",
									"type": "{Class<Proto>}",
									"desc": "Model",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export function body(Model) {\n\tconst objectpipe = Symbol.for('@dataplastique/objectpipe');\n\treturn ['div', simple, ...resolveAll(Model[objectpipe]())];\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 18,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "model",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function resolveAll(model) {\n\treturn Object.entries(model).map(resolveOne);\n}\n"
						},
						{
							"line": 25,
							"tags": [
								{
									"name": "@param",
									"type": "{Array<string,*>}",
									"desc": "entry",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function resolveOne([key, value]) {\n\treturn [\n\t\t'div',\n\t\tdouble,\n\t\t['span', simple, `${key}: `],\n\t\t['span', simple, format(value)]\n\t];\n}\n"
						},
						{
							"line": 37,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "value",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function format(value) {\n\tif (typeof value === 'function') {\n\t\tif (native(value) || value.isModelConstructor) {\n\t\t\treturn value.name;\n\t\t} else {\n\t\t\treturn '? function';\n\t\t}\n\t} else {\n\t\treturn String(value);\n\t}\n}\n"
						},
						{
							"line": 52,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "value",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: More goes here! ",
							"code": "function native(value) {\n\tswitch (value) {\n\t\tcase String:\n\t\tcase Number:\n\t\tcase Boolean:\n\t\tcase Object:\n\t\tcase Array:\n\t\tcase Function:\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edb/src/devtools/Formatter.js": {
			"title": "Formatter",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import Model from '../Model';\nimport * as ClassFormatter from './ClassFormatter';\nimport * as InstanceFormatter from './InstanceFormatter';\n"
						},
						{
							"line": 3,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "object",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "[config]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object|null}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Render the header. ",
							"code": "export function header(object, config) {\n\treturn config && config.dataplastique\n\t\t? InstanceFormatter.head(object, config.key)\n\t\t: definez(object)\n\t\t\t? ClassFormatter.head(object)\n\t\t\t: extendz(object)\n\t\t\t\t? InstanceFormatter.head(object)\n\t\t\t\t: null;\n}\n"
						},
						{
							"line": 18,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "object",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Should display a tree-twisty to expand either type defs or instance props? ",
							"code": "export function hasBody(object) {\n\treturn definez(object) ? haspipe(object) : lengthy(object);\n}\n"
						},
						{
							"line": 26,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "object",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "[config]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object|null}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Render the body, either type definitions or instance props. ",
							"code": "export function body(object, config) {\n\treturn config && config.dataplastique\n\t\t? InstanceFormatter.body(object)\n\t\t: definez(object)\n\t\t\t? ClassFormatter.body(object)\n\t\t\t: extendz(object)\n\t\t\t\t? InstanceFormatter.body(object)\n\t\t\t\t: null;\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 41,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "const objpipe = Symbol.for('@dataplastique/objectpipe');\nconst arrpipe = Symbol.for('@dataplastique/arraypipe');\nconst isfuncz = o => typeof o === 'function';\nconst objectz = o => typeof o === 'object';\nconst extendz = o => objectz(o) && Model.is(o);\nconst definez = o => isfuncz(o) && o.isModelConstructor;\nconst haspipe = o => !!(o[objpipe]() || (o[arrpipe] && o[arrpipe]()));\nconst lengthy = o => !!(Object.keys(o).length || o.length);\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edb/src/devtools/InstanceFormatter.js": {
			"title": "InstanceFormatter",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { simple, dimmed, indent, double } from './styling';\n"
						},
						{
							"line": 1,
							"tags": [
								{
									"name": "@param",
									"type": "{Object|Array|Model}",
									"desc": "object",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string|number}",
									"desc": "key",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export function head(object, key) {\n\tconst name = getTitle(object, key);\n\tconst guid = object.$id ? ` (${object.$id})` : '';\n\treturn ['div', simple, ['span', simple, name], ['span', dimmed, guid]];\n}\n"
						},
						{
							"line": 11,
							"tags": [
								{
									"name": "@param",
									"type": "{Object|Array|Model}",
									"desc": "object",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export function body(object) {\n\treturn ['div', simple].concat(\n\t\tArray.isArray(object) ? arrayMembers(object) : instanceProps(object)\n\t);\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 21,
							"tags": [
								{
									"name": "@param",
									"type": "{string|number}",
									"desc": "key",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{*}",
									"desc": "value",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: Color coding goes here! ",
							"code": "function asattrib(key, value) {\n\treturn `${key}: ${value}`;\n}\n"
						},
						{
							"line": 30,
							"tags": [
								{
									"name": "@param",
									"type": "{Object|Array|Model}",
									"desc": "object",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string|number}",
									"desc": "key",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function getTitle(object, key) {\n\treturn key !== undefined\n\t\t? asattrib(key, getTitle(object))\n\t\t: getName(object, object.constructor);\n}\n"
						},
						{
							"line": 40,
							"tags": [
								{
									"name": "@param",
									"type": "{Object|Array|Model}",
									"desc": "object",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Class<Object|Array|Model>}",
									"desc": "constructor",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function getName(object, constructor) {\n\tswitch (constructor) {\n\t\tcase Object:\n\t\t\treturn Object.keys(object).length ? '{…}' : '{}';\n\t\tcase Array:\n\t\t\treturn object.length ? '[…]' : '[]';\n\t\tdefault:\n\t\t\treturn constructor.name;\n\t}\n}\n"
						},
						{
							"line": 55,
							"tags": [
								{
									"name": "@param",
									"type": "{Array}",
									"desc": "array",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Resolve array arrayMembers. ",
							"code": "function arrayMembers(array) {\n\treturn array.map((value, index) => {\n\t\treturn dennis(index, value);\n\t});\n}\n"
						},
						{
							"line": 65,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "object",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Resolve instance (own) properties. ",
							"code": "function instanceProps(object) {\n\treturn Object.entries(object).map(([key, value]) => {\n\t\treturn dennis(key, value);\n\t});\n}\n"
						},
						{
							"line": 75,
							"tags": [
								{
									"name": "@param",
									"type": "{string|number}",
									"desc": "key",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{*}",
									"desc": "value",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function dennis(key, value) {\n\tconst output = hans(key, value);\n\tconst simple = typeof output === 'string';\n\treturn ['div', simple ? double : indent, output];\n}\nfunction hans(key, value) {\n\tif (typeof value === 'object') {\n\t\treturn asobject(key, value);\n\t} else {\n\t\treturn asattrib(key, format(value));\n\t}\n}\n"
						},
						{
							"line": 92,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "value",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{*}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Format quotes on strings. ",
							"code": "function format(value) {\n\treturn typeof value === 'string' ? `\"${value}\"` : value;\n}\n"
						},
						{
							"line": 100,
							"tags": [
								{
									"name": "@param",
									"type": "{string|number}",
									"desc": "key",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object|Array}",
									"desc": "value",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function asobject(key, value) {\n\treturn [\n\t\t'object',\n\t\t{\n\t\t\tobject: value,\n\t\t\tconfig: {\n\t\t\t\tdataplastique: true,\n\t\t\t\tkey: key\n\t\t\t}\n\t\t}\n\t];\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edb/src/devtools/index.js": {
			"title": "index",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import * as Formatter from './Formatter';\n"
						},
						{
							"line": 1,
							"tags": [
								{
									"name": "@param",
									"type": "{Window|GlobalContext}",
									"desc": "[context]",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Install custom console debug formatters. ",
							"code": "export default function(context = window) {\n\tformatters(context).push(Formatter);\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 9,
							"tags": [
								{
									"name": "@param",
									"type": "{Window|GlobalContext}",
									"desc": "context",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<Object>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Formatters live inside a bizarre array that doesn't exist. ",
							"code": "function formatters(context) {\n\treturn context.devtoolsFormatters || (context.devtoolsFormatters = []);\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edb/src/devtools/styling.js": {
			"title": "styling",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "export const simple = {};\nexport const dimmed = { style: 'opacity: 0.5' };\nexport const indent = { style: 'margin-left: 14px' };\nexport const double = { style: 'margin-left: 28px' };\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edb/src/index.js": {
			"title": "index",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import installdevtools from './devtools/';\nimport { observe } from './proxy/ProxyFactory';\nimport { Environment } from '@dataplastique/util';\nexport { plugin } from './Plugin';\nexport { default as Tree } from './Tree';\nexport { default as Model } from './Model';\nexport { default as Plugin } from './Plugin';\nexport { default as Collection } from './Collection';\nif (Environment.browser) {\n\tinstalldevtools();\n}\n"
						},
						{
							"line": 11,
							"tags": [
								{
									"name": "@param",
									"type": "{Observer}",
									"desc": "obs",
									"text": "- TODO: Define `Observer` interface somewhere"
								}
							],
							"tabs": "",
							"desc": "TODO: How to expose this? ",
							"code": "export function addGlobalObserver(obs) {\n\tobserve(true, obs);\n}\n"
						},
						{
							"line": 18,
							"tags": [
								{
									"name": "@param",
									"type": "{Observer}",
									"desc": "obs",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: How to expose this? ",
							"code": "export function removeGlobalObserver(obs) {\n\tobserve(false, obs);\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edb/src/output/Output.js": {
			"title": "Output",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { getscope } from './scopes';\nimport { Environment } from '@dataplastique/util';\n"
						},
						{
							"line": 2,
							"tags": [
								{
									"name": "@filedesc",
									"type": "",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Carefully manage all input and output. ",
							"code": ""
						},
						{
							"line": 6,
							"tags": [
								{
									"name": "@type",
									"type": "{Symbol}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Key for public scope (the default scope). ",
							"code": "const pubkey = Symbol('Output');\n"
						},
						{
							"line": 11,
							"tags": [
								{
									"name": "@param",
									"type": "{Model}",
									"desc": "model",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string|Symbol}",
									"desc": "[key]",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export function output(model, key = pubkey) {\n\tconst C = timestamp(model.constructor);\n\tconst [outscope, handlers] = getscope(key);\n\toutscope.set(C, model);\n\tif (handlers.has(C)) {\n\t\thandlers.get(C).forEach(handler => {\n\t\t\thandler.oninput(model);\n\t\t});\n\t}\n}\n"
						},
						{
							"line": 25,
							"tags": [
								{
									"name": "@param",
									"type": "{Model}",
									"desc": "model",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string|Symbol}",
									"desc": "[key]",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: This methods needs some work. TODO: Make revoke work with function callbacks. ",
							"code": "export function revoke(model, key = pubkey) {\n\tconst C = model.constructor;\n\tconst [outscope, handlers] = getscope(key);\n\tif (outscope.get(C) === model) {\n\t\toutscope.delete(C);\n\t\tif (handlers.has(C)) {\n\t\t\thandlers\n\t\t\t\t.get(C)\n\t\t\t\t.filter(handler => !!handler.onrevoke)\n\t\t\t\t.forEach(handler => handler.onrevoke(C));\n\t\t}\n\t}\n}\n"
						},
						{
							"line": 44,
							"tags": [
								{
									"name": "@param",
									"type": "{Constructor}",
									"desc": "C",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{InputHandler}",
									"desc": "handler",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string|Symbol}",
									"desc": "[key]",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export function connect(C, handler, key = pubkey) {\n\tconst [outscope, handlers] = getscope(key);\n\tif (!handlers.has(C, handler)) {\n\t\thandlers.add(C, handler);\n\t\tif (outscope.has(C)) {\n\t\t\thandler.oninput(outscope.get(C));\n\t\t}\n\t}\n}\n"
						},
						{
							"line": 58,
							"tags": [
								{
									"name": "@param",
									"type": "{Constructor}",
									"desc": "C",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{InputHandler}",
									"desc": "handler",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string|Symbol}",
									"desc": "[key]",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export function disconnect(C, handler, key = pubkey) {\n\tconst [outscope, handlers] = getscope(key);\n\thandlers.del(C, handler);\n}\n"
						},
						{
							"line": 67,
							"tags": [
								{
									"name": "@param",
									"type": "{Constructor}",
									"desc": "C",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string|Symbol}",
									"desc": "[key]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Model|null}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get latest output. Note that the offical API is `MyClass.output()`! ",
							"code": "export function get(C, key = pubkey) {\n\tconst [outscope] = getscope(key);\n\treturn outscope.get(C) || null;\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 78,
							"tags": [
								{
									"name": "@param",
									"type": "{Class<Model>}",
									"desc": "C",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Class<Model>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Workaraoundy setup for finding the latest output (elsewhere in the project). We would like to track the output-chronology via some List or something, but how would this structure be accessed and analyzed (elsewhere in the project)? TODO: https://nodejs.org/api/perf_hooks.html#perf_hooks_performance_timing_api ",
							"code": "function timestamp(C) {\n\tconst now = Environment.isBrowser ? performance.now() : Date.now();\n\tC[Symbol.for('dataplastique:timestamp')] = now;\n\treturn C;\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edb/src/output/scopes.js": {
			"title": "scopes",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { IMapping } from '@dataplastique/util';\n"
						},
						{
							"line": 1,
							"tags": [
								{
									"name": "@type",
									"type": "{Map<string|Symbol,Scope>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Mapping all scopes by key. TODO: Unref scope with no output or handlers. ",
							"code": "const scopes = new Map();\n"
						},
						{
							"line": 7,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Symbol}",
									"desc": "key",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<Map|Mapping>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get scope by key. If not found, a new scope will be created. ",
							"code": "export function getscope(key) {\n\tconst scope = scopes.get(key) || scopes.set(key, new Scope()).get(key);\n\treturn [scope.outscope, scope.handlers];\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 16,
							"tags": [],
							"tabs": "\t",
							"desc": "",
							"code": "class Scope {\n"
						},
						{
							"line": 18,
							"tags": [
								{
									"name": "@type",
									"type": "{Map}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Tracking output in this scope. ",
							"code": "\toutscope = new Map();\n"
						},
						{
							"line": 23,
							"tags": [
								{
									"name": "@type",
									"type": "{IMapping<Constructor,ISet<Function|InputHandler>>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Tracking (set of) input handlers in this scope. ",
							"code": "\thandlers = new IMapping();\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edb/src/proxy/ProxyFactory.js": {
			"title": "ProxyFactory",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import * as Access from './access/Access';\nimport * as Target from './target/Target';\nimport * as Plugins from './plugins/Plugins';\nimport ModelHandler from './handlers/ModelHandler';\nimport CollectionHandler from './handlers/CollectionHandler';\nimport Observers from './handlers/observers/Observers';\nimport ProxyHandler from './ProxyHandler';\nimport { badConstructor } from './access/Access';\n"
						},
						{
							"line": 8,
							"tags": [
								{
									"name": "@filedesc",
									"type": "",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Proxies and traps. Note that the `target` object referenced in the files beyond this point is the proxied object and not the returned Proxy instance that the user will generally think of as the Model. TODO: Read http://stackoverflow.com/questions/35093382/javascript-trap-in-operator-in-proxy ",
							"code": ""
						},
						{
							"line": 15,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": "- Model, Collection or Plugin"
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "object",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array}",
									"desc": "[array]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Proto|Proxy}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: clash-detect plugin prefixes in constructor argument TODO: Also confirm `addObserver` and `removeObserver` ",
							"code": "export function approximate(target, object, array) {\n\treturn Array.isArray(target) || Access.confirm(object)\n\t\t? target.$observable\n\t\t\t? proxify(...arguments)\n\t\t\t: natural(...arguments)\n\t\t: Access.badConstructor(target, object);\n}\n"
						},
						{
							"line": 30,
							"tags": [
								{
									"name": "@param",
									"type": "{Class<Proto>|Proto}",
									"desc": "ModelC",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "prefix",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Constructor}",
									"desc": "PluginC",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{boolean}",
									"desc": "[override]",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Register plugin to prefix. ",
							"code": "export function registerPlugin(ModelC, prefix, PluginC, override) {\n\tPlugins.register(...arguments);\n}\n"
						},
						{
							"line": 40,
							"tags": [
								{
									"name": "@param",
									"type": "{boolean}",
									"desc": "on",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{IObserver}",
									"desc": "obs",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Add some kind of global observer. ",
							"code": "export function observe(on, obs) {\n\ton ? Observers.addGlobal(obs) : Observers.removeGlobal(obs);\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 49,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "object",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array}",
									"desc": "[array]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Proxy}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function proxify(target, object, array) {\n\tconst proxy = new Proxy(target, ProxyHandler);\n\tcommon(target, object, array, proxy);\n\tproxy.onconstruct();\n\treturn proxy;\n}\n"
						},
						{
							"line": 61,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "object",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array}",
									"desc": "[array]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Proto}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function natural(target, object, array) {\n\tcommon(target, object, array);\n\ttarget.onconstruct();\n\treturn target;\n}\n"
						},
						{
							"line": 72,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "object",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array}",
									"desc": "array",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Proxy}",
									"desc": "[proxy]",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function common(target, object, array, proxy = null) {\n\tTarget.init(target, proxy);\n\tModelHandler.init(target, object);\n\tCollectionHandler.init(target, array);\n\tPlugins.init(target);\n\tTarget.done(target);\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edb/src/proxy/ProxyHandler.js": {
			"title": "ProxyHandler",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import * as Target from './target/Target';\nimport * as Access from './access/Access';\nimport * as Plugins from './plugins/Plugins';\nimport ModelHandler from './handlers/ModelHandler';\nimport CollectionHandler from './handlers/CollectionHandler';\nimport Observers from './handlers/observers/Observers';\nimport { isFunction, isSymbol } from '@dataplastique/util';\n"
						},
						{
							"line": 7,
							"tags": [],
							"tabs": "\t",
							"desc": "First level proxy traps. Validate and analyze getter and setter operations, then forward reponsibility to either {ModelHandler} or {CollectionHandler} unless the property is reserved for use in any of the registered {Plugins}. ",
							"code": "export default class ProxyHandler {\n"
						},
						{
							"line": 13,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{*}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Getter trap. ",
							"code": "\tstatic get(target, name) {\n\t\tconst desc = getaccessor(target, name);\n\t\treturn desc\n\t\t\t? getter(target, desc, name)\n\t\t\t: isFunction(target[name])\n\t\t\t\t? target[name]\n\t\t\t\t: CollectionHandler.match(target, name)\n\t\t\t\t\t? CollectionHandler.get(target, name)\n\t\t\t\t\t: ModelHandler.get(target, name);\n\t}\n"
						},
						{
							"line": 29,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{*}",
									"desc": "value",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{object}",
									"desc": "[desc]",
									"text": "- (used internally)"
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": "Return success"
								}
							],
							"tabs": "\t",
							"desc": "Setter trap. ",
							"code": "\tstatic set(target, name, value) {\n\t\tconst desc = getaccessor(target, name);\n\t\treturn desc\n\t\t\t? setter(target, desc, name, value)\n\t\t\t: CollectionHandler.match(target, name)\n\t\t\t\t? CollectionHandler.set(target, name, value)\n\t\t\t\t: illegal(target, name, target[name])\n\t\t\t\t\t? badset(target, name, true)\n\t\t\t\t\t: ModelHandler.set(target, name, value);\n\t}\n"
						},
						{
							"line": 47,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<string>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Trap for ownKeys must implement for Chrome to respect property enumerability setting. https://bugs.chromium.org/p/v8/issues/detail?id=1543#c153 ",
							"code": "\tstatic ownKeys(target) {\n\t\tconst keys = ModelHandler.keys(target);\n\t\treturn Reflect.ownKeys(target).concat(keys);\n\t}\n"
						},
						{
							"line": 58,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": "- Property descriptor"
								}
							],
							"tabs": "\t",
							"desc": "Make `Object.keys` work more or less like expected. TODO: Revise for redesigned Plugins infrastructure! TODO: Revise ad-hoc descriptor sometime later on! https://bugzilla.mozilla.org/show_bug.cgi?id=1110332 http://mdn.io/Proxy/handler/getOwnPropertyDescriptor ",
							"code": "\tstatic getOwnPropertyDescriptor(target, name) {\n\t\tconst desc = getdescriptor(target, name);\n\t\treturn Plugins.has(target, name)\n\t\t\t? desc\n\t\t\t: desc\n\t\t\t\t? desc\n\t\t\t\t: Access.isPublic(name)\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tvalue: ModelHandler.get(target, name),\n\t\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\t\tenumerable: true\n\t\t\t\t\t  }\n\t\t\t\t\t: null;\n\t}\n"
						},
						{
							"line": 82,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "desc",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Trap `definePropety`. ",
							"code": "\tstatic defineProperty(target, name, desc) {\n\t\tconst old = Target.get(target, name);\n\t\tconst val = desc.value;\n\t\treturn desc.get || desc.set\n\t\t\t? Access.badDefine(target, name)\n\t\t\t: old !== val\n\t\t\t\t? Target.isPreserved(target, name)\n\t\t\t\t\t? badset(target, name)\n\t\t\t\t\t: do {\n\t\t\t\t\t\t\tTarget.set(target, name, val, desc);\n\t\t\t\t\t\t\tObservers.$poke(target, name, val, old);\n\t\t\t\t\t\t\ttrue;\n\t\t\t\t\t  }\n\t\t\t\t: true;\n\t}\n"
						},
						{
							"line": 104,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": "Return success"
								}
							],
							"tabs": "",
							"desc": "Delete trap. TODO: Actually go ahead and remove the key value pair instead of just setting key to `undefined` \n(observers could still call `onpoke` undefined). ",
							"code": "\tstatic deleteProperty(target, name) {\n\t\treturn this.set(target, name, undefined);\n\t}\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 118,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string|Symbol}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object|undefined}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get descriptor on target (not scanning the prototype chain). ",
							"code": "function getdescriptor(target, name) {\n\treturn Reflect.getOwnPropertyDescriptor(target, name);\n}\n"
						},
						{
							"line": 127,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string|Symbol}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object|undefined}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get accessor for property (scanning the prototype chain). ",
							"code": "function getaccessor(target, name) {\n\tconst desc = getdescriptor(target, name);\n\treturn isSymbol(name)\n\t\t? undefined\n\t\t: desc && (desc.get || desc.set)\n\t\t\t? desc\n\t\t\t: (target = Object.getPrototypeOf(target))\n\t\t\t\t? getaccessor(target, name)\n\t\t\t\t: undefined;\n}\n"
						},
						{
							"line": 143,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{*}",
									"desc": "desc",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{boolean}",
									"desc": "safe",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{*}",
									"desc": "",
									"text": ""
								},
								{
									"name": "@throws",
									"type": "{Error}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Resolve getter. ",
							"code": "function getter(target, desc, name, safe) {\n\treturn desc.get\n\t\t? Plugins.has(target, name)\n\t\t\t? target[name]\n\t\t\t: do {\n\t\t\t\t\tconst pro = Target.getProxy(target);\n\t\t\t\t\tconst res = desc.get.call(pro);\n\t\t\t\t\tObservers.$peek(target, name);\n\t\t\t\t\tres;\n\t\t\t  }\n\t\t: safe\n\t\t\t? undefined\n\t\t\t: Access.badGetter(target, name);\n}\n"
						},
						{
							"line": 166,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{*}",
									"desc": "desc",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{*}",
									"desc": "value",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": "Survive the proxy trap"
								},
								{
									"name": "@throws",
									"type": "{Error}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Resolve setter. ",
							"code": "function setter(target, desc, name, value) {\n\treturn desc.set\n\t\t? do {\n\t\t\t\tconst oldval = getter(target, desc, name, true);\n\t\t\t\tdesc.set.call(Target.getProxy(target), value);\n\t\t\t\tObservers.$poke(target, name, value, oldval);\n\t\t\t\ttrue;\n\t\t  }\n\t\t: Access.badSetter(target, name);\n}\n"
						},
						{
							"line": 185,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{*}",
									"desc": "field",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "\n\n",
							"code": "function illegal(target, name, field) {\n\treturn (\n\t\tisFunction(field) ||\n\t\tTarget.isReadonly(target, name) ||\n\t\tAccess.isReserved(name)\n\t);\n}\n"
						},
						{
							"line": 199,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{boolean}",
									"desc": "[isplugin]",
									"text": ""
								},
								{
									"name": "@throws",
									"type": "{AccessError}",
									"desc": "",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": "false"
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function badset(target, name, isplugin = false) {\n\tconst plugin = isplugin ? Plugins.find(target.constructor, name) : null;\n\tAccess.badValue(target, name, plugin);\n\treturn false;\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edb/src/proxy/access/Access.js": {
			"title": "Access",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { AccessError, isString, isSymbol } from '@dataplastique/util';\n"
						},
						{
							"line": 1,
							"tags": [
								{
									"name": "@filedesc",
									"type": "",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Access management and exception factory. ",
							"code": ""
						},
						{
							"line": 5,
							"tags": [],
							"tabs": "",
							"desc": "Reserved field names. ",
							"code": "const [ADD, REMOVE, X1, X2] = [\n\t'addObserver',\n\t'removeObserver',\n\t'observe',\n\t'unobserve'\n];\n"
						},
						{
							"line": 14,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "object",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Confirm that object as constructor argument only contains public (non-special) property names. ",
							"code": "export function confirm(object) {\n\tif (object === null) {\n\t\tconsole.log('access confirm null');\n\t\treturn true;\n\t}\n\tconst keys = Object.keys(object);\n\treturn keys.every(ispublic) && !keys.some(reserved);\n}\n"
						},
						{
							"line": 28,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Name looks loke a public key? ",
							"code": "export function isPublic(name) {\n\treturn ispublic(name);\n}\n"
						},
						{
							"line": 36,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Name is reserved for internal use? ",
							"code": "export function isReserved(name) {\n\treturn reserved(name);\n}\n"
						},
						{
							"line": 44,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "object",
									"text": ""
								},
								{
									"name": "@throws",
									"type": "{AccessError}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Constructor object denied. TODO: report `getOwnPropertySymbols`. ",
							"code": "export function badConstructor(target, object) {\n\tconst props = Object.keys(object);\n\tbad(`Cannot create ${target.constructor.name}: ${problematic(props)}`);\n}\n"
						},
						{
							"line": 55,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto|string}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Class<Plugin>}",
									"desc": "[Plugin]",
									"text": ""
								},
								{
									"name": "@throws",
									"type": "{AccessError}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Value denied. ",
							"code": "export function badValue(target, name, Plugin = null) {\n\tbad(\n\t\t`Cannot assign to ${signature(target, name)}` +\n\t\t\t(Plugin ? `: Reserved for the ${Plugin.name}` : '')\n\t);\n}\n"
						},
						{
							"line": 68,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@throws",
									"type": "{AccessError}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Getter denied. ",
							"code": "export function badGetter(target, name) {\n\tbad(`Getting a property that only has a setter: ${signature(target, name)}`);\n}\n"
						},
						{
							"line": 77,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@throws",
									"type": "{AccessError}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Setter denied. ",
							"code": "export function badSetter(target, name) {\n\tbad(`Setting a property that only has a getter: ${signature(target, name)}`);\n}\n"
						},
						{
							"line": 86,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@throws",
									"type": "{AccessError}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "\n`definePropery` denied. ",
							"code": "export function badDefine(target, name) {\n\tbad(`Cannot redefine ${signature(target, name)}`);\n}\n"
						},
						{
							"line": 95,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "cname",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@throws",
									"type": "{AccessError}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: More elaborate error message. ",
							"code": "export function reportDestructedViolation(cname, name) {\n\tbad(`Attempt to access \"${name}\" on destructed ${cname}`);\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 105,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto|string}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string|Symbol}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Identified by class name and property name. ",
							"code": "function signature(target, name) {\n\treturn isSymbol(name)\n\t\t? '[symbol]'\n\t\t: `${isString(target) ? target : target.constructor.name}.${name}`;\n}\n"
						},
						{
							"line": 116,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "message",
									"text": ""
								},
								{
									"name": "@throws",
									"type": "{AccessError}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Throw that access error. ",
							"code": "function bad(message) {\n\tthrow new AccessError(message);\n}\n"
						},
						{
							"line": 124,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Not a strange name? ",
							"code": "function ispublic(name) {\n\treturn !special(name);\n}\n"
						},
						{
							"line": 132,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Private or privileged property name? ",
							"code": "function special(name) {\n\treturn typeof name !== 'string' || name[0] === '_' || name[0] === '$';\n}\n"
						},
						{
							"line": 140,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Is reserved name? ",
							"code": "function reserved(name) {\n\treturn name === ADD || name === REMOVE;\n}\n"
						},
						{
							"line": 148,
							"tags": [
								{
									"name": "@param",
									"type": "{Array<string>|string}",
									"desc": "input",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Compile error message for problematic names (in constructor scenario)? ",
							"code": "function problematic(input) {\n\tif (Array.isArray(input)) {\n\t\treturn input.filter(problematic).reduce((message, key) => {\n\t\t\treturn message + `  \"${key}\" is not allowed\\n`;\n\t\t}, '\\n');\n\t} else {\n\t\treturn special(input) || reserved(input);\n\t}\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edb/src/proxy/handlers/CollectionHandler.js": {
			"title": "CollectionHandler",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { Type } from '@dataplastique/util';\nimport { getProxy } from '../target/Target';\nimport Observers from './observers/Observers';\nimport getArrayPipe from './pipes/ArrayPipe';\nimport { ok } from './ModelHandler.js';\n"
						},
						{
							"line": 5,
							"tags": [
								{
									"name": "@type",
									"type": "{RegExp}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "String that would resolve to integer when used in square bracket notation. TODO: This regular expressions appears over-engineered: Something simpler. ",
							"code": "const INTEGER = /^-*(?:[1-9]\\d*|\\d)$/;\n\n"
						},
						{
							"line": 12,
							"tags": [],
							"tabs": "\t",
							"desc": "Proxytraps for collection aspects (array-like properties). ",
							"code": "export default class CollectionHandler {\n"
						},
						{
							"line": 16,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array}",
									"desc": "[array]",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "TODO: Investigate if `array` can be a number somehow? Need validate much? ",
							"code": "\tstatic init(target, array) {\n\t\tif (Array.isArray(target)) {\n\t\t\tgetProxy(target).push(...array);\n\t\t}\n\t}\n"
						},
						{
							"line": 26,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Attempting to set uniquely array-related properties on an actual array? ",
							"code": "\tstatic match(target, name) {\n\t\treturn (\n\t\t\tArray.isArray(target) &&\n\t\t\tnotsymbol(name) &&\n\t\t\t(name === 'length' || INTEGER.test(name))\n\t\t);\n\t}\n"
						},
						{
							"line": 39,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string\\number}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{*}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Just FYI: `match` was called before this wass called and therefore we already know that the property is either `length` or a numeric index. ",
							"code": "\t@ok\n\tstatic get(target, name) {\n\t\tObservers.$peek(target, name);\n\t\treturn target[name];\n\t}\n"
						},
						{
							"line": 51,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{*}",
									"desc": "value",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Just FYI: `match` was called before this gets called and therefore, we already know that the property is either `length` or an index. If the value is undefined, it usually implies that this index was deleted, so we will not attempt to pipe that into a model (seems that we really cannot distinguish `push(undefined)` from a delete?) ",
							"code": "\t@ok\n\tstatic set(target, name, value) {\n\t\tObservers.$splice(target);\n\t\tif (name === 'length') {\n\t\t\ttarget[name] = value;\n\t\t} else {\n\t\t\ttarget[name] = value !== undefined ? resolve(target, value) : value;\n\t\t}\n\t\treturn true;\n\t}\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 74,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Symbol}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Given key is not a symbol? ",
							"code": "function notsymbol(name) {\n\treturn !!name.charAt;\n}\n"
						},
						{
							"line": 82,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{*}",
									"desc": "value",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{*}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function resolve(target, value) {\n\tconst cons = target.constructor;\n\tconst pipe = getArrayPipe(cons);\n\treturn pipe ? pipe(value) : value;\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edb/src/proxy/handlers/ModelHandler.js": {
			"title": "ModelHandler",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { Type } from '@dataplastique/util';\nimport * as Access from '../access/Access';\nimport * as Target from '../target/Target';\nimport Observers from './observers/Observers';\nimport getObjectPipe from './pipes/ObjectPipe';\nconst [CONSTRUCTOR, CONSTRUCTED, ADD, REMOVE, DISPOSE, DISPOSED] = [\n\t'constructor',\n\t'constructed',\n\t'addObserver',\n\t'removeObserver',\n\t'dispose', \n\t'disposed' \n];\nconst CONFIRM_PROXY = '$CONFIRM_PROXY';\n"
						},
						{
							"line": 14,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "object",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "descriptor",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Decorator to throw an exception on attempt to access destructed target. TODO: This can become deprecated once we revoke the proxies for good. ",
							"code": "export function ok(object, name, descriptor) {\n\tconst base = descriptor.value;\n\tdescriptor.value = function(target, name) {\n\t\tif (name !== 'disposed' && Target.isDisposed(target)) {\n\t\t\tAccess.reportDestructedViolation(target.constructor.name, name);\n\t\t} else {\n\t\t\treturn base.apply(this, arguments);\n\t\t}\n\t};\n\treturn descriptor;\n}\n"
						},
						{
							"line": 33,
							"tags": [],
							"tabs": "\t",
							"desc": "Proxytraps for model aspects (object-like properties). ",
							"code": "export default class ModelHandler {\n"
						},
						{
							"line": 37,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "object",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Create target mapping. ",
							"code": "\tstatic init(target, object) {\n\t\tObject.entries(object).forEach(([key, value]) => {\n\t\t\tTarget.set(target, key, piped(target, key, value));\n\t\t});\n\t}\n"
						},
						{
							"line": 47,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{*}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Get property (or method). ",
							"code": "\t@ok\n\tstatic get(target, name) {\n\t\tconst value = special(target, name) || normal(target, name);\n\t\treturn value === undefined ? uniget(target, name) : value;\n\t}\n"
						},
						{
							"line": 58,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{*}",
									"desc": "value",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Set property. ",
							"code": "\t@ok\n\tstatic set(target, name, value) {\n\t\tif (!uniset(target, name, value)) {\n\t\t\tconst val = piped(target, name, value);\n\t\t\tconst old = Target.get(target, name);\n\t\t\tif (old !== val) {\n\t\t\t\tTarget.set(target, name, val);\n\t\t\t\tObservers.$poke(target, name, val, old);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n"
						},
						{
							"line": 77,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<string>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get non-special keys (only). ",
							"code": "\t@ok\n\tstatic keys(target) {\n\t\treturn Target.publickeys(target);\n\t}\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 88,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{*}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Step 0: Special methods and properties that require access to the \n`target` that is hidden behind the proxy event horizon. The `constructor` apparently needs a fix in V8 (at least). ",
							"code": "function special(target, name) {\n\tswitch (name) {\n\t\tcase ADD:\n\t\t\treturn observer => Observers.add(target, observer);\n\t\tcase REMOVE:\n\t\t\treturn observer => Observers.remove(target, observer);\n\t\tcase DISPOSE:\n\t\t\treturn () => Target.dispose(target);\n\t\tcase DISPOSED:\n\t\t\treturn Target.isDisposed(target);\n\t\tcase CONSTRUCTOR:\n\t\t\treturn target.constructor;\n\t\tcase CONSTRUCTED:\n\t\t\treturn Target.isConstructed(target);\n\t\tcase CONFIRM_PROXY:\n\t\t\treturn true;\n\t}\n}\n"
						},
						{
							"line": 115,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string|Symbol}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{*}",
									"desc": "value",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{truthy}",
									"desc": "",
									"text": "- `true` if the unversal setter handled it."
								}
							],
							"tabs": "",
							"desc": "Attempt to assign the property via \"universal setter\". ",
							"code": "function uniset(target, name, value) {\n\tif (target.uniset && uniok(target, name)) {\n\t\treturn universal(target, name, value);\n\t}\n}\n"
						},
						{
							"line": 127,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string|Symbol}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{truthy}",
									"desc": "",
									"text": "- `undefined` unless the unversal getter handled it."
								}
							],
							"tabs": "",
							"desc": "Attempt to retrieve the property via \"universal getter\". ",
							"code": "function uniget(target, name) {\n\tif (target.uniget && uniok(target, name)) {\n\t\treturn universal(target, name);\n\t}\n}\n"
						},
						{
							"line": 138,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string|Symbol}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "OK to evalute \"universal\" setter or getter? ",
							"code": "function uniok(target, name) {\n\treturn (\n\t\tnotsymbol(name) && Target.isConstructed(target) && !universal.suspended\n\t);\n}\n"
						},
						{
							"line": 149,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{*}",
									"desc": "[value]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{*}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "To save the callstack, suspend interception while calling \"universal\" getter or setter. ",
							"code": "function universal(target, name, value) {\n\tuniversal.suspended = true;\n\tconst proxy = Target.getProxy(target);\n\tconst getit = arguments.length === 2;\n\tconst returnval = getit ? proxy.uniget(name) : proxy.uniset(name, value);\n\tuniversal.suspended = false;\n\treturn returnval;\n}\n"
						},
						{
							"line": 165,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{*}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get normal property. ",
							"code": "function normal(target, name) {\n\tObservers.$peek(target, name);\n\treturn Target.get(target, name);\n}\n"
						},
						{
							"line": 175,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "key",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{*}",
									"desc": "val",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{*}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function piped(target, key, val) {\n\tconst cons = target.constructor;\n\tconst pipe = getObjectPipe(cons);\n\treturn pipe ? pipeline(cons, pipe, key, val) : val;\n}\n"
						},
						{
							"line": 186,
							"tags": [
								{
									"name": "@param",
									"type": "{Constructor}",
									"desc": "cons",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "pipe",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "key",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{*}",
									"desc": "val",
									"text": ""
								},
								{
									"name": "@throws",
									"type": "{TypeError}",
									"desc": "",
									"text": ""
								},
								{
									"name": "@throws",
									"type": "{Error}",
									"desc": "",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{*}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Potentially \"upgrade\" the value to an advanced type. If type definitions have been declared, this will also validate the correct type of the value. ",
							"code": "function pipeline(cons, pipe, key, val) {\n\treturn pipe.hasOwnProperty(key) \n\t\t? pipe[key](val)\n\t\t: Access.badValue(cons.name, key);\n}\n"
						},
						{
							"line": 202,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Symbol}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Just while Type.isSymbol is not exactly the fastest implementation. ",
							"code": "function notsymbol(name) {\n\treturn !!name.charAt;\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edb/src/proxy/handlers/observers/IObserver.js": {
			"title": "IObserver",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "\t",
							"desc": "Interface Observer. ",
							"code": "export default class IObserver {\n"
						},
						{
							"line": 4,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "model",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Ary}",
									"desc": "newval",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{*}",
									"desc": "oldval",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Model property changed. ",
							"code": "\tonpoke(model, name, newval, oldval) {}\n"
						},
						{
							"line": 12,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "model",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Model property inspected. ",
							"code": "\tonpeek(model, name) {}\n"
						},
						{
							"line": 18,
							"tags": [
								{
									"name": "@param",
									"type": "{Collection}",
									"desc": "collection",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<Any>}",
									"desc": "added",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<Any>}",
									"desc": "removed",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<Any>}",
									"desc": "moved",
									"text": "TODO: This was deprecated, right?"
								}
							],
							"tabs": "",
							"desc": "Work in progress. ",
							"code": "\tonsplice(collection, added, removed, moved) {}\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edb/src/proxy/handlers/observers/Observers.js": {
			"title": "Observers",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { Tick, Type } from '@dataplastique/util';\nimport { UnsupportedError } from '@dataplastique/util';\nimport { isConstructed, getProxy } from '../../target/Target';\n"
						},
						{
							"line": 3,
							"tags": [
								{
									"name": "@type",
									"type": "{Map<Set<IObserver>>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Mapping target to observers. ",
							"code": "const locals = new WeakMap();\n"
						},
						{
							"line": 8,
							"tags": [
								{
									"name": "@type",
									"type": "{Set<IObserver>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Listing observers for *all* targets. These are not so easily garbage collected, so please don't linger here. ",
							"code": "const globals = new Set();\n"
						},
						{
							"line": 14,
							"tags": [
								{
									"name": "@type",
									"type": "{Map<Model,Set<string>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Models inspected in current execution stack. ",
							"code": "const peeks = new Map();\n"
						},
						{
							"line": 19,
							"tags": [
								{
									"name": "@type",
									"type": "{Map<Model,Map<string,Array>>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Models changed in current execution stack. ",
							"code": "const pokes = new Map();\n"
						},
						{
							"line": 24,
							"tags": [
								{
									"name": "@type",
									"type": "{Map<Collection,Array>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Collections mutated in current execution stack: The indexed value is an array of pre-update collection members, a snapshot from before the change. ",
							"code": "const mutes = new Map();\n"
						},
						{
							"line": 30,
							"tags": [
								{
									"name": "@type",
									"type": "{Map<Proto,Set<IObserver>>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: Implement this cache for resolving observers ",
							"code": "const cache = new Map();\n"
						},
						{
							"line": 35,
							"tags": [],
							"tabs": "",
							"desc": "While false, suspend observer notification while inspecting properties (internal use). ",
							"code": "let peeking = true;\n"
						},
						{
							"line": 40,
							"tags": [],
							"tabs": "\t",
							"desc": "Observers management studio. ",
							"code": "export default class Observers {\n"
						},
						{
							"line": 44,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{IObserver}",
									"desc": "[observer]",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Add observer for target. ",
							"code": "\tstatic add(target, observer = target) {\n\t\tlet set = locals.get(target);\n\t\tif (observable(target)) {\n\t\t\tif (!set) {\n\t\t\t\tlocals.set(target, (set = new Set()));\n\t\t\t}\n\t\t\tset.add(observer);\n\t\t} else {\n\t\t\tobservererror(target);\n\t\t}\n\t}\n"
						},
						{
							"line": 60,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{IObserver}",
									"desc": "[observer]",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Remove observer for target. ",
							"code": "\tstatic remove(target, observer = target) {\n\t\tlet set = locals.get(target);\n\t\tif (observable(target)) {\n\t\t\tif (set) {\n\t\t\t\tset.delete(observer);\n\t\t\t\tif (!set.size) {\n\t\t\t\t\tlocals.delete(target);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tobservererror(target);\n\t\t}\n\t}\n"
						},
						{
							"line": 78,
							"tags": [
								{
									"name": "@param",
									"type": "{IObserver}",
									"desc": "observer",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Add observer for all targets. ",
							"code": "\tstatic addGlobal(observer) {\n\t\tglobals.add(observer);\n\t}\n"
						},
						{
							"line": 85,
							"tags": [
								{
									"name": "@param",
									"type": "{IObserver}",
									"desc": "observer",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Remove observer for all targets. ",
							"code": "\tstatic removeGlobal(observer) {\n\t\tglobals.delete(observer);\n\t}\n"
						},
						{
							"line": 92,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Model property inspected. TODO: For globals, confirm that the property (descriptor) is writable. ",
							"code": "\tstatic $peek(target, name) {\n\t\tif (observable(target) && peeking) {\n\t\t\tif (globals.size) {\n\t\t\t\tsuspendpeeking(() => {\n\t\t\t\t\tglobals.forEach(observer => {\n\t\t\t\t\t\tif (observer.onpeek) {\n\t\t\t\t\t\t\tobserver.onpeek(getProxy(target), name);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (locals.has(target) && ispublic(name)) {\n\t\t\t\tlet names = peeks.get(target);\n\t\t\t\tif (!names) {\n\t\t\t\t\tpeeks.set(target, (names = new Set()));\n\t\t\t\t}\n\t\t\t\tnames.add(name);\n\t\t\t\tdebug('$peek', target);\n\t\t\t\tschedule();\n\t\t\t}\n\t\t}\n\t}\n"
						},
						{
							"line": 120,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{*}",
									"desc": "newval",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{*}",
									"desc": "oldval",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "TODO: Local observers should NOT be notified about \"private\" changes (unless they have been proxied by a \"public\" getter) Model property changed. ",
							"code": "\tstatic $poke(target, name, newval, oldval) {\n\t\tif (observable(target)) {\n\t\t\tif (globals.size || locals.has(target)) {\n\t\t\t\tlet props = pokes.get(target);\n\t\t\t\tif (props) {\n\t\t\t\t\tif (props.has(name)) {\n\t\t\t\t\t\tprops.get(name)[0] = newval;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprops.set(name, [newval, oldval]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tprops = new Map();\n\t\t\t\t\tprops.set(name, [newval, oldval]);\n\t\t\t\t\tpokes.set(target, props);\n\t\t\t\t}\n\t\t\t\tdebug('$poke', target, name);\n\t\t\t\tschedule();\n\t\t\t}\n\t\t}\n\t}\n"
						},
						{
							"line": 149,
							"tags": [
								{
									"name": "@param",
									"type": "{Collection}",
									"desc": "target",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Collection members changed somehow. This gets called *before* the update operation(s) happens: We'll snapshot the old collection and compare it to the new so that we can figure out what was changed. ",
							"code": "\tstatic $splice(target) {\n\t\tif (observable(target) && (globals.size || locals.has(target))) {\n\t\t\tif (!mutes.has(target)) {\n\t\t\t\tmutes.set(target, Array.from(target));\n\t\t\t\tdebug('$splice', target);\n\t\t\t\tschedule();\n\t\t\t}\n\t\t}\n\t}\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 166,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Target should trigger peeks and pokes? ",
							"code": "function observable(target) {\n\treturn isConstructed(target) && target.$observable;\n}\n"
						},
						{
							"line": 174,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "action",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Do enable this once in a while for a quick sanity check. Does it look like we need to setup some transient cache? ",
							"code": "function debug(action, target, name) {\n\tif (false) {\n\t\tconsole.log(action, target.constructor.name, name || '');\n\t}\n}\n"
						},
						{
							"line": 186,
							"tags": [],
							"tabs": "",
							"desc": "Schedule updates async via `requestAnimationFrame` \n(in the browser) or via `setTimeout` (in the Node). ",
							"code": "function schedule() {\n\tconst id = schedule.id;\n\tTick.cancelSchedule(isNaN(id) ? -1 : id);\n\tschedule.id = Tick.schedule(onschedule);\n}\n"
						},
						{
							"line": 195,
							"tags": [],
							"tabs": "",
							"desc": "Run scheduled updates, updating observers. ",
							"code": "function onschedule() {\n\tsnapshot(peeks).forEach(gopeek);\n\tsnapshot(pokes).forEach(gopoke);\n\tsnapshot(mutes).forEach(gomute);\n}\n"
						},
						{
							"line": 203,
							"tags": [
								{
									"name": "@param",
									"type": "{Map}",
									"desc": "map",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<Model,String|Map<string,*>>|Array<*>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Transfer map contents to an array so that the map can be cleared before we trigger any side effects that might repopulate the map. ",
							"code": "function snapshot(map) {\n\tconst array = [];\n\tmap.forEach((...mapping) => array.push(mapping));\n\tmap.clear();\n\treturn array;\n}\n"
						},
						{
							"line": 215,
							"tags": [
								{
									"name": "@param",
									"type": "{Array<Model|Set>}",
									"desc": "update",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Update observers for properties inspected. ",
							"code": "function gopeek([props, target]) {\n\tconst proxy = getProxy(target);\n\tconst observers = locals.get(target);\n\tif (observers) {\n\t\tsuspendpeeking(() => {\n\t\t\tobservers.forEach(observer => {\n\t\t\t\tif (observer.onpeek) {\n\t\t\t\t\tprops.forEach(name => {\n\t\t\t\t\t\tobserver.onpeek(proxy, name);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n}\n"
						},
						{
							"line": 234,
							"tags": [
								{
									"name": "@param",
									"type": "{Array<Model|Map<string,Array>>}",
									"desc": "update",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Update observers for properties changed. ",
							"code": "function gopoke([props, target]) {\n\tconst proxy = getProxy(target);\n\tconst poke = (observer, isglobal) => {\n\t\tif (observer.onpoke) {\n\t\t\tprops.forEach((values, name) => {\n\t\t\t\tif (isglobal || ispublic(name)) {\n\t\t\t\t\tobserver.onpoke(proxy, name, values[0], values[1]);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n\tglobals.forEach(observer => poke(observer, true));\n\tif (locals.has(target)) {\n\t\tlocals.get(target).forEach(observer => poke(observer));\n\t}\n}\n"
						},
						{
							"line": 254,
							"tags": [
								{
									"name": "@param",
									"type": "{Array<Array<Any>,Collection<Any>>}",
									"desc": "update",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Update observers for collection mutations. ",
							"code": "function gomute([source, target]) {\n\tconst proxy = getProxy(target);\n\tconst added = target.filter(any => !source.includes(any));\n\tconst removed = source.filter(any => !target.includes(any));\n\tallobservers(target).forEach(observer => {\n\t\tif (observer.onsplice) {\n\t\t\tobserver.onsplice(proxy, added, removed);\n\t\t}\n\t});\n}\n"
						},
						{
							"line": 268,
							"tags": [
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "action",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Suspend peek notifications for the duration of given action. Note that the business logic here is unfortunate: To save the call stack, we must disable notifications while we notify the observers. This means that we have a blind spot for properties that can be inspected in stealth mode. This will most likely be the observer inspecting it's own properties, so perhaps OK. ",
							"code": "function suspendpeeking(action) {\n\tpeeking = false;\n\taction();\n\tpeeking = true;\n}\n"
						},
						{
							"line": 281,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Set<IObserver>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get local and global observers for target, avoiding potential duplicates. TODO: Something must optimize, perhaps setup a short-lived cache thingy? ",
							"code": "function allobservers(target) {\n\tconst loc = locals.get(target) || new Set();\n\tconst set = new Set([...globals, ...loc]);\n\treturn set;\n}\n"
						},
						{
							"line": 292,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Only trigger \"public\" observers on \"public\" properties. TODO: Figure this out with getter that proxies private. TODO: If possible, move this function into {Access} ",
							"code": "function ispublic(name) {\n\treturn notsymbol(name) && name[0] !== '_' && name[0] !== '$';\n}\n"
						},
						{
							"line": 302,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Symbol}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Don't trigger observers on Symbol access. ",
							"code": "function notsymbol(name) {\n\treturn !!name.charAt;\n}\n"
						},
						{
							"line": 310,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@throws",
									"type": "{Error}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Can't observe that. ",
							"code": "function observererror(target) {\n\tconst classname = target.constructor.name;\n\tthrow new UnsupportedError(\n\t\t`The ${classname} is unfortunately not observable.`\n\t);\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edb/src/proxy/handlers/pipes/ArrayPipe.js": {
			"title": "ArrayPipe",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import getvalidator from './Validators';\nimport getconverter from './Converters';\nimport { isClass, isFunction, typeOf } from '@dataplastique/util';\n"
						},
						{
							"line": 3,
							"tags": [
								{
									"name": "@type",
									"type": "{Map<constructor,function>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Mapping Collection constructors to ArrayPipes. ",
							"code": "const pipes = new Map();\n"
						},
						{
							"line": 8,
							"tags": [
								{
									"name": "@param",
									"type": "{Class<Collection>}",
									"desc": "cons",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Function}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get pipe for constructor. This \"pipe\" is a function that can be used validate and transform elements added to the {Collection}. TODO: required TODO: enumerable TODO: configurable TODO: default ",
							"code": "export default function getArrayPipe(cons) {\n\treturn pipes.has(cons)\n\t\t? pipes.get(cons)\n\t\t: do {\n\t\t\t\tconst name = Symbol.for('@dataplastique/arraypipe');\n\t\t\t\tconst type = cons[name]();\n\t\t\t\tconst pipe = createpipe(cons, type);\n\t\t\t\tpipes.set(cons, pipe);\n\t\t\t\tpipe;\n\t\t  };\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 30,
							"tags": [
								{
									"name": "@type",
									"type": "{Set<Constructor>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Primitive and strangely exotic types. ",
							"code": "const primitives = new Set([String, Number, Boolean, Symbol]);\n"
						},
						{
							"line": 35,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "input",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{*}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "This pipe simply outputs the input untransformed. ",
							"code": "const identitypipe = input => input;\n"
						},
						{
							"line": 41,
							"tags": [
								{
									"name": "@param",
									"type": "{Collection}",
									"desc": "col",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Constructor|Function|null}",
									"desc": "pipe",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Function}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Create new pipe. ",
							"code": "function createpipe(col, pipe) {\n\tif (pipe) {\n\t\treturn primitives.has(pipe)\n\t\t\t? identitypipe\n\t\t\t: isClass(pipe)\n\t\t\t\t? constructorpipe(col, pipe)\n\t\t\t\t: isFunction(pipe)\n\t\t\t\t\t? functionpipe(col, pipe)\n\t\t\t\t\t: typeerror();\n\t} else {\n\t\treturn pipe === null ? identitypipe : typeerror();\n\t}\n}\n"
						},
						{
							"line": 60,
							"tags": [
								{
									"name": "@param",
									"type": "{Collection}",
									"desc": "col",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{constructor}",
									"desc": "pipe",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Function}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "The pipe is a model constructor. ",
							"code": "function constructorpipe(col, pipe) {\n\tconst validator = getvalidator(pipe);\n\tconst converter = getconverter(pipe);\n\treturn input => {\n\t\treturn validator(input) ? converter(input) : fail(col, pipe, input);\n\t};\n}\n"
						},
						{
							"line": 73,
							"tags": [
								{
									"name": "@param",
									"type": "{Collection}",
									"desc": "col",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "pipe",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Function}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "The pipe is a function that evaluates the input and returns a constructor. ",
							"code": "function functionpipe(col, pipe) {\n\treturn input => {\n\t\tconst constructor = pipe(input);\n\t\treturn constructor.isModelConstructor\n\t\t\t? getconverter(constructor)(input)\n\t\t\t: typeerror(`Expected constructor, got ${typeOf(constructor)}`);\n\t};\n}\n"
						},
						{
							"line": 87,
							"tags": [
								{
									"name": "@param",
									"type": "{Collection}",
									"desc": "col",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Constructor}",
									"desc": "pipe",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "input",
									"text": ""
								},
								{
									"name": "@throws",
									"type": "{TypeError}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function fail(col, pipe, input) {\n\tconst [name, type] = [col.name || 'Anonymous', typeOf(input)];\n\ttypeerror(`Bad input for ${name}: Expected ${pipe.name}, got ${type}.`);\n}\n"
						},
						{
							"line": 97,
							"tags": [
								{
									"name": "@param",
									"type": "{Collection}",
									"desc": "col",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{*}",
									"desc": "badpipe",
									"text": ""
								},
								{
									"name": "@throws",
									"type": "{TypeError}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function failreturntype(col, badpipe) {\n\tconst wanted = 'constructor|function|null';\n\tconst [name, type] = [col.name || 'Anonymous', typeOf(badpipe)];\n\ttypeerror(`${name}.collection() returned ${type}, expected ${wanted}`);\n}\n"
						},
						{
							"line": 107,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "message",
									"text": ""
								},
								{
									"name": "@throws",
									"type": "{TypeError}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Throw that TypeError. ",
							"code": "function typeerror(message) {\n\tthrow new TypeError(message);\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edb/src/proxy/handlers/pipes/Converters.js": {
			"title": "Converters",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { Type, IMap, ISet } from '@dataplastique/util';\n"
						},
						{
							"line": 1,
							"tags": [
								{
									"name": "@type",
									"type": "{IMap<Constructor|ISet,Function>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Default converters. Simple values will be passed through unconverted. TODO: Untangle Object and Array! TODO: Special converter for Date ",
							"code": "let converters = (id => {\n\treturn new IMap([\n\t\t[String, id],\n\t\t[Number, id],\n\t\t[Boolean, id],\n\t\t[Function, id],\n\t\t[Object, id],\n\t\t[Array, id],\n\t\t[Symbol, id]\n\t]);\n})(input => input);\n"
						},
						{
							"line": 18,
							"tags": [
								{
									"name": "@param",
									"type": "{Constructor}",
									"desc": "cons",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Function}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get converter for constructor. Returns a function that can upgrade plain objects and arrays to super advanced Models and Collections. ",
							"code": "export default function getconverter(cons) {\n\treturn converters.has(cons) ? converters.get(cons) : newconverter(cons);\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 27,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "const simplearray = x => Array.isArray(x) && x.constructor === Array;\nconst simplething = x => typeof x === 'object' && x.constructor === Object;\n"
						},
						{
							"line": 30,
							"tags": [
								{
									"name": "@param",
									"type": "{Constructor|ISet<Constructor>}",
									"desc": "cons",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Function}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function newconverter(cons) {\n\tconst converter = ISet.isSet(cons)\n\t\t? multiconverter(cons)\n\t\t: basicconverter(cons);\n\tconverters = converters.set(cons, converter);\n\treturn converter;\n}\n"
						},
						{
							"line": 41,
							"tags": [
								{
									"name": "@param",
									"type": "{ISet}",
									"desc": "set",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Function}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO Something fancy. ",
							"code": "function multiconverter(set) {\n\treturn input => {\n\t\tconsole.log('TODO: multiconverter');\n\t\treturn input;\n\t};\n}\n"
						},
						{
							"line": 52,
							"tags": [
								{
									"name": "@param",
									"type": "{Class<Proto>}",
									"desc": "cons",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Function}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: Handle null and undefined?????????????????????????????????????????????? Build function to transform input of complex type. ",
							"code": "function basicconverter(cons) {\n\treturn input => {\n\t\tif (input === null) {\n\t\t\tconsole.log('TODO: converter null');\n\t\t\treturn input;\n\t\t}\n\t\treturn input instanceof cons\n\t\t\t? input\n\t\t\t: cons.isCollectionConstructor\n\t\t\t\t? simplearray(input)\n\t\t\t\t\t? new cons(...input)\n\t\t\t\t\t: typeerror()\n\t\t\t\t: new cons(input);\n\t};\n}\n"
						},
						{
							"line": 73,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "message",
									"text": ""
								},
								{
									"name": "@throws",
									"type": "{TypeError}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Throw that TypeError. ",
							"code": "function typeerror(message = 'TODO') {\n\tthrow new TypeError(message);\n}\n"
						}
					]
				},
				{
					"title": "TODO ",
					"tabs": "",
					"sections": [
						{
							"line": 82,
							"tags": [
								{
									"name": "@param",
									"type": "{Object|Array}",
									"desc": "input",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object|Array}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Users will input their models to our models and despair when we change them, so we'll clone their input into fresh objects before we continue. TODO: Instantiated models should survice this operation (somehow). TODO: Something that won't explode on recursion (without `try catch`). ",
							"code": "function untangle(input) {\n\treturn JSON.parse(JSON.stringify(input));\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edb/src/proxy/handlers/pipes/ObjectPipe.js": {
			"title": "ObjectPipe",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import getvalidator from './Validators';\nimport getconverter from './Converters';\nimport { typeOf } from '@dataplastique/util';\nimport { IMap, ISet, ISeq, immutable, isImmutable } from '@dataplastique/util';\n"
						},
						{
							"line": 4,
							"tags": [
								{
									"name": "@type",
									"type": "{Map<Class<Proto>,Object>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Mapping Model constructor to pipe. ",
							"code": "const pipes = new Map();\n"
						},
						{
							"line": 9,
							"tags": [
								{
									"name": "@param",
									"type": "{Class<Proto>}",
									"desc": "Proto",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get pipe for constructor. This \"pipe\" is an object with methods to validate and potentially transform properties assigned to the Model (or Collection). TODO: required TODO: enumerable TODO: configurable TODO: default ",
							"code": "export default function getObjectPipe(Proto) {\n\treturn pipes.has(Proto)\n\t\t? pipes.get(Proto)\n\t\t: do {\n\t\t\t\tconst pipe = resolve(Proto);\n\t\t\t\tpipes.set(Proto, pipe);\n\t\t\t\tpipe;\n\t\t  };\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 28,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "const isnull = val => val === null;\nconst isimap = val => IMap.isMap(val);\nconst islist = val => Array.isArray(val);\nconst isobjt = val => typeof val === 'object';\nconst toiset = seq => seq.toSet();\nconst toimap = seq => seq.toMap();\n"
						},
						{
							"line": 35,
							"tags": [
								{
									"name": "@type",
									"type": "{Map<Class<Proto>,IMap|null>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Mapping Model constructor to IMap derived from `static model()` ",
							"code": "const imaps = new Map();\n"
						},
						{
							"line": 40,
							"tags": [
								{
									"name": "@type",
									"type": "{IMap}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "An empty IMap. There's nothing to it. ",
							"code": "const blank = new IMap();\n"
						},
						{
							"line": 45,
							"tags": [
								{
									"name": "@param",
									"type": "{Class<Proto>}",
									"desc": "Proto",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{IMap|null}",
									"desc": "[map]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object|null}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function resolve(Proto, map = ancestors(Proto).reduce(mapping)) {\n\treturn isnull(map)\n\t\t? map\n\t\t: isimap(map)\n\t\t\t? buildpipe(Proto, map)\n\t\t\t: failpipe(Proto, map);\n}\n"
						},
						{
							"line": 57,
							"tags": [
								{
									"name": "@param",
									"type": "{Class<Proto>}",
									"desc": "Proto",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<Class<Proto>>}",
									"desc": "[list]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<Class<Proto>>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "List class hierarchy starting from the top (Proto itself). ",
							"code": "function ancestors(Proto, list = [Proto]) {\n\treturn (Proto = Object.getPrototypeOf(Proto)).isProtoConstructor\n\t\t? ancestors(Proto, list.concat(Proto))\n\t\t: list.reverse();\n}\n"
						},
						{
							"line": 68,
							"tags": [
								{
									"name": "@param",
									"type": "{IMap|null}",
									"desc": "oldmap",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Class<Proto>}",
									"desc": "Proto",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{IMap|null}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function mapping(oldmap, Proto) {\n\treturn imaps.has(Proto)\n\t\t? imaps.get(Proto)\n\t\t: do {\n\t\t\t\tconst symbol = Symbol.for('@dataplastique/objectpipe');\n\t\t\t\tconst object = Proto[symbol](oldmap || blank);\n\t\t\t\tconst newmap = deepfreeze(object, oldmap || blank);\n\t\t\t\timaps.set(Proto, newmap);\n\t\t\t\tnewmap;\n\t\t  };\n}\n"
						},
						{
							"line": 84,
							"tags": [
								{
									"name": "@param",
									"type": "{IMap|Object|null}",
									"desc": "newmap",
									"text": "- Usually this is just a plain JS Object"
								},
								{
									"name": "@param",
									"type": "{IMap}",
									"desc": "oldmap",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{IMap|null}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Making map values immutable all the way down so subclas cannot accidentally change the parent interface. Object pipes are crated lazily, so this would not become apparent until the parent class was first instantiated (if ever). ",
							"code": "function deepfreeze(newmap, oldmap) {\n\treturn isnull(newmap)\n\t\t? newmap\n\t\t: isimap(newmap)\n\t\t\t? newmap.map(frozen)\n\t\t\t: isobjt(newmap)\n\t\t\t\t? oldmap.merge(newmap).map(frozen)\n\t\t\t\t: newmap;\n}\n"
						},
						{
							"line": 101,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "js",
									"text": "- String, Number, Boolean but also Objects and Arrays."
								},
								{
									"name": "@returns",
									"type": "{*}",
									"desc": "",
									"text": "- Returns an immutable structure"
								}
							],
							"tabs": "",
							"desc": "Recursively transform objects and arrays to immutable Maps and Sets. ",
							"code": "function frozen(js) {\n\treturn !isobjt(js) || isnull(js) || isImmutable(js)\n\t\t? js\n\t\t: islist(js)\n\t\t\t? toiset(ISeq(js).map(frozen))\n\t\t\t: toimap(ISeq(js).map(frozen));\n}\n"
						},
						{
							"line": 113,
							"tags": [
								{
									"name": "@param",
									"type": "{Class<Proto>}",
									"desc": "Proto",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{IMap}",
									"desc": "map",
									"text": "- The result of calling `static model()`."
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Creates an object, the \"pipe\", with methods to match every entry in the map. ",
							"code": "function buildpipe(Proto, map) {\n\treturn map.reduce((pipe, value, key) => {\n\t\tReflect.set(pipe, key, input => {\n\t\t\treturn getvalidator(value)(input)\n\t\t\t\t? getconverter(value)(input)\n\t\t\t\t: throwinvalid(Proto, key, input, value);\n\t\t});\n\t\treturn pipe;\n\t}, {});\n}\n"
						}
					]
				},
				{
					"title": "Failures ",
					"tabs": "",
					"sections": [
						{
							"line": 130,
							"tags": [
								{
									"name": "@param",
									"type": "{Constructor}",
									"desc": "Proto",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{*}",
									"desc": "pipe",
									"text": ""
								},
								{
									"name": "@throws",
									"type": "{TypeError}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "The `static model` method returned something bad. TODO: Method name 'model()' has been hardcoded! ",
							"code": "function failpipe(Proto, pipe) {\n\tthrow new TypeError(\n\t\t`${Proto.name}.model() returned ${typeOf(pipe)}, expected IMap|Object|null`\n\t);\n}\n"
						},
						{
							"line": 142,
							"tags": [
								{
									"name": "@param",
									"type": "{Class<Proto>}",
									"desc": "Proto",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "key",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{*}",
									"desc": "input",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Constructor|ISet<Constructor>}",
									"desc": "cons",
									"text": "(String, Number, Person etc)"
								},
								{
									"name": "@throws",
									"type": "{TypeError}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Throw that type error. ",
							"code": "function throwinvalid(Proto, key, input, cons) {\n\tconst name = c => c.name;\n\tconst list = c => [...c.map(name)].join('|');\n\tconst want = ISet.isSet(cons) ? list(cons) : name(cons);\n\tconst fail = failedtype(input);\n\tconst clas = name(Proto);\n\tthrow new TypeError(\n\t\t`Bad assignment to ${clas}.${key}: Expected ${want}, got ${fail}.`\n\t);\n}\n"
						},
						{
							"line": 160,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "input",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Attempt to qualify the exact type of input that failed validation. ",
							"code": "function failedtype(input) {\n\tlet type = typeOf(input);\n\tswitch (type) {\n\t\tcase 'object':\n\t\tcase 'array':\n\t\t\tlet cons = input.constructor;\n\t\t\tif (cons !== Object && cons !== Array) {\n\t\t\t\ttype = cons.name;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\treturn type;\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edb/src/proxy/handlers/pipes/Validators.js": {
			"title": "Validators",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { IMap, ISet } from '@dataplastique/util';\nimport { isArray, isFunction, isDate, isSymbol } from '@dataplastique/util';\nimport { isString, isNumber, isBoolean, isObject } from '@dataplastique/util';\n"
						},
						{
							"line": 3,
							"tags": [
								{
									"name": "@type",
									"type": "{IMap<Constructor|ISet,Function>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Default validators. TODO: Perhaps parity https://reactjs.org/docs/typechecking-with-proptypes.html ",
							"code": "let validators = new IMap([\n\t[String, isString],\n\t[Number, isNumber],\n\t[Boolean, isBoolean],\n\t[Object, isObject],\n\t[Array, isArray],\n\t[Function, isFunction],\n\t[Date, isDate],\n\t[Symbol, isSymbol]\n]);\n"
						},
						{
							"line": 18,
							"tags": [
								{
									"name": "@param",
									"type": "{Constructor|ISet<Constructor>}",
									"desc": "cons",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Function}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get validator for constructor. Returns function to confirm input data via \n`instanceOf` test (unless the input is primitive, in which case see above). ",
							"code": "export default function getvalidator(cons) {\n\treturn validators.has(cons) ? validators.get(cons) : newvalidator(cons);\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 27,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "const simplearray = x => Array.isArray(x) && x.constructor === Array;\nconst simplething = x => typeof x === 'object' && x.constructor === Object;\n"
						},
						{
							"line": 30,
							"tags": [
								{
									"name": "@param",
									"type": "{Constructor|ISet<Constructor>}",
									"desc": "cons",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Function}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Build function to validate input of complex type. ",
							"code": "function newvalidator(cons) {\n\tconst validator = ISet.isSet(cons)\n\t\t? multivalidator(cons)\n\t\t: basicvalidator(cons);\n\tvalidators = validators.set(cons, validator);\n\treturn validator;\n}\n"
						},
						{
							"line": 42,
							"tags": [
								{
									"name": "@param",
									"type": "{ISet<Constructor>}",
									"desc": "set",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Function}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "\n\n",
							"code": "function multivalidator(set) {\n\tconst validators = set.map(getvalidator);\n\treturn input => validators.some(isvalid => isvalid(input));\n}\n"
						},
						{
							"line": 51,
							"tags": [
								{
									"name": "@param",
									"type": "{Class<Proto>}",
									"desc": "cons",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Function}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function basicvalidator(cons) {\n\treturn input => {\n\t\tif (input === null) {\n\t\t\tconsole.log('TODO: validator null');\n\t\t\treturn true;\n\t\t}\n\t\treturn cons.isCollectionConstructor\n\t\t\t? cons.is(input) || simplearray(input)\n\t\t\t: cons.isModelConstructor\n\t\t\t\t? cons.is(input) || simplething(input)\n\t\t\t\t: true;\n\t};\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edb/src/proxy/plugins/Plugins.js": {
			"title": "Plugins",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { typeOf } from '@dataplastique/util';\nimport { Class } from '@dataplastique/util';\nimport { getPlugins, getProxy } from '../target/Target';\n"
						},
						{
							"line": 3,
							"tags": [
								{
									"name": "@filedesc",
									"type": "",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Plugins management studio. ",
							"code": ""
						},
						{
							"line": 7,
							"tags": [
								{
									"name": "@param",
									"type": "{Class<Proto>|Proto}",
									"desc": "what",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Class<Plugin>}",
									"desc": "PluginC",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{boolean}",
									"desc": "[override]",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Assign plugin to property name. TODO: Support register to instance! ",
							"code": "export function register(what, name, PluginC, override) {\n\tif (true) {\n\t\tregisterToClass(...arguments);\n\t} else {\n\t\tregisterToInstance(...arguments);\n\t}\n}\n"
						},
						{
							"line": 22,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Initialize plugins for instance. ",
							"code": "export function init(target) {\n\tinitPlugins(target, target.constructor);\n}\n"
						},
						{
							"line": 29,
							"tags": [
								{
									"name": "@param",
									"type": "{Class<Proto>}",
									"desc": "ProtoC",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Class<Plugin>|null}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Lookup plugin assigned to property name, if indeed it is. ",
							"code": "export function find(ProtoC, name) {\n\treturn lookupPlugin(ProtoC, name);\n}\n"
						},
						{
							"line": 38,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Target class has plugin assigned to property name? ",
							"code": "export function has(target, name) {\n\treturn !!lookupPlugin(target.constructor, name);\n}\n"
						},
						{
							"line": 47,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Dispose target plugins. ",
							"code": "export function dispose(target) {\n\tconst map = getPlugins(target);\n\tif (map) {\n\t\tmap.forEach(plugin => {\n\t\t\tplugin.dispose();\n\t\t});\n\t}\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 60,
							"tags": [
								{
									"name": "@type",
									"type": "{Map<Class<Proto>,Map<string,Class<Plugin>>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Tracking names and plugins for various classes. TODO: Remove traces of old getter-and-setter logic. ",
							"code": "const registry = new Map();\n"
						},
						{
							"line": 66,
							"tags": [
								{
									"name": "@param",
									"type": "{Class<Proto>}",
									"desc": "ProtoC",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Class<Plugin>}",
									"desc": "PluginC",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{boolean}",
									"desc": "[override]",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Assign plugin to class. ",
							"code": "function registerToClass(ProtoC, name, PluginC, override) {\n\tconst Plugin = lookupPlugin(ProtoC, name);\n\tconst map = registry;\n\tif (Plugin && !override) {\n\t\toverrideError(Plugin, name);\n\t} else {\n\t\tif (!map.has(ProtoC)) {\n\t\t\tmap.set(ProtoC, new Map());\n\t\t}\n\t\tmap.get(ProtoC).set(name, PluginC);\n\t\tdefineSetter(ProtoC, name, PluginC);\n\t}\n}\n"
						},
						{
							"line": 86,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "proto",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Class<Plugin>}",
									"desc": "PluginC",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{boolean}",
									"desc": "[override]",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: Assign plugin to instance. ",
							"code": "function registerToInstance(proto, name, PluginC, override) {\n\tconsole.error('TODO');\n}\n"
						},
						{
							"line": 96,
							"tags": [
								{
									"name": "@param",
									"type": "{Class<Proto>}",
									"desc": "ProtoC",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Class<Plugin>}",
									"desc": "PluginC",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Define the getter so that it instantiates the plugin on initial access. ",
							"code": "function defineSetter(ProtoC, name, PluginC) {\n\tReflect.defineProperty(ProtoC.prototype, name, {\n\t\tconfigurable: true,\n\t\tenumarable: false,\n\t\tget() {\n\t\t\tconst target = getProxy(this) || this;\n\t\t\tconst plugin = new PluginC({ host: target });\n\t\t\tgetPlugins(this).set(name, plugin);\n\t\t\tReflect.defineProperty(this, name, {\n\t\t\t\tconfigurable: false,\n\t\t\t\tenumarable: false,\n\t\t\t\twritable: false,\n\t\t\t\tvalue: plugin\n\t\t\t});\n\t\t\treturn plugin;\n\t\t}\n\t});\n}\n"
						},
						{
							"line": 120,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Class<Proto>}",
									"desc": "ProtoC",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Lookup plugins assigned to class, recursively crawling up the class hierarchy. If plugins are not lazy, new them up. ",
							"code": "function initPlugins(target, ProtoC) {\n\tconst plugins = registry.get(ProtoC);\n\tif (plugins) {\n\t\tplugins.forEach((PluginC, name) => {\n\t\t\tif (!PluginC.lazy()) {\n\t\t\t\ttarget[name].$touched = true; \n\t\t\t}\n\t\t});\n\t}\n\tif ((ProtoC = Object.getPrototypeOf(ProtoC))) {\n\t\tinitPlugins(target, ProtoC);\n\t}\n}\n"
						},
						{
							"line": 139,
							"tags": [
								{
									"name": "@param",
									"type": "{Class<Proto>}",
									"desc": "ProtoC",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Class<Plugin>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Lookup Plugin assigned to name for given class (or ancestor). TODO: Now called on every accessor (via ProxyHandler), so cache this! ",
							"code": "function lookupPlugin(ProtoC, name) {\n\tconst plugins = registry.get(ProtoC);\n\treturn plugins && plugins.has(name)\n\t\t? plugins.get(name)\n\t\t: (ProtoC = Object.getPrototypeOf(ProtoC)).isProtoConstructor\n\t\t\t? lookupPlugin(ProtoC, name)\n\t\t\t: null;\n}\n"
						},
						{
							"line": 154,
							"tags": [
								{
									"name": "@param",
									"type": "{Class<Plugin>}",
									"desc": "Plugin",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@throws",
									"type": "{Error}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function overrideError(Plugin, name) {\n\tthrow new Error(`The ${Plugin.name} is assigned to \"${name}\"`);\n}\n"
						},
						{
							"line": 162,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "thing",
									"text": ""
								},
								{
									"name": "@throws",
									"type": "{TypeError}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function typeError(thing) {\n\tthrow new TypeError(`Expected Plugin, got ${typeOf(thing)}`);\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edb/src/proxy/target/Target.js": {
			"title": "Target",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { Key } from '@dataplastique/util';\nimport { isPublic } from '../access/Access';\n"
						},
						{
							"line": 2,
							"tags": [
								{
									"name": "@filedesc",
									"type": "",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Manage {Proto} properties. ",
							"code": ""
						},
						{
							"line": 6,
							"tags": [],
							"tabs": "",
							"desc": "Artifacts shared by all {Proto} instances. ",
							"code": "const [plugins, constructed, disposed] = [\n\tSymbol('plugins'),\n\tSymbol('constructed'),\n\tSymbol('disposed')\n];\n"
						},
						{
							"line": 14,
							"tags": [],
							"tabs": "",
							"desc": "Special artifacts for proxied {Proto} instances. ",
							"code": "const [proxy, normal, special, readonly, locked] = [\n\tSymbol('proxy'),\n\tSymbol('normal'),\n\tSymbol('special'),\n\tSymbol('readonly'),\n\tSymbol('locked')\n];\n"
						},
						{
							"line": 24,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Proxy}",
									"desc": "[theproxy]",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Setup artifacts. ",
							"code": "export function init(target, theproxy) {\n\ttarget[constructed] = false;\n\ttarget[disposed] = false;\n\tif ((target[proxy] = theproxy)) {\n\t\ttarget[normal] = new Map();\n\t\ttarget[special] = new Map();\n\t\ttarget[readonly] = new Set();\n\t\ttarget[locked] = new Set();\n\t}\n\t$id(target);\n}\n"
						},
						{
							"line": 40,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "target",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Mark the target with a special property upon construction completed. This will make sure that observers are not triggered during newup. ",
							"code": "export function done(target) {\n\ttarget[constructed] = true;\n}\n"
						},
						{
							"line": 48,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{*}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get property. ",
							"code": "export function get(target, name) {\n\tif (target[proxy]) {\n\t\treturn getmap(target, name).get(name);\n\t} else {\n\t\treturn target[name];\n\t}\n}\n"
						},
						{
							"line": 61,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{*}",
									"desc": "value",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "[desc]",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Set property. ",
							"code": "export function set(target, name, value, desc) {\n\tif (target[proxy]) {\n\t\tgetmap(target, name).set(name, value);\n\t\tmaybepreserve(target, name, desc);\n\t} else {\n\t\ttarget[name] = value; \n\t}\n}\n"
						},
						{
							"line": 76,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Is property readonly or nonconfigurable? ",
							"code": "export function isPreserved(target, name) {\n\treturn target[locked].has(name) || target[readonly].has(name);\n}\n"
						},
						{
							"line": 85,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Is property readonly? ",
							"code": "export function isReadonly(target, name) {\n\treturn target[readonly].has(name);\n}\n"
						},
						{
							"line": 94,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Target is done parsing constructor arguments? ",
							"code": "export function isConstructed(target) {\n\treturn target[constructed];\n}\n"
						},
						{
							"line": 102,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Proxy}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get target proxy. ",
							"code": "export function getProxy(target) {\n\treturn target[proxy]; \n}\n"
						},
						{
							"line": 110,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Map<string,Plugin|Function>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get instantiated plugins for target. ",
							"code": "export function getPlugins(target) {\n\treturn target[plugins] || (target[plugins] = new Map());\n}\n"
						},
						{
							"line": 118,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Target has been disposed? ",
							"code": "export function isDisposed(target) {\n\treturn target[disposed];\n}\n"
						},
						{
							"line": 126,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<string>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get non-special keys (only). ",
							"code": "export function publickeys(target) {\n\treturn [...target[normal].keys()];\n}\n"
						},
						{
							"line": 134,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "target",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Recursively dispose the target. TODO: Revoke the proxies here! ",
							"code": "export function dispose(target) {\n\ttarget[disposed] = true;\n\t(target[proxy] || target).ondestruct();\n\tif (target[plugins]) {\n\t\ttarget[plugins].forEach(dispose);\n\t}\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 147,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{boolean}",
									"desc": "proxied",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Compute and assign the unique `$id`. ",
							"code": "function $id(target) {\n\tconst id = Key.generate(classname(target));\n\tif (target[proxy]) {\n\t\ttarget[special].set('$id', id);\n\t\ttarget[readonly].add('$id');\n\t\ttarget[locked].add('$id');\n\t} else {\n\t\tReflect.defineProperty(target, '$id', {\n\t\t\tconfigurable: false,\n\t\t\tenumerable: false,\n\t\t\twritable: false,\n\t\t\tvalue: id\n\t\t});\n\t}\n}\n"
						},
						{
							"line": 167,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "[desc]",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Make readonly or nonconfigurable or both. ",
							"code": "function maybepreserve(target, name, desc) {\n\tif (uppercase(name)) {\n\t\ttarget[locked].add(name);\n\t\ttarget[readonly].add(name);\n\t} else if (desc) {\n\t\tif (!desc.configurable) {\n\t\t\ttarget[locked].add(name);\n\t\t}\n\t\tif (!desc.writable) {\n\t\t\ttarget[readonly].add(name);\n\t\t}\n\t}\n}\n"
						},
						{
							"line": 186,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Map}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get map for normal or special properties (public or private). ",
							"code": "function getmap(target, name) {\n\treturn isPublic(name) ? target[normal] : target[special];\n}\n"
						},
						{
							"line": 195,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Property name matches a readonly value because UPPERCASE convention? ",
							"code": "function uppercase(name) {\n\treturn notsymbol(name) && /^[A-Z0-9_\\$]+$/.test(name);\n}\n"
						},
						{
							"line": 203,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Symbol}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Not a symbol? ",
							"code": "function notsymbol(name) {\n\treturn !!name.charAt;\n}\n"
						},
						{
							"line": 211,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Elegantly normalize some classname$$1 that was sanitized by Rollup :/ TODO: Perhaps let `displayName` take precedence in case of mangling? ",
							"code": "function classname(target) {\n\treturn target.constructor.name.replace(/(\\$+)\\d+$/, '');\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edbml-cli/src/Parser.js": {
			"title": "Parser",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import prettier from 'prettier';\nimport parse5 from 'parse5';\n"
						},
						{
							"line": 2,
							"tags": [
								{
									"name": "@see",
									"type": "https://www.w3.org/TR/html5/syntax.html#syntax-tag-omission",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "TODO: Translate selected self closing tags to start plus end tags. ",
							"code": "export default class Parser {\n"
						},
						{
							"line": 7,
							"tags": [],
							"tabs": "\t",
							"desc": "Configure SAXParser. ",
							"code": "\tconstructor() {\n\t\tconst append = html => (this._markup += html);\n\t\tthis._parser\n\t\t\t.on('startTag', (...args) => append(starttag(this, ...args)))\n\t\t\t.on('endTag', tag => append(`</${tag}>`))\n\t\t\t.on('text', text => append(text));\n\t}\n"
						},
						{
							"line": 17,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "line",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{number}",
									"desc": "index",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\tparse(line, index) {\n\t\tthis._source += line;\n\t\tfor (let c of line) {\n\t\t\tthis._parser.write(c);\n\t\t}\n\t\treturn this._markup;\n\t}\n"
						},
						{
							"line": 29,
							"tags": [
								{
									"name": "@param",
									"type": "{boolean}",
									"desc": "ishtml",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{number}",
									"desc": "index",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\treset(ishtml, index) {\n\t\tthis._lastjs = ishtml ? this._lastjs : index;\n\t\tthis._markup = '';\n\t}\n"
						},
						{
							"line": 37,
							"tags": [
								{
									"name": "@returns",
									"type": "{number}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\tincrement() {\n\t\treturn this._counts++;\n\t}\n"
						},
						{
							"line": 43,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "code",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\tinject(code) {\n\t\tconst map = this._inject;\n\t\tconst now = this._lastjs;\n\t\tif (!map.has(now)) {\n\t\t\tmap.set(now, []);\n\t\t}\n\t\tmap.get(now).push(code);\n\t}\n"
						},
						{
							"line": 54,
							"tags": [
								{
									"name": "@param",
									"type": "{number}",
									"desc": "start",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{number}",
									"desc": "stop",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\textract(start, stop) {\n\t\treturn this._source.substring(start, stop);\n\t}\n"
						},
						{
							"line": 62,
							"tags": [
								{
									"name": "@returns",
									"type": "{Map<number,Array<string>>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\tinjections() {\n\t\treturn this._inject;\n\t}\n"
						}
					]
				},
				{
					"title": "Private ",
					"tabs": "\t",
					"sections": [
						{
							"line": 69,
							"tags": [
								{
									"name": "@type",
									"type": "{parse5.SAXParser}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\t_parser = new parse5.SAXParser({\n\t\tlocationInfo: true\n\t});\n"
						},
						{
							"line": 75,
							"tags": [
								{
									"name": "@type",
									"type": "{Map<number,Array<string>>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\t_inject = new Map();\n"
						},
						{
							"line": 79,
							"tags": [
								{
									"name": "@type",
									"type": "{Array<string>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\t_source = '';\n"
						},
						{
							"line": 83,
							"tags": [
								{
									"name": "@type",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\t_markup = '';\n"
						},
						{
							"line": 87,
							"tags": [
								{
									"name": "@type",
									"type": "{number}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\t_lastjs = 0;\n"
						},
						{
							"line": 91,
							"tags": [
								{
									"name": "@type",
									"type": "{number}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "\t_counts = 0;\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 97,
							"tags": [
								{
									"name": "@type",
									"type": "{RegExp}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Match attribute name that can be declared as JS property using dot notation. ",
							"code": "const SAFEATT = /^[^\\d][a-zA-Z0-9_\\$]*$/;\n"
						},
						{
							"line": 102,
							"tags": [
								{
									"name": "@type",
									"type": "{RegExp}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Matches the ${value} between the curly braces. ",
							"code": "const XPVALUE = /\\$\\{(.*)\\}/;\n"
						},
						{
							"line": 107,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "const prefix = name => name.split(':')[0];\n"
						},
						{
							"line": 112,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "const localname = name => name.split(':')[1];\n"
						},
						{
							"line": 117,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "const reserved = name => /^(on:|do:elm|do:gui)/.test(name);\n"
						},
						{
							"line": 122,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "value",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "const decode = value => value.match(XPVALUE)[1];\n"
						},
						{
							"line": 127,
							"tags": [
								{
									"name": "@param",
									"type": "{Parser}",
									"desc": "parser",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "tag",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<Object>}",
									"desc": "atts",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{boolean}",
									"desc": "closing",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "location",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function starttag(parser, tag, atts, closing, location) {\n\tatts = atts.map(att => exactcase(parser, att, location));\n\tatts = resolveall(parser, tag, atts).map(attributedone);\n\treturn `<${tag}${atts.join('')}${closing ? '/' : ''}>`;\n}\n"
						},
						{
							"line": 140,
							"tags": [
								{
									"name": "@see",
									"type": "https://github.com/inikulin/parse5/issues/116",
									"desc": "",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Parser}",
									"desc": "parser",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "att",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "location",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Restore attribute name to pascalCase and convert to kebab-case. The attributes appear to *not* be indexed for SVG elements (?). This conversion is not technically needed anymore, but still. ",
							"code": "function exactcase(parser, { name, value }, location) {\n\tconst loc = location.attrs[name];\n\tif (loc) {\n\t\tconst sub = parser.extract(loc.startOffset, loc.endOffset);\n\t\treturn { name: sub.substr(0, name.length), value };\n\t} else {\n\t\treturn { name, value };\n\t}\n}\n"
						},
						{
							"line": 159,
							"tags": [
								{
									"name": "@param",
									"type": "{Parser}",
									"desc": "parser",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "tag",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<Object>}",
									"desc": "before",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<Object>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function resolveall(parser, tag, before) {\n\treturn before.reduce((after, att) => {\n\t\tif (reserved(att.name)) {\n\t\t\tresolveone(parser, tag, after, att);\n\t\t} else {\n\t\t\tafter.push(att);\n\t\t}\n\t\treturn after;\n\t}, []);\n}\n"
						},
						{
							"line": 175,
							"tags": [
								{
									"name": "@param",
									"type": "{Parser}",
									"desc": "parser",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "tag",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<Object>}",
									"desc": "atts",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "att",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function resolveone(parser, tag, atts, { name, value }) {\n\tconst code = format(decode(value));\n\tconst type = localname(name);\n\tswitch (prefix(name)) {\n\t\tcase 'on':\n\t\t\tupdateatts(\n\t\t\t\tatts,\n\t\t\t\t'data-plastique-on',\n\t\t\t\t`${type}:${injectevent(parser, tag, code)}`\n\t\t\t);\n\t\t\tbreak;\n\t\tcase 'do':\n\t\t\tupdateatts(atts, `data-plastique-${type}`, inject(parser, code, type));\n\t\t\tbreak;\n\t}\n}\n"
						},
						{
							"line": 197,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "att",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "\n\nfunction resolveguid({ name, value }) { \n\tname = name === 'guid' ? 'data-plastique-id' : name; \n\treturn { name, value }; \n} ",
							"code": ""
						},
						{
							"line": 206,
							"tags": [
								{
									"name": "@param",
									"type": "{Array<Object>}",
									"desc": "atts",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "dataname",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "value",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function updateatts(atts, dataname, value) {\n\tlet old = att => att.name === dataname;\n\tlet att = atts.find(old);\n\tif (!att) {\n\t\tatts.push((att = { name: dataname, value: '' }));\n\t}\n\tatt.value += (att.value ? ';' : '') + value;\n}\n"
						},
						{
							"line": 219,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "att",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Finally string the attribute as HTML. ",
							"code": "function attributedone({ name, value }) {\n\treturn name.startsWith('@') ? proxyatt(name.slice(1)) : ` ${name}=\"${value}\"`;\n}\n"
						},
						{
							"line": 227,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "This attribute becomes a HTML attribute at runtime. ",
							"code": "function proxyatt(name) {\n\treturn SAFEATT.test(name)\n\t\t? ' ${out.' + name + '}'\n\t\t: \" ${out['\" + name + \"']}\";\n}\n"
						},
						{
							"line": 237,
							"tags": [
								{
									"name": "@param",
									"type": "{Parser}",
									"desc": "parser",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "tag",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "code",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function injectevent(parser, tag, code) {\n\tconst form = /textarea|input/.test(tag);\n\tconst args = form ? '(e, value, checked)' : 'e';\n\treturn inject(parser, code, args);\n}\n"
						},
						{
							"line": 248,
							"tags": [
								{
									"name": "@param",
									"type": "{Parser}",
									"desc": "parser",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "code",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "[args]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function inject(parser, code, args = '()') {\n\tconst next = parser.increment();\n\tconst call = `const df${next} = out.arrghs(${args} => ${code});\\n`;\n\tparser.inject(call);\n\treturn '${df' + next + '}';\n}\n"
						}
					]
				},
				{
					"title": "Code formatting ",
					"tabs": "",
					"sections": [
						{
							"line": 261,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "code",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "lead",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Run inline calback (string) through Prettier to determine if it should be wrapped in curly braces for a multiline arrow function. As a bonus, the parser will fail fast at this point if the code is not syntactically valid. TODO: Make such an exception triggers more useful console debugging info. ",
							"code": "function format(code, lead = '') {\n\tcode = pretty(code);\n\tif (code.includes('\\n')) {\n\t\treturn indent(pretty('{' + code + '}'), lead);\n\t} else {\n\t\treturn code.replace(/;$/, '');\n\t}\n}\n"
						},
						{
							"line": 278,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "code",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function pretty(code) {\n\treturn prettier\n\t\t.format(code, {\n\t\t\tuseTabs: true,\n\t\t\tsingleQuote: true,\n\t\t\tprintWidth: 1000\n\t\t})\n\t\t.trim();\n}\n"
						},
						{
							"line": 291,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "code",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "lead",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function indent(code, lead) {\n\treturn code\n\t\t.split('\\n')\n\t\t.map((l, i) => (i ? lead + l : l))\n\t\t.join('\\n');\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edbml-cli/src/index.js": {
			"title": "index",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import step1 from './step1';\nimport step2 from './step2';\nimport step3 from './step3';\nimport step4 from './step4';\nimport callsite from 'callsite';\nimport path from 'path';\nimport glob from 'glob';\nimport fs from 'fs';\n"
						},
						{
							"line": 8,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Array<string>}",
									"desc": "targets",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "[options]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<string>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export function compile(targets, options = {}) {\n\tconst base = getsource(callsite());\n\tconst list = gettargets(targets, base);\n\tconst code = transform(list, options);\n\treturn [...code].map(entry => write(...entry));\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 19,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "const stats = target => fs.lstatSync(target);\nconst exists = target => fs.existsSync(target);\nconst isfolder = target => exists(target) && stats(target).isDirectory();\nconst isfile = target => exists(target) && stats(target).isFile();\nconst isglob = target => !isfolder(target) && !isfile(target);\nconst getfiles = folder => glob.sync(path.normalize(folder + '/**/*.edbml'));\n"
						},
						{
							"line": 26,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Array<string>}",
									"desc": "targets",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "base",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<string>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Resolve to list of files (not folders). TODO: Support glob *.edbml (files not folders), perhaps ONLY support globs? ",
							"code": "function gettargets(targets, base) {\n\ttargets = makearray(targets);\n\tconst folders = targets.filter(isfolder);\n\tconst files = targets.filter(isfile);\n\tconst globs = targets.filter(isglob);\n\tglobs.forEach(pattern => files.push(...getfiles(glob.sync(pattern))));\n\tfolders.forEach(folder => files.push(...getfiles(folder)));\n\treturn makeabsolute([...new Set(files)], base);\n}\n"
						},
						{
							"line": 42,
							"tags": [
								{
									"name": "@param",
									"type": "{Array<string>}",
									"desc": "files",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "options",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Map<string,string>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Mapping filenames to compiled JS code. ",
							"code": "function transform(files, options) {\n\tconst map = new Map();\n\tconst ext = options.extname || '.edbml.js';\n\toptions = prettier(options);\n\tfiles.forEach(file => {\n\t\tconst target = basename(file) + ext;\n\t\tconst jscode = parse(read(file), options);\n\t\tif (jscode instanceof Error) {\n\t\t\tfail(jscode, file, read(file));\n\t\t} else {\n\t\t\tmap.set(target, jscode);\n\t\t}\n\t});\n\treturn map;\n}\n"
						},
						{
							"line": 63,
							"tags": [
								{
									"name": "@param",
									"type": "{Error}",
									"desc": "error",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "file",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "edbml",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Log the failed file for inspection before we exit miserably. Note that we log the raw EDBML file and not the pre-processed JS that would have actually triggered the error (via \"step1.js\"). ",
							"code": "function fail(error, file, edbml) {\n\tconsole.log(`${error.message} in \"${file}\"\\n`);\n\tconsole.log(\n\t\tedbml\n\t\t\t.split('\\n')\n\t\t\t.map((line, i) => {\n\t\t\t\treturn padStart(i + 1, 3, 0) + '   ' + line;\n\t\t\t})\n\t\t\t.join('\\n')\n\t);\n\tprocess.exit(1);\n}\n"
						},
						{
							"line": 83,
							"tags": [
								{
									"name": "@param",
									"type": "{string|number}",
									"desc": "string",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{number}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string|number}",
									"desc": "[fill]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: Replace with native `string.padStart` at some point. ",
							"code": "function padStart(string, target, fill = ' ') {\n\tstring = String(string);\n\ttarget = target >> 0;\n\tfill = String(fill);\n\tif (string.length > target) {\n\t\treturn string;\n\t} else {\n\t\ttarget = target - string.length;\n\t\tif (target > fill.length) {\n\t\t\tfill += fill.repeat(target / fill.length);\n\t\t}\n\t\treturn fill.slice(0, target) + string;\n\t}\n}\n"
						},
						{
							"line": 104,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "edbml",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "options",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string|Array<string>}",
									"desc": "macros",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string|Error}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function parse(edbml, options = {}) {\n\treturn [step1, step2, step3, step4].reduce((result, step) => {\n\t\treturn result instanceof Error ? result : step(result, options);\n\t}, edbml);\n}\n"
						},
						{
							"line": 115,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "options",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Formatting output via Prettier using hardcoded settings for now. This should be synced to general repo to counter false Git diffs. TODO: Follow https://github.com/prettier/prettier/issues/42 ",
							"code": "function prettier(options) {\n\toptions.prettier = options.prettier || {\n\t\tuseTabs: true,\n\t\tsingleQuote: true,\n\t\tprintWidth: 1000\n\t};\n\treturn options;\n}\n"
						},
						{
							"line": 130,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "file",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function basename(file) {\n\treturn file.slice(0, file.lastIndexOf(path.extname(file)));\n}\n"
						},
						{
							"line": 137,
							"tags": [
								{
									"name": "@param",
									"type": "{Array<string>}",
									"desc": "files",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "base",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<string>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function makeabsolute(files, base) {\n\treturn files.map(file => {\n\t\tif (!path.isAbsolute(file)) {\n\t\t\tfile = path.normalize(path.join(base, file));\n\t\t}\n\t\treturn file;\n\t});\n}\n"
						},
						{
							"line": 150,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "stack",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function getsource(stack) {\n\treturn path.dirname(stack[1].getFileName());\n}\n"
						},
						{
							"line": 157,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "file",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function read(file) {\n\treturn fs.readFileSync(file, { encoding: 'UTF-8' });\n}\n"
						},
						{
							"line": 164,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "file",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "code",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: Ensure folder exists! ",
							"code": "function write(file, code) {\n\tif (code !== null) {\n\t\tfs.writeFileSync(file, code);\n\t}\n\treturn file;\n}\n"
						},
						{
							"line": 176,
							"tags": [
								{
									"name": "@param",
									"type": "{Array<string>|string}",
									"desc": "thing",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<string>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function makearray(thing) {\n\treturn Array.isArray(thing) ? thing : [thing];\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edbml-cli/src/step1.js": {
			"title": "step1",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import prettier from 'prettier';\nimport util from 'util';\n"
						},
						{
							"line": 2,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "script",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "options",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string|Error}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "We're gonna remove all JS comments, confirm basic syntactical integrity and standardize the general code style via Prettier. TODO: Support non-Babylon parser via options TODO: Preserve JSDoc comments ",
							"code": "export default function(script, options) {\n\treturn [prepare, parse, restore].reduce((code, step) => {\n\t\treturn code instanceof Error ? code : step(code, options);\n\t}, script);\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 17,
							"tags": [
								{
									"name": "@type",
									"type": "{RegExp}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Match @attribute name that can be declared as JS property using dots ",
							"code": "const NORMALS = /(?!\\n)\\s*@([A-Za-z]+[A-Za-z0-9_]*)\\s*=+/g;\n"
						},
						{
							"line": 22,
							"tags": [
								{
									"name": "@type",
									"type": "{RegExp}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Match @attribute name that must be declared as JS property using brackets. ",
							"code": "const SPECIAL = /(?!\\n)\\s*@(.[^\\s]*)\\s*=+/g;\n"
						},
						{
							"line": 27,
							"tags": [
								{
									"name": "@attribute",
									"type": "assignementswillberesolvedheresothattheyalsobecomevalid.",
									"desc": "",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "script",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Comment everything that looks like EDBML so that we can parse the code as JS. ",
							"code": "function prepare(script) {\n\tlet html = false;\n\tlet cont = false;\n\tlet lead = '';\n\tlet adds = line => line.endsWith('+');\n\tlet atts = line => {\n\t\treturn line.replace(NORMALS, 'out.$1 =').replace(SPECIAL, \"out['$1'] =\");\n\t};\n\treturn script\n\t\t.split('\\n')\n\t\t.map(line => {\n\t\t\tlead = /^\\s*/.exec(line);\n\t\t\tline = line.trim();\n\t\t\tswitch (line[0]) {\n\t\t\t\tcase '<':\n\t\t\t\t\thtml = true;\n\t\t\t\t\tcont = adds(line);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '+':\n\t\t\t\t\tcont = html;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '@':\n\t\t\t\t\tif (!cont) {\n\t\t\t\t\t\tline = atts(line);\n\t\t\t\t\t\thtml = false;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (cont) {\n\t\t\t\t\t\tcont = adds(line);\n\t\t\t\t\t} else {\n\t\t\t\t\t\thtml = false;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn (html ? '//!' : '') + lead + line;\n\t\t})\n\t\t.join('\\n');\n}\n"
						},
						{
							"line": 72,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "script",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string|Error}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Parse the script and prepare to remove JS comments. ",
							"code": "function parse(script) {\n\tlet error = null;\n\tscript = prettier.format(script, {\n\t\tuseTabs: true,\n\t\tsingleQuote: true,\n\t\tprintWidth: 1000,\n\t\tparser(text, { babylon }) {\n\t\t\tlet ast;\n\t\t\ttry {\n\t\t\t\tast = babylon(text);\n\t\t\t} catch (exception) {\n\t\t\t\tast = babylon('');\n\t\t\t\terror = exception;\n\t\t\t}\n\t\t\treturn strip(ast);\n\t\t}\n\t});\n\treturn error || script;\n}\n"
						},
						{
							"line": 96,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "ast",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Make comments identical so they can be targeted for deletion. ",
							"code": "function strip(ast) {\n\tast.comments.forEach(c => {\n\t\tif (!c.value.startsWith('!')) {\n\t\t\tc.value = '?';\n\t\t}\n\t});\n\treturn ast;\n}\n"
						},
						{
							"line": 109,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "script",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Delete the JS comments (but keep the markup comments). ",
							"code": "function restore(script) {\n\tconst block = /\\/\\*\\?\\*\\//g;\n\tconst lines = /\\/\\/\\?/g;\n\treturn [block, lines].reduce((result, regex) => {\n\t\treturn result.replace(regex, '');\n\t}, script);\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edbml-cli/src/step2.js": {
			"title": "step2",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "script",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<string>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "We're gonna combine multiple consecutive lines of markup into one single line. ",
							"code": "export default function(script) {\n\treturn script.split('\\n').reduce(reducer, []);\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 9,
							"tags": [
								{
									"name": "@type",
									"type": "{RegExp}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Matches a line of markup (that was commented out in the previous step). ",
							"code": "const MARKUP = /^\\s*\\/\\/!/;\n"
						},
						{
							"line": 14,
							"tags": [
								{
									"name": "@param",
									"type": "{Array<string>}",
									"desc": "result",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "line",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<string>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Collecting a list of lines, combining lines as we go along. ",
							"code": "function reducer(result, line) {\n\tconst was = !!result.now;\n\tif ((result.now = MARKUP.test(line))) {\n\t\tif (was) {\n\t\t\tresult[result.length - 1] += strip(line);\n\t\t} else {\n\t\t\tresult.push(strip(line, true));\n\t\t}\n\t} else {\n\t\tresult.push(line);\n\t}\n\treturn result;\n}\n"
						},
						{
							"line": 33,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "line",
									"text": "- One line of markup"
								},
								{
									"name": "@param",
									"type": "{boolean}",
									"desc": "[first]",
									"text": "- First or following line of markup?"
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Strip whitespace and all `+` used to concatenate multiple lines of markup. ",
							"code": "function strip(line, first) {\n\tconst LEAD = /^\\+/;\n\tconst ENDS = /\\+$/;\n\treturn first\n\t\t? line.trimRight().replace(ENDS, '')\n\t\t: line\n\t\t\t\t.replace(MARKUP, '')\n\t\t\t\t.trim()\n\t\t\t\t.replace(LEAD, '')\n\t\t\t\t.replace(ENDS, '');\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edbml-cli/src/step3.js": {
			"title": "step3",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import Parser from './Parser';\n"
						},
						{
							"line": 1,
							"tags": [
								{
									"name": "@param",
									"type": "{Array<string>}",
									"desc": "lines",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<string>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Compile EDBML to pure JS. TODO: Conceptualize peek|poke|passout|lockout (and also write it down!) ",
							"code": "export default function(lines) {\n\tconst parser = new Parser();\n\tlines = lines.map(lineparser(parser));\n\treturn inject(lines, parser.injections());\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 13,
							"tags": [
								{
									"name": "@type",
									"type": "{RegExp}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Matches a line of (still commented out) markup. ",
							"code": "const MARKUPCOMMENT = /^\\s*\\/\\/!/;\n"
						},
						{
							"line": 18,
							"tags": [
								{
									"name": "@param",
									"type": "{Parser}",
									"desc": "parser",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Function}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Returns a function to parse a line of markup into JS. ",
							"code": "function lineparser(parser) {\n\treturn (line, index) => {\n\t\tconst ishtml = MARKUPCOMMENT.test(line);\n\t\tif (ishtml) {\n\t\t\tline = line.replace(MARKUPCOMMENT, '');\n\t\t\tline = parseedbml(line, parser);\n\t\t}\n\t\tparser.reset(ishtml, index);\n\t\treturn line;\n\t};\n}\n"
						},
						{
							"line": 34,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "line",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{SAXParser}",
									"desc": "parser",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Parse a line of markup to produce a line of JS. ",
							"code": "function parseedbml(line, parser) {\n\tconst lead = /^\\s*/.exec(line);\n\tline = line.trim();\n\tline = line.replace(/^\\+/, '');\n\tline = line.replace(/\\+$/, '');\n\tline = parser.parse(line);\n\treturn lead + 'out`' + line + '`;';\n}\n"
						},
						{
							"line": 48,
							"tags": [
								{
									"name": "@param",
									"type": "{Array<string>}",
									"desc": "lines",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Map<number,Array<string>>}",
									"desc": "map",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<string>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function inject(lines, map) {\n\treturn lines.reduce((lines, line, index) => {\n\t\tlines.push(line);\n\t\tif (map.has(index)) {\n\t\t\tlines.push(...map.get(index));\n\t\t}\n\t\treturn lines;\n\t}, []);\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edbml-cli/src/step4.js": {
			"title": "step4",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import prettier from 'prettier';\n"
						},
						{
							"line": 1,
							"tags": [
								{
									"name": "@param",
									"type": "{Array<string>}",
									"desc": "lines",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "options",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Resolve import statements and declare variables in functon bodies. ",
							"code": "export default function(lines, options) {\n\treturn [functions, imports, cleanup].reduce((result, step) => {\n\t\treturn step(result, options);\n\t}, lines);\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 13,
							"tags": [
								{
									"name": "@type",
									"type": "{RegExp}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Match root level function declaration. ",
							"code": "const FUNCTION = /^(?:(export*)?)\\s*(?:(default*)*?)\\s*function(?=\\s*(?:\\w*)?\\s*\\(.*\\))/;\n"
						},
						{
							"line": 18,
							"tags": [
								{
									"name": "@type",
									"type": "{RegExp}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Extract function name from declaration. ",
							"code": "const FUNCNAME = /function\\s*([^\\(]*)/i;\n"
						},
						{
							"line": 23,
							"tags": [
								{
									"name": "@type",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "We expect this package in the node_modules folder. TODO: Let's explain this again, shall we? ",
							"code": "const RUNTIME = 'dataplastique'; \n"
						},
						{
							"line": 29,
							"tags": [
								{
									"name": "@param",
									"type": "{Array<string>}",
									"desc": "lines",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Resolve all functions in the script so that `out` and `att` are declared whenever needed. Make sure that exported functions also return something. ",
							"code": "function functions(lines) {\n\tlet main = [];\n\tlet func = false;\n\tlet body = null;\n\tlet name = null;\n\tlet expo = false;\n\tlines.forEach(line => {\n\t\tif (func) {\n\t\t\tif (line.trimRight() === '}') {\n\t\t\t\tmain.push(resolve(body, name, expo), line);\n\t\t\t\tfunc = false;\n\t\t\t} else {\n\t\t\t\tbody.push(line);\n\t\t\t}\n\t\t} else {\n\t\t\tif (FUNCTION.test(line)) {\n\t\t\t\tfunc = true;\n\t\t\t\tbody = [];\n\t\t\t\tname = FUNCNAME.exec(line)[1];\n\t\t\t\texpo = line.trimLeft().startsWith('export');\n\t\t\t\tmain.push(line);\n\t\t\t} else {\n\t\t\t\tmain.push(line);\n\t\t\t}\n\t\t}\n\t});\n\treturn main.join('\\n');\n}\n"
						},
						{
							"line": 63,
							"tags": [
								{
									"name": "@param",
									"type": "{Array<string>}",
									"desc": "body",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{boolean}",
									"desc": "expo",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Resolve a single function. TODO: Skip return if closest code has already returned something. ",
							"code": "function resolve(body, name, expo) {\n\tconst out = expo || body.some(l => /out`|out\\(/.test(l));\n\tconst intro = out ? `\\tconst out = output();` : '';\n\tconst extro = expo ? `\\treturn out();` : '';\n\treturn [intro, ...body, extro].join('\\n');\n}\n"
						},
						{
							"line": 77,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "script",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Import members from `dataplastique-edbml-runtime`. ",
							"code": "function imports(script) {\n\tconst list = /out`|out\\(/g.test(script) ? ['output'] : [];\n\tconst head = list[0]\n\t\t? `import { ${list.join(', ')} } from '${RUNTIME}';`\n\t\t: '';\n\treturn [head, script].join('\\n\\n');\n}\n"
						},
						{
							"line": 89,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "script",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "options",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: Cleanup cleaner. ",
							"code": "function cleanup(script, options) {\n\tconst notempty = line => line.trim() !== '';\n\treturn prettier.format(\n\t\tscript\n\t\t\t.split('\\n')\n\t\t\t.filter(notempty)\n\t\t\t.join('\\n'),\n\t\toptions\n\t);\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edbml-runtime/src/Out/attributes.js": {
			"title": "attributes",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{*}",
									"desc": "value",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "[type]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get one or more attribute declarations. ",
							"code": "export function htmlattribute(target, name, value, type = gettype(value)) {\n\tswitch (type) {\n\t\tcase 'null':\n\t\tcase 'undefined':\n\t\t\treturn '';\n\t\tcase 'object':\n\t\t\treturn getall(target, Object.entries(value));\n\t\tcase 'array':\n\t\t\treturn getall(value); \n\t\tdefault:\n\t\t\treturn getone(target, name, value, type);\n\t}\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 22,
							"tags": [
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{*}",
									"desc": "val",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "[type]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Declare single HTML attribute. ",
							"code": "function getone(target, name, val, type) {\n\tconst unsafe = encode(val, type || gettype(val));\n\treturn name + `=\"${target.guargh(unsafe)}\"`;\n}\n"
						},
						{
							"line": 34,
							"tags": [
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<Array<string,Any>>}",
									"desc": "entries",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Bulk declare HTML attributes. ",
							"code": "function getall(target, entries) {\n\treturn entries\n\t\t.map(entry => getone(target, ...entry))\n\t\t.join(' ')\n\t\t.trim();\n}\n"
						},
						{
							"line": 46,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "val",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get string type of something (somewhat better than typeof). That regexp matches 'Array' in '[object Array]' and so on. ",
							"code": "function gettype(val) {\n\tconst stringify = Object.prototype.toString;\n\tconst typematch = /\\s([a-zA-Z]+)/;\n\treturn stringify\n\t\t.call(val)\n\t\t.match(typematch)[1]\n\t\t.toLowerCase();\n}\n"
						},
						{
							"line": 60,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "val",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Stringify stuff to be used as HTML attribute values. TODO: in 'string' case, support simple/handcoded JSON object/array. ",
							"code": "function encode(val, type) {\n\tswitch (type) {\n\t\tcase 'string':\n\t\t\treturn val;\n\t\tcase 'number':\n\t\tcase 'boolean':\n\t\t\treturn String(val);\n\t\t\tbreak;\n\t\tcase 'date':\n\t\t\tthrow new Error('TODO: Encode standard date format?');\n\t\tdefault:\n\t\t\tthrow new Error('Could not create HTML attribute from: ' + type);\n\t}\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edbml-runtime/src/Out/deferred.js": {
			"title": "deferred",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "const [EVENTS, ELEMENTS, SPIRITS] = [\n\t'data-plastique-on', \n\t'data-plastique-elm', \n\t'data-plastique-gui' \n];\n"
						},
						{
							"line": 5,
							"tags": [
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "guids",
									"text": "- Elements with a specified `guid`"
								},
								{
									"name": "@param",
									"type": "{Map<string,Function>}",
									"desc": "defers",
									"text": "- All the deferred functions we know"
								},
								{
									"name": "@returns",
									"type": "{Array<Map>}",
									"desc": "",
									"text": "- mapping events, elements and spirits in that order"
								}
							],
							"tabs": "",
							"desc": "Map deferred calls into separate domains based on element attributes. TODO: Return more `null` instead of these empty Maps when not needed! ",
							"code": "export function mapdefer(guids, defers) {\n\tguids = translate(guids);\n\treturn [\n\t\tisolateevents(isolate(EVENTS, guids), defers),\n\t\tisolate(ELEMENTS, guids, defers),\n\t\tisolate(SPIRITS, guids, defers)\n\t];\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 21,
							"tags": [
								{
									"name": "@type",
									"type": "{Set<string>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Quickly identifies reserved HTML attributes. ",
							"code": "const reserved = new Set([EVENTS, ELEMENTS, SPIRITS]);\n"
						},
						{
							"line": 26,
							"tags": [
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "guids",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Map<string,Map<string,string>>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Remove from element all reserved attributes and transfer them to a Map. ",
							"code": "function translate(guids) {\n\tconst result = new Map();\n\tguids.forEach((elm, guid) => extractall(elm, guid, result));\n\treturn result;\n}\n"
						},
						{
							"line": 36,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "type",
									"text": "- Reserved attribute name"
								},
								{
									"name": "@param",
									"type": "{Map<string,Map<string,string>>}",
									"desc": "guids",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Map<string,Function>}",
									"desc": "[defers]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Map<string,Function|string>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Transfer reserved attribute of given type to unique Map. ",
							"code": "function isolate(type, guids, defers) {\n\tconst result = new Map();\n\tguids.forEach((map, guid) => {\n\t\tif (map.has(type)) {\n\t\t\tconst key = map.get(type);\n\t\t\tconst val = defers ? defers.get(key) : key;\n\t\t\tresult.set(guid, val);\n\t\t}\n\t});\n\treturn result;\n}\n"
						},
						{
							"line": 54,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "guid",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Map<string,Map>}",
									"desc": "result",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function extractall(elm, guid, result) {\n\tconst atts = elm.attributes;\n\tfor (let i = atts.length - 1; i >= 0; i--) {\n\t\textractone(elm, guid, result, atts.item(i));\n\t}\n}\n"
						},
						{
							"line": 65,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "guid",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Map<string,Map>}",
									"desc": "result",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Attr}",
									"desc": "att",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function extractone(elm, guid, result, { name, value }) {\n\tif (reserved.has(name)) {\n\t\trecordone(guid, result, name, value);\n\t\telm.removeAttribute(name);\n\t}\n}\n"
						},
						{
							"line": 77,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "guid",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Map<string,Map>}",
									"desc": "result",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "value",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function recordone(guid, result, name, value) {\n\tgetrecord(guid, result).set(name, value);\n}\n"
						},
						{
							"line": 86,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "guid",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Map<string,Map>}",
									"desc": "result",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Map}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function getrecord(guid, result) {\n\treturn result.get(guid) || result.set(guid, new Map()).get(guid);\n}\n"
						}
					]
				},
				{
					"title": "Event callbacks ",
					"tabs": "",
					"sections": [
						{
							"line": 95,
							"tags": [
								{
									"name": "@param",
									"type": "{Map<string,string>}",
									"desc": "guids",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Map<string,Function>}",
									"desc": "defers",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Map<string,Map<string,Function>>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "From the map of elements with deferred callbacks, find the ones that deal with events and transfer them to a new map. Note that the `data-plastique-on` attribute may index more than one event, so we will need to parse them individually. ",
							"code": "function isolateevents(guids, defers) {\n\tif (guids.size) {\n\t\tconst lookup = ([type, key]) => [type, change(key)];\n\t\tconst change = key => changefun(defers.get(key));\n\t\tguids.forEach((key, guid) => {\n\t\t\tguids.set(guid, new Map(splitup(key, defers, lookup)));\n\t\t});\n\t}\n\treturn guids;\n}\n"
						},
						{
							"line": 114,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "string",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Map<string,Function>}",
									"desc": "defers",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "lookup",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<Array<string,Function>>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "The attribute is indexing multiple events separated by `;`. ",
							"code": "function splitup(string, defers, lookup) {\n\treturn string\n\t\t.split(';')\n\t\t.map(sliceup)\n\t\t.map(lookup);\n}\n"
						},
						{
							"line": 127,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "part",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<string,string>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "The event listeners type and key are separated by `:`. ",
							"code": "function sliceup(part) {\n\tconst i = part.lastIndexOf(':');\n\treturn [part.substring(0, i), part.substring(i + 1)];\n}\n"
						},
						{
							"line": 136,
							"tags": [
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "fun",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Function}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Create callback function with special business logic for form elements. Note that this special business logic is dependant on some supporting code going on inside the project `dataplastique-edbml` (so at build time). TODO: The `Parser.js` should figure out if this is a form field TODO: always relay the (potential) CustomEvent data TODO: Further special business logic for select elements ",
							"code": "function changefun(fun) {\n\treturn function(e) {\n\t\tif (/input|textarea/.test(this.localName)) {\n\t\t\tfun(e, this.value, this.checked);\n\t\t} else {\n\t\t\tfun(e);\n\t\t}\n\t};\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edbml-runtime/src/Out/fixes.js": {
			"title": "fixes",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { safeattr } from './safe';\n"
						},
						{
							"line": 1,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "value",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<string>}",
									"desc": "unsafe",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<sSpirit|Node|NodeList>}",
									"desc": "nodes",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export function fixvalue(value, unsafe, nodes) {\n\tconst attribute = /^\\S+=\".*\"$/g;\n\tif (value) {\n\t\tif (isnode(value)) {\n\t\t\tconst marker = `{node:${nodes.length}}`;\n\t\t\tnodes.push(value);\n\t\t\treturn marker;\n\t\t} else {\n\t\t\tconst marker = `{unsafe:${unsafe.length}}`;\n\t\t\tunsafe.push(value);\n\t\t\treturn marker;\n\t\t}\n\t}\n\treturn '';\n}\n"
						},
						{
							"line": 22,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "data",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<string>}",
									"desc": "unsafe",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Note that this simply returns the unsafe value. It only becomes safe with further manhandling! ",
							"code": "export function fixtext(data, unsafe) {\n\treturn fix(data, unsafe);\n}\n"
						},
						{
							"line": 32,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "value",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<string>}",
									"desc": "unsafe",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export function fixattr(name, value, unsafe) {\n\treturn safeattr(name, fix(value, unsafe));\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 42,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "value",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: Test for non-primitive might be faster. ",
							"code": "function isnode(value) {\n\treturn !!value.nodeType || value.isModel || value.isSpirit;\n}\n"
						},
						{
							"line": 50,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "data",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<string>}",
									"desc": "unsafe",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "pipe",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function fix(data, unsafe) {\n\treturn data\n\t\t.split(/{unsafe:(\\d+)}/)\n\t\t.map((string, index) => {\n\t\t\treturn index % 2 === 0 ? string : unsafe[parseInt(string, 10)];\n\t\t})\n\t\t.join('');\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edbml-runtime/src/Out/index.js": {
			"title": "index",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { mapguids } from '@dataplastique/util';\nimport { runnable } from './runnable';\nimport { htmlattribute } from './attributes';\nimport { normalize, canonize } from './normalize';\nimport { mapdefer } from './deferred';\n"
						},
						{
							"line": 5,
							"tags": [
								{
									"name": "@type",
									"type": "{Map<string,*>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Tracking properties to generate HTML attributes. ",
							"code": "const props = new Map();\n"
						},
						{
							"line": 10,
							"tags": [
								{
									"name": "@type",
									"type": "{Symbol}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Keeping dependency injections private. ",
							"code": "const state = Symbol('state');\n"
						},
						{
							"line": 15,
							"tags": [],
							"tabs": "\t",
							"desc": "\n\n",
							"code": "export default class Out {\n"
						},
						{
							"line": 19,
							"tags": [
								{
									"name": "@type",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Tracking things that might be injected via constructor or methods calls. ",
							"code": "\t[state] = null;\n"
						},
						{
							"line": 24,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "[markup]",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array}",
									"desc": "[unsafe]",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array}",
									"desc": "[others]",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Map<string,Function>}",
									"desc": "[defers]",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\tconstructor(markup = '', unsafe = [], others = [], defers = []) {\n\t\tthis[state] = { markup, unsafe, others, defers };\n\t\tprops.clear();\n\t}\n"
						},
						{
							"line": 34,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "guid",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\ttoString(guid) {\n\t\treturn resolve(this, guid).innerHTML;\n\t}\n"
						},
						{
							"line": 41,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "guid",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{DocumentFragment}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "TODO: Apply event listeners and such! ",
							"code": "\ttoFragment(guid) {\n\t\treturn resolve(this, guid).content;\n\t}\n"
						},
						{
							"line": 49,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "guid",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Returns a list of aspects that can used to compare two instances of {Out} in order to support incremental DOM updates (the \"virtual DOM\" use case). ",
							"code": "\ttoAspects(guid) {\n\t\tconst cloned = resolve(this, guid, true);\n\t\tconst defers = this[state].defers;\n\t\treturn aspects(cloned, guid, defers);\n\t}\n"
						},
						{
							"line": 60,
							"tags": [
								{
									"name": "@returns",
									"type": "{Map<string,Function>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\tdeferred() {\n\t\treturn this[state].defers;\n\t}\n"
						},
						{
							"line": 66,
							"tags": [
								{
									"name": "@deprecated",
									"type": "",
									"desc": "",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Out}",
									"desc": "out",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "That {Out} is structurally identical (given unresolved values)? In that case, it it safe to call method `update` with that {Out}. TODO: Whenever this returns `true`, we can attempt to candidate the local `_ownmap` as reusable by all other instances of {Out}. This might however require an extra argument? Remember to mark this as a failure in case the template changes DOM structure. ",
							"code": "\tsimilar(out) {\n\t\treturn out[state].markup === this[state].markup;\n\t}\n"
						},
						{
							"line": 80,
							"tags": [
								{
									"name": "@deprecated",
									"type": "",
									"desc": "",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Out}",
									"desc": "out",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "That {Out} would produce that exact same output as this {Out}? This implies that both structure and state are identical except for all the deferred callbacks which are always unique. ",
							"code": "\tidentical(out) {\n\t\tconst mine = this[state];\n\t\tconst other = out[state];\n\t\treturn (\n\t\t\tthis.similar(out) &&\n\t\t\tequals(mine.unsafe, other.unsafe) &&\n\t\t\tequals(mine.others, other.others)\n\t\t);\n\t}\n"
						},
						{
							"line": 97,
							"tags": [
								{
									"name": "@param",
									"type": "{Out}",
									"desc": "out",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{this}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Assimilate state from another {Out}, making them identical. ",
							"code": "\tupdate(out) {\n\t\tif (this.similar(out)) {\n\t\t\tObject.assign(this[state], out[state]);\n\t\t} else {\n\t\t\tthrow new Error('Output must be structurally similar.');\n\t\t}\n\t\treturn this;\n\t}\n"
						}
					]
				},
				{
					"title": "Private ",
					"tabs": "\t",
					"sections": [
						{
							"line": 111,
							"tags": [
								{
									"name": "@type",
									"type": "{Function}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Temporarily store the template resolver here to avoid creating new ones. TODO: Global pool of runnables that can be shared between instances of `Out`. ",
							"code": "\t_run = null;\n"
						}
					]
				},
				{
					"title": "Proxy traps ",
					"tabs": "\t",
					"sections": [
						{
							"line": 118,
							"tags": [
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "out",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{String}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "The getter trap will expose all assigned properties in the form of HTML attribute declarations. For example, when you set the property \n`proxy.title = 'john' you will see the string `title=\"john\"` whenever you attempt to `alert(proxy.title)`. This allows for a syntax that will make it easy to maintain the generated script by hand in case the devs decide to abandon EDBML at some point, note however that this implies that it's not safe in EDBML to concatenate properties via the syntax \n`@class += ' newclass' (since this operation will read the property). ",
							"code": "\tstatic get(out, name) {\n\t\tswitch (name) {\n\t\t\tcase 'guargh':\n\t\t\tcase 'blargh':\n\t\t\tcase 'arrghs':\n\t\t\t\treturn out[name];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn out.blargh(htmlattribute(out, name, props.get(name)));\n\t\t\t\tbreak;\n\t\t}\n\t}\n"
						},
						{
							"line": 143,
							"tags": [
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "out",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{String}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{*}",
									"desc": "value",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Setter trap. ",
							"code": "\tstatic set(out, name, value) {\n\t\tprops.set(name, value);\n\t\treturn true;\n\t}\n"
						},
						{
							"line": 154,
							"tags": [
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "out",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "that",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<*>}",
									"desc": "args",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{*}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Apply trap. ",
							"code": "\tstatic apply(out, that, args) {\n\t\treturn out.apply(that, args);\n\t}\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 166,
							"tags": [
								{
									"name": "@param",
									"type": "{Out}",
									"desc": "out",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{String}",
									"desc": "guid",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{boolean}",
									"desc": "[canon]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{HTMLTemplateElement}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Creates a normalized and potentially canonical template with resolved values. ",
							"code": "function resolve(out, guid, canon = false) {\n\tconst clone = collapse(out, out[state]);\n\treturn canon ? canonize(clone, guid) : normalize(clone, guid);\n}\n"
						},
						{
							"line": 177,
							"tags": [
								{
									"name": "@param",
									"type": "{Out}",
									"desc": "out",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "state",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{HTMLTemplateElement}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Clone template and resolve with current state. ",
							"code": "function collapse(out, state) {\n\treturn (out._run || (out._run = runnable(state)))(state);\n}\n"
						},
						{
							"line": 186,
							"tags": [
								{
									"name": "@param",
									"type": "{HTMLTemplateElement}",
									"desc": "canonical",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "guid",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Map<string,function>}",
									"desc": "defers",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: We'll need less aspects (and only keys in some maps) when diffing old! ",
							"code": "function aspects(canonical, guid, defers) {\n\tconst fragment = canonical.content;\n\tconst rootelem = fragment.firstElementChild;\n\tconst elements = mapguids(rootelem, guid);\n\tconst deferred = mapdefer(elements, defers);\n\treturn [fragment, elements, ...deferred];\n}\n// TODO: Deprecate this? .......................................................\n"
						},
						{
							"line": 201,
							"tags": [
								{
									"name": "@param",
									"type": "{Array}",
									"desc": "a1",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array}",
									"desc": "a2",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Array members are identical? ",
							"code": "function equals(a1, a2) {\n\tconst same = (value, idx) => a2[idx] === value;\n\treturn a1.length === a2.length && a1.every(same);\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edbml-runtime/src/Out/normalize.js": {
			"title": "normalize",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [
								{
									"name": "@param",
									"type": "{HTMLTemplateElement}",
									"desc": "temp",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "guid",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{HTMLTemplateElement}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Normalize template. This basically means that we replace the `guid` attribute with the (hardcoded for now) `data-plastique-id` attribute. ",
							"code": "export function normalize(temp, guid) {\n\tconst frag = temp.content;\n\texpand(first(frag), guid);\n\treturn temp;\n}\n"
						},
						{
							"line": 12,
							"tags": [
								{
									"name": "@param",
									"type": "{HTMLTemplateElement}",
									"desc": "temp",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "guid",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{HTMLTemplateElement}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Canonize template to always contain a root level `this` element. ",
							"code": "export function canonize(temp, guid) {\n\ttemp = normalize(temp, guid);\n\trootguid(temp.content, guid);\n\treturn temp;\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 23,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "const first = node => node.firstElementChild,\n\tnext = node => node.nextElementSibling,\n\tiselm = node => node && node.nodeType === Node.ELEMENT_NODE,\n\tisroot = elm => iselm(elm) && elm.localName === 'this',\n\tnewelm = name => document.createElement(name),\n\tappend = (n1, n2) => n1.appendChild(n2),\n\thasguid = elm => elm.hasAttribute('guid'),\n\tgetguid = elm => elm.getAttribute('guid'),\n\tdelguid = elm => elm.removeAttribute('guid');\n"
						},
						{
							"line": 33,
							"tags": [
								{
									"name": "@param",
									"type": "{Element|null}",
									"desc": "elm",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "guid",
									"text": "The root guid"
								}
							],
							"tabs": "",
							"desc": "Replace all `guid` with `data-plastique-id`. TODO: We do that in the EDBML `Parser.js` now, so skip this for performance? ",
							"code": "function expand(elm, guid) {\n\tif (elm) {\n\t\texpand(first(elm), guid);\n\t\texpand(next(elm), guid);\n\t\tif (hasguid(elm)) {\n\t\t\tsetguid(elm, guid, getguid(elm));\n\t\t\tdelguid(elm);\n\t\t}\n\t}\n}\n"
						},
						{
							"line": 49,
							"tags": [
								{
									"name": "@param",
									"type": "{DocumentFragment}",
									"desc": "frag",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "guid",
									"text": "The root guid"
								},
								{
									"name": "@returns",
									"type": "{DocumentFragment}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "If the root element `this` doesn't exist, we'll go ahead and create it. Assigning the root `guid` to the `this` element so that all attribute and callback updates can be handled by the standard business logic \n(the `this` element represents the spirits element, just to clarify). ",
							"code": "function rootguid(frag, guid) {\n\tconst root = first(frag);\n\tif (isroot(root)) {\n\t\tdelguid(root);\n\t\tsetguid(root, guid);\n\t\treturn frag;\n\t} else {\n\t\treturn rootguid(createroot(frag), guid);\n\t}\n}\n"
						},
						{
							"line": 68,
							"tags": [
								{
									"name": "@param",
									"type": "{DocumentFragment}",
									"desc": "frag",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{DocumentFragment}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Enclose fragment members in a root level element. ",
							"code": "function createroot(frag) {\n\tlet node;\n\tconst root = newelm('this');\n\twhile ((node = frag.firstChild)) {\n\t\tappend(root, node);\n\t}\n\tappend(frag, root);\n\treturn frag;\n}\n"
						},
						{
							"line": 82,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "rootguid",
									"text": "The root (Spirit) guid"
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "elemguid",
									"text": "The local element guid"
								}
							],
							"tabs": "",
							"desc": "The `data-plastique-id` is a combo of the root guid and, if the element is not the root element, the element guid itself. ",
							"code": "function setguid(elm, rootguid, elemguid) {\n\telm.dataset.plastiqueId = rootguid + (elemguid ? `-${elemguid}` : '');\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edbml-runtime/src/Out/runnable.js": {
			"title": "runnable",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { fixtext, fixattr } from './fixes';\n"
						},
						{
							"line": 1,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "state",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Function}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export function runnable({ markup }) {\n\tconst elm = template(markup);\n\tconst map = index(elm.content);\n\treturn function run({ unsafe, others }) {\n\t\tresolve(map, unsafe);\n\t\treturn template(elm.innerHTML); \n\t};\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 14,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "markup",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{HTMLTemplateElement}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Initially creates the `template` element with unresolved content. TODO: Now also used to \"clone\" the template with resolved content because Edge ",
							"code": "function template(markup) {\n\tconst elm = document.createElement('template');\n\telm.innerHTML = markup;\n\treturn elm;\n}\n"
						},
						{
							"line": 25,
							"tags": [
								{
									"name": "@param",
									"type": "{Node}",
									"desc": "node",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Map}",
									"desc": "[map]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Map}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Mapping text and attribute nodes with dynamic value. ",
							"code": "function index(node, map = new Map()) {\n\tif (node) {\n\t\tindex(node.firstChild, map);\n\t\tindex(node.nextSibling, map);\n\t\tswitch (node.nodeType) {\n\t\t\tcase Node.TEXT_NODE:\n\t\t\t\tif (node.data.trim() !== '') {\n\t\t\t\t\tif (node.data.includes('{unsafe:')) {\n\t\t\t\t\t\tmap.set(node, node.data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase Node.ELEMENT_NODE:\n\t\t\t\tArray.from(node.attributes)\n\t\t\t\t\t.filter(att => att.value.includes('{unsafe:'))\n\t\t\t\t\t.forEach(att => map.set(att, att.value));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn map;\n}\n"
						},
						{
							"line": 52,
							"tags": [
								{
									"name": "@param",
									"type": "{Map<Node,string>}",
									"desc": "map",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array}",
									"desc": "unsafe",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function resolve(map, unsafe) {\n\tmap.forEach((data, node) => {\n\t\tif (node.nodeType === Node.TEXT_NODE) {\n\t\t\tnode.data = fixtext(data, unsafe);\n\t\t} else {\n\t\t\tnode.value = fixattr(node.name, data, unsafe);\n\t\t}\n\t});\n}\n"
						},
						{
							"line": 65,
							"tags": [
								{
									"name": "@param",
									"type": "{TextNode}",
									"desc": "node",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<sSpirit|Node|NodeList>}",
									"desc": "others",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{DocumentFragment}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function build(node, others) {\n\tconst frag = document.createDocumentFragment();\n\tconst cuts = node.data.split(/{node:(\\d+)}/);\n\tconst elem = n => (n.isSpirit ? n.element : n);\n\tcuts.forEach(part => {\n\t\tif (part.length) {\n\t\t\tconst index = parseInt(part, 10);\n\t\t\tif (isNaN(index)) {\n\t\t\t\tfrag.appendChild(document.createTextNode(part));\n\t\t\t} else {\n\t\t\t\tconst other = others[index];\n\t\t\t\tfrag.appendChild(elem(other));\n\t\t\t}\n\t\t}\n\t});\n\treturn frag;\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edbml-runtime/src/Out/safe.js": {
			"title": "safe",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "const safemap = {\n\t'&': '&amp;',\n\t'<': '&lt;',\n\t'>': '&gt;',\n\t'\"': '&quot;',\n\t\"'\": '&#39;'\n};\nconst unsafexp = /[&<>'\"]/g;\n"
						},
						{
							"line": 8,
							"tags": [
								{
									"name": "@see",
									"type": "https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet#RULE_.232_-_Attribute_Escape_Before_Inserting_Untrusted_Data_into_HTML_Common_Attributes",
									"desc": "",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": "TODO: This should determine how to escape the value!"
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "value",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Escape potentially unsafe string for use in HTML attribute context. TODO(jmo@): This is UNSAFE! We'll need to look at the attribute name! ",
							"code": "export function safeattr(name, value) {\n\treturn String(value).replace(unsafexp, c => safemap[c]);\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edbml-runtime/src/Out/validate.js": {
			"title": "validate",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "const rooted = html => `<wellformed>${html}</wellformed>`;\nconst unroot = html => html.replace(/<\\/*wellformed>/g, '');\nconst encode = html => html.replace(/&([^\\s]*);/g, '&amp;$1;');\nconst decode = html => html.replace(/&amp;([^\\s]*);/g, '&$1;');\nlet serial = null;\nlet parser = null;\n"
						},
						{
							"line": 6,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "markup",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": "If well-formed, returns this input markup"
								}
							],
							"tabs": "",
							"desc": "TODO: Enable this option! Attempt to parse the markup as XHTML. In case of failure, we return some substitute markup to render a parser error. Please note that such failure will not nescessarily throw an exception an all browsers. ",
							"code": "export function wellformed(markup) {\n\tparser = parser || (parser = new DOMParser());\n\tconst xml = encode(rooted(markup));\n\tconst doc = parser.parseFromString(xml, 'application/xhtml+xml');\n\tconst err = doc.querySelector('parsererror');\n\tif (err) {\n\t\tserial = serial || (serial = new XMLSerializer());\n\t\tmarkup = serial.serializeToString(doc.documentElement);\n\t\tmarkup = decode(unroot(markup));\n\t}\n\treturn markup;\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edbml-runtime/src/diffengine/compare.js": {
			"title": "compare",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { children } from './filter';\nimport { Key } from '@dataplastique/util';\nconst iselm = node => node && node.nodeType === Node.ELEMENT_NODE,\n\tistext = node => node && node.nodeType === Node.TEXT_NODE,\n\tclean = string => (string ? Key.removeKeys(string, 'cb') : null),\n\tgetatt = (node, name) => (iselm(node) ? node.getAttribute(name) : null),\n\tgetatts = elm => (iselm(elm) ? Array.from(elm.attributes) : []),\n\tgetguid = node => getatt(node, 'data-plastique-id'),\n\tsubguids = elm => Array.from(elm.children).map(getguid),\n\tmatchatt = (elm, att) => clean(getatt(elm, att.name)) === clean(att.value),\n\tcompatts = (elm1, elm2) => getatts(elm1).every(att => matchatt(elm2, att)),\n\tsametype = (node1, node2) => node1.nodeType === node2.nodeType,\n\tsamename = (elm1, elm2) => elm1.localName === elm2.localName,\n\tsametext = (txt1, txt2) => txt1.data === txt2.data,\n\tunique = (list1, list2) => list1.filter(entry => !list2.includes(entry)),\n\tnonulls = things => things.every(notnull),\n\tnotnull = thing => thing !== null;\n"
						},
						{
							"line": 17,
							"tags": [
								{
									"name": "@param",
									"type": "{Node}",
									"desc": "oldn",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Node}",
									"desc": "newn",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export function similar(oldn, newn) {\n\treturn oldn && newn && samenode(oldn, newn)\n\t\t? istext(oldn) || (samesize(oldn, newn) && samekids(oldn, newn))\n\t\t: false;\n}\n"
						},
						{
							"line": 27,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm1",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm2",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: Purge this! ",
							"code": "export function samesize(elm1, elm2) {\n\treturn elm1.childNodes.length === elm2.childNodes.length;\n}\n"
						},
						{
							"line": 36,
							"tags": [
								{
									"name": "@param",
									"type": "{Node}",
									"desc": "n1",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Node}",
									"desc": "n2",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: Rename this! ",
							"code": "export function samenode(n1, n2) {\n\treturn sametype(n1, n2)\n\t\t? iselm(n1)\n\t\t\t? samename(n1, n2) && getguid(n1)\n\t\t\t\t? sameguid(n1, n2)\n\t\t\t\t: sameatts(n1, n2)\n\t\t\t: sametext(n1, n2)\n\t\t: false;\n}\n"
						},
						{
							"line": 51,
							"tags": [
								{
									"name": "@param",
									"type": "{Element|DocumentFragment}",
									"desc": "node1",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Element|DocumentFragment}",
									"desc": "node2",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Direct children of two nodes appear to be similar? ",
							"code": "export function samekids(node1, node2) {\n\tconst [kids1, kids2] = [children(node1), children(node2)];\n\treturn kids1.every((kid1, i) => samenode(kid1, kids2[i]));\n}\n"
						},
						{
							"line": 61,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm1",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm2",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Same guid? ",
							"code": "export function sameguid(elm1, elm2) {\n\treturn getguid(elm1) === getguid(elm2);\n}\n"
						},
						{
							"line": 70,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm1",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm2",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Same attributes? ",
							"code": "export function sameatts(elm1, elm2) {\n\treturn compatts(elm1, elm2) && compatts(elm2, elm1);\n}\n"
						},
						{
							"line": 79,
							"tags": [
								{
									"name": "@param",
									"type": "{Node}",
									"desc": "oldn",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Node}",
									"desc": "newn",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: Account for textnodes (should only be whitespace). ",
							"code": "export function allguids(oldn, newn) {\n\treturn iselm(oldn) && iselm(newn)\n\t\t? do {\n\t\t\t\tconst oldkids = subguids(oldn);\n\t\t\t\tconst newkids = subguids(newn);\n\t\t\t\tnonulls(oldkids) && nonulls(newkids)\n\t\t\t\t\t? do {\n\t\t\t\t\t\t\ttrue;\n\t\t\t\t\t  }\n\t\t\t\t\t: false;\n\t\t  }\n\t\t: false;\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edbml-runtime/src/diffengine/events.js": {
			"title": "events",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [
								{
									"name": "@type",
									"type": "{WeakMap<Element,EventListener>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Mapping (root) element to Handler. ",
							"code": "const handlers = new WeakMap();\n"
						},
						{
							"line": 5,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "root",
									"text": "- The root element"
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "guid",
									"text": "- The root guid (which may not be a real attribute)"
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "ofun",
									"text": "- Callbacks found in old VDOM"
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "nfun",
									"text": "- Callbacks found in new VDOM"
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "oids",
									"text": "- Guid elements in old VDOM"
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "nids",
									"text": "- Guid elements in new VDOM"
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "nmap",
									"text": "- Guid elements in new real DOM"
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "omap",
									"text": "- Guid elements in old real DOM"
								}
							],
							"tabs": "",
							"desc": "For elements that were removed in the DOM update, remove all assigned listeners. For elements that remain, we only remove the listeners that will not eventually be reassigned by method `newcalls` below. TODO: Mechanism to flush the WeakMap when the `root` gets disconnected ",
							"code": "export function updateevents(root, guid, ofun, nfun, oids, nids, nmap, omap) {\n\tlet handler = handlers.get(root);\n\tif (handler) {\n\t\tremoveevents(ofun, nfun, oids, nids, nmap, omap, handler);\n\t\thandler.map = nfun;\n\t} else {\n\t\thandler = new Handler(nfun, guid);\n\t\thandlers.set(root, handler);\n\t}\n\taddevents(nfun, nmap, handler);\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 31,
							"tags": [
								{
									"name": "@implements",
									"type": "{EventListener}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "A handler to handle events. ",
							"code": "class Handler {\n\tmap = null;\n\tconstructor(map, guid) {\n\t\tthis.map = map;\n\t\tthis.guid = guid;\n\t}\n\thandleEvent(e) {\n\t\tconst elem = e.currentTarget;\n\t\tconst guid = elem.dataset.plastiqueId;\n\t\tconst type = this.map.get(guid || this.guid);\n\t\tconst func = type.get(e.type);\n\t\tif (func) {\n\t\t\tfunc.call(elem, e);\n\t\t}\n\t}\n}\n"
						},
						{
							"line": 51,
							"tags": [
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "ofun",
									"text": "- Callbacks found in old VDOM"
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "nfun",
									"text": "- Callbacks found in new VDOM"
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "oids",
									"text": "- Guid elements in old VDOM"
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "nids",
									"text": "- Guid elements in new VDOM"
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "nmap",
									"text": "- Guid elements in new real DOM"
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "omap",
									"text": "- Guid elements in old real DOM"
								},
								{
									"name": "@param",
									"type": "{Handler}",
									"desc": "handler",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "For elements that were removed in the DOM update, remove all assigned listeners. For elements that remain, we only remove the listeners that will not eventually be reassigned by method `addevents` down below. ",
							"code": "function removeevents(ofun, nfun, oids, nids, nmap, omap, handler) {\n\tomap.forEach((elm, guid) => {\n\t\tif (ofun.has(guid)) {\n\t\t\tconst oats = ofun.get(guid);\n\t\t\tconst nats = nfun.get(guid);\n\t\t\tconst gone = !nmap.has(guid);\n\t\t\toats.forEach((value, type) => {\n\t\t\t\tif (gone || (!nats || !nats.has(type))) {\n\t\t\t\t\telm.removeEventListener(type, handler);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n}\n"
						},
						{
							"line": 77,
							"tags": [
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "nfun",
									"text": "- Callbacks found in new VDOM"
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "nmap",
									"text": "- Guid elements in new real DOM"
								},
								{
									"name": "@param",
									"type": "{Handler}",
									"desc": "handler",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "When DOM updates are done, refresh and assign all the event listeners. ",
							"code": "function addevents(nfun, nmap, handler) {\n\tnmap.forEach((elm, guid) => {\n\t\tif (nfun.has(guid)) {\n\t\t\tnfun.get(guid).forEach((func, type) => {\n\t\t\t\telm.addEventListener(type, handler);\n\t\t\t});\n\t\t}\n\t});\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edbml-runtime/src/diffengine/filter.js": {
			"title": "filter",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "const istype = (node, type) => node && node.nodeType === type;\nconst istext = node => istype(node, Node.TEXT_NODE);\nconst iswhite = node => istext(node) && node.data.trim() === '';\nconst unwhite = node => !iswhite(node);\n"
						},
						{
							"line": 4,
							"tags": [
								{
									"name": "@param",
									"type": "{Node}",
									"desc": "node",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Node}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get first child node which is not a whitespace-only textnode. \n(so to avoid triggering updates on simple formatting changes). ",
							"code": "export const childnode = node => (node ? purge(node.firstChild) : null);\n"
						},
						{
							"line": 11,
							"tags": [
								{
									"name": "@param",
									"type": "{Node}",
									"desc": "node",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Node}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get follwong sibling node which is not a whitespace-only textnode. ",
							"code": "export const nextnode = node => (node ? purge(node.nextSibling) : null);\n"
						},
						{
							"line": 17,
							"tags": [
								{
									"name": "@param",
									"type": "{Element|DocumentFragment}",
									"desc": "node",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Element}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get first element child, ignoring this whole whitespace issue. ",
							"code": "export const childelm = node => (node ? node.firstElementChild : null);\n"
						},
						{
							"line": 23,
							"tags": [
								{
									"name": "@param",
									"type": "{Node}",
									"desc": "node",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Element}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get following element sibling. ",
							"code": "export const nextelm = node => (node ? node.nextElementSibling : null);\n"
						},
						{
							"line": 29,
							"tags": [
								{
									"name": "@param",
									"type": "{Element|DocumentFragment}",
									"desc": "node",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<Node>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get array of childnodes exluding whitespace-only textnodes. ",
							"code": "export const children = node => [...node.childNodes].filter(unwhite);\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 36,
							"tags": [
								{
									"name": "@param",
									"type": "{Node}",
									"desc": "n",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Node}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Crawl the DOM until you find something other than a whitespace textnode. ",
							"code": "function purge(n) {\n\treturn n && iswhite(n) ? purge(n.nextSibling) : iswhite(n) ? null : n;\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edbml-runtime/src/diffengine/focus.js": {
			"title": "focus",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [
								{
									"name": "@param",
									"type": "{Element|ShadowRoot}",
									"desc": "root",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Element|string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get the focused element, either by element reference or by selector scoped from the root element. Since the first option is less error prone, it is advised to always fit focusable elements with a `guid`. ",
							"code": "export function snapshotbefore(root) {\n\tconst elm = root.activeElement || document.activeElement;\n\tif (elm && root.contains(elm)) {\n\t\treturn elm.dataset.plastiqueId ? elm : selector(root, elm);\n\t}\n}\n"
						},
						{
							"line": 13,
							"tags": [
								{
									"name": "@param",
									"type": "{Element|ShadowRoot}",
									"desc": "root",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Element|string}",
									"desc": "elm",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Restore the focus while noting that the patch operation might have changed the DOM in such a way that a CSS selector will now target the wrong element. We supress potential `onfocus` event listeners since they were most likely intended for user instigated focus. TODO: Restore selection range!!! ",
							"code": "export function restoreafter(root, elm) {\n\tconst now = root.activeElement || document.activeElement;\n\tif (elm && (elm = elm.nodeType ? elm : root.querySelector(elm))) {\n\t\tif (root.contains(elm) && elm !== now) {\n\t\t\telm.focus();\n\t\t}\n\t}\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 30,
							"tags": [
								{
									"name": "@param",
									"type": "{Element|ShadowRoot}",
									"desc": "root",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Compute selector for focused element. ",
							"code": "function selector(root, elm) {\n\tconst parts = [];\n\tconst [ELEM, FRAG] = [Node.ELEMENT_NODE, Node.DOCUMENT_FRAGMENT_NODE];\n\twhile (elm && (elm.nodeType === ELEM || elm.nodeType === FRAG)) {\n\t\tif (elm.id) {\n\t\t\tparts.push('#' + elm.id);\n\t\t\telm = null;\n\t\t} else {\n\t\t\tif (elm === root) {\n\t\t\t\tparts.push(':scope ');\n\t\t\t\telm = null;\n\t\t\t} else {\n\t\t\t\tparts.push(` > ${elm.localName}:nth-child(${ordinal(elm)})`);\n\t\t\t\telm = elm.parentNode;\n\t\t\t}\n\t\t}\n\t}\n\treturn parts.reverse().join('');\n}\n"
						},
						{
							"line": 55,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{number}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get ordinal position of element within container. The index is one-based (and not zero-based) to conform with CSS conventions. Note: Bugs fixed here should be synchronized with {DOMPlugin}. ",
							"code": "function ordinal(elm) {\n\tlet result = 1;\n\tlet parent = elm.parentNode;\n\tif (parent) {\n\t\tlet node = parent.firstElementChild;\n\t\twhile (node && node !== elm) {\n\t\t\tnode = node.nextElementSibling;\n\t\t\tresult++;\n\t\t}\n\t}\n\treturn result;\n}\n"
						},
						{
							"line": 74,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Element}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: Something like this to supress `blur` and `focus` events during update? ",
							"code": "function silently(type, elm) {\n\tconst cb = e => e.stopPropagation();\n\telm.addEventListener(type, cb, true);\n\telm[type]();\n\telm.removeEventListener(type, cb, true);\n\treturn elm;\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edbml-runtime/src/diffengine/index.js": {
			"title": "index",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { mapguids } from '@dataplastique/util';\nimport { updateevents } from './events';\nimport { snapshotbefore, restoreafter } from './focus';\nimport { removekids, replacenode, replacekids } from './mutate';\nimport { childnode, nextnode, childelm, nextelm } from './filter';\nimport {\n\tsimilar,\n\tsamenode,\n\tsamesize,\n\tsamekids,\n\tsameguid,\n\tsameatts,\n\tallguids\n} from './compare';\nimport {\n\thardupdate,\n\tsoftupdate,\n\tattsupdate,\n\tupdatesoft,\n\tsoftqualify,\n\tbreakdown\n} from './updates';\n\n"
						},
						{
							"line": 23,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "root",
									"text": "- The root element"
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "guid",
									"text": "- The root `$id`"
								},
								{
									"name": "@param",
									"type": "{Out}",
									"desc": "newout",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Out|null}",
									"desc": "oldout",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<function>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export function getdiffs(root, guid, newout, oldout) {\n\tconst [ndoc, nids, nfun, doelm, dogui] = newout.toAspects(guid);\n\tconst [odoc, oids, ofun] = oldout.toAspects(guid);\n\treturn [\n\t\t...treediffs(root, guid, odoc, ndoc, oids, nids),\n\t\t...miscdiffs(root, guid, oids, nids, ofun, nfun, doelm, dogui)\n\t];\n}\n"
						},
						{
							"line": 38,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "root",
									"text": "- The root element"
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "guid",
									"text": "- The root guid"
								},
								{
									"name": "@param",
									"type": "{Array<function>}",
									"desc": "diffs",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": "- TODO: More info!"
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export function patchdiffs(root, guid, diffs) {\n\tconst log = Object.create(null);\n\tif (diffs.length) {\n\t\tconst range = document.createRange();\n\t\tconst focus = snapshotbefore(root);\n\t\tconst guids = mapguids(root, guid);\n\t\tdiffs.forEach(diff => diff(range, guids));\n\t\trestoreafter(root, focus);\n\t\trange.detach();\n\t}\n\treturn log;\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 56,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "const asarray = alike => Array.from(alike),\n\tistype = (node, type) => node && node.nodeType === type,\n\tgetatt = (elm, name) => (elm ? elm.getAttribute(name) : null),\n\tsetatt = (elm, name, val) => elm.setAttribute(name, val),\n\tdelatt = (elm, name) => elm.removeAttribute(name),\n\thasatt = (elm, name) => (elm ? !!elm.hasAttribute(name) : false),\n\tgetatts = elm => (iselm(elm) ? asarray(elm.attributes) : []),\n\thasatts = elm => (elm ? !!elm.attributes.length : false),\n\tmapatts = elm => new Map(getatts(elm).map(att => [att.name, att.value])),\n\tsubmap = elm => new Map(asarray(elm.children).map(e => [getguid(e), e])),\n\tgetguid = node => (iselm(node) ? getatt(node, 'data-plastique-id') : null),\n\thasclass = elm => (elm ? !!elm.className : false),\n\tclasses = elm => (elm ? elm.classList : null),\n\tiselm = node => istype(node, Node.ELEMENT_NODE),\n\tistext = node => istype(node, Node.TEXT_NODE),\n\tqueryall = (css, ctx) => asarray(ctx.querySelectorAll(css)),\n\tqueryone = (css, ctx) => ctx.querySelector(css),\n\tunique = (a1, a2) => a1.filter(e => !a2.includes(e));\n"
						}
					]
				},
				{
					"title": "Diffing elements and attributes ",
					"tabs": "",
					"sections": [
						{
							"line": 76,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "root",
									"text": "- The root element"
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "guid",
									"text": "- The root guid"
								},
								{
									"name": "@param",
									"type": "{DocumentFragment}",
									"desc": "odoc",
									"text": "- The old VDOM"
								},
								{
									"name": "@param",
									"type": "{DocumentFragment}",
									"desc": "ndoc",
									"text": "- The new VDOM"
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "oids",
									"text": "- Guid elements in old VDOM"
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "nids",
									"text": "- Guid elements in new VDOM"
								},
								{
									"name": "@returns",
									"type": "{Array<Function>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function treediffs(root, guid, odoc, ndoc, oids, nids) {\n\treturn oids.size > 1 && odoc.hasChildNodes()\n\t\t? do {\n\t\t\t\tconst updates = trawl(oids, odoc, ndoc, guid);\n\t\t\t\tconst reduced = reduce(updates, oids);\n\t\t\t\tconst actions = getactions(oids, nids);\n\t\t\t\tcompile(reduced, actions);\n\t\t  }\n\t\t: [\n\t\t\t\trange => {\n\t\t\t\t\tconst olde = oids.get(guid);\n\t\t\t\t\tconst newe = nids.get(guid);\n\t\t\t\t\treplacekids(range, root, newe);\n\t\t\t\t\tsyncattribs(root, olde, newe);\n\t\t\t\t}\n\t\t  ];\n}\n"
						},
						{
							"line": 102,
							"tags": [
								{
									"name": "@param",
									"type": "{Array<Object>}",
									"desc": "updates",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "actions",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<Function>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: Offer the developer a chance to debug this array of update objects before they all get converted to functions. ",
							"code": "function compile(updates, actions) {\n\treturn updates.map(({ type, guid, operations }) => (range, xids) => {\n\t\treturn actions[type](range, xids, guid, operations);\n\t});\n}\n"
						},
						{
							"line": 114,
							"tags": [
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "oids",
									"text": "- All `guid` elements in old VDOM"
								},
								{
									"name": "@param",
									"type": "{Node}",
									"desc": "oldn",
									"text": "- Some node in the old VDOM"
								},
								{
									"name": "@param",
									"type": "{Node}",
									"desc": "newn",
									"text": "- Some node in the new VDOM, which could be different"
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "aguid",
									"text": "- Last known `guid` as seen on an ancestor element"
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "pguid",
									"text": "- The `guid` of the parent node, if there was one"
								},
								{
									"name": "@param",
									"type": "{Array<Object>}",
									"desc": "[updates]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<Object>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function trawl(oids, oldn, newn, aguid, pguid, updates = []) {\n\tconst [child, next, guid] = [childnode, nextnode, getguid];\n\tif (oldn || newn) {\n\t\tif (similar(oldn, newn)) {\n\t\t\tif (sameguid(oldn, newn) && !sameatts(oldn, newn)) {\n\t\t\t\tupdates.push(attsupdate(guid(oldn)));\n\t\t\t}\n\t\t\ttrawl(\n\t\t\t\toids,\n\t\t\t\tchild(oldn),\n\t\t\t\tchild(newn),\n\t\t\t\tguid(oldn) || aguid,\n\t\t\t\tguid(oldn),\n\t\t\t\tupdates\n\t\t\t);\n\t\t\ttrawl(oids, next(oldn), next(newn), aguid, pguid, updates);\n\t\t} else if (pguid && sameguid(oldn, newn) && allguids(oldn, newn)) {\n\t\t\tif (softqualify(oids, oldn, newn)) {\n\t\t\t\tupdates.push(\n\t\t\t\t\tsoftupdate(guid(oldn), oldn, newn),\n\t\t\t\t\tattsupdate(guid(oldn))\n\t\t\t\t);\n\t\t\t\ttrawlon(oids, submap(oldn), submap(newn), updates);\n\t\t\t} else {\n\t\t\t\tupdates.push(hardupdate(aguid), attsupdate(aguid));\n\t\t\t}\n\t\t} else {\n\t\t\tupdates.push(hardupdate(aguid), attsupdate(aguid));\n\t\t}\n\t}\n\treturn updates;\n}\n"
						},
						{
							"line": 155,
							"tags": [
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "oids",
									"text": "- Guid elements in old VDOM"
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "oldmap",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "newmap",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<Object>}",
									"desc": "[updates]",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: Attsupdate! \n\n",
							"code": "function trawlon(oids, oldmap, newmap, updates) {\n\tnewmap.forEach((newn, guid) => {\n\t\tconst oldn = oldmap.get(guid);\n\t\tif (oldn) {\n\t\t\ttrawl(oids, childnode(oldn), childnode(newn), guid, guid, updates);\n\t\t}\n\t});\n}\n"
						},
						{
							"line": 171,
							"tags": [
								{
									"name": "@param",
									"type": "{Array<Object>}",
									"desc": "updates",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "oids",
									"text": "- Guid elements in old VDOM"
								},
								{
									"name": "@returns",
									"type": "{Array<Function>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "The idea here is to igore updates to nodes inside a hardupdated DOM branch. TODO: Clean this up and get a general idea about performance of `contains`. ",
							"code": "function reduce(updates, oids) {\n\tconst elem = ({ guid }) => oids.get(guid);\n\tconst hard = ({ type }) => type === 'hardupdate';\n\tconst pass = n => h => h === n || !h.contains(n);\n\tconst list = updates.filter(hard).map(elem);\n\treturn updates.reduce((subset, update) => {\n\t\tif (list.every(pass(elem(update)))) {\n\t\t\tsubset.push(update);\n\t\t}\n\t\treturn subset;\n\t}, []);\n}\n"
						},
						{
							"line": 190,
							"tags": [
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "oids",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "nids",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "function getactions(oids, nids) {\n"
						},
						{
							"line": 196,
							"tags": [
								{
									"name": "@param",
									"type": "{Range}",
									"desc": "range",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "xids",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "guid",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\tfunction hardupdate(range, xids, guid) {\n\t\tconst xelm = xids.get(guid);\n\t\tconst olde = oids.get(guid);\n\t\tconst newe = nids.get(guid);\n\t\tif (xelm) {\n\t\t\tpatchstart(range, xelm, newe, oids, nids, xids);\n\t\t}\n\t}\n"
						},
						{
							"line": 209,
							"tags": [
								{
									"name": "@param",
									"type": "{Range}",
									"desc": "range",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "xids",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "guid",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\tfunction attsupdate(range, xids, guid) {\n\t\tconst xelm = xids.get(guid);\n\t\tconst olde = oids.get(guid);\n\t\tconst newe = nids.get(guid);\n\t\tif (xelm) {\n\t\t\tsyncattribs(xelm, olde, newe);\n\t\t}\n\t}\n"
						},
						{
							"line": 222,
							"tags": [
								{
									"name": "@param",
									"type": "{Range}",
									"desc": "range",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "xids",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "guid",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<Object>}",
									"desc": "operations",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "\tfunction softupdate(range, xids, guid, operations) {\n\t\tupdatesoft(guid, xids, nids, operations);\n\t}\n\treturn { hardupdate, attsupdate, softupdate };\n}\n// Diffing more stuff! .........................................................\nfunction miscdiffs(root, guid, oids, nids, ofun, nfun, doelm, dogui) {\n\treturn [\n\t\t(range, oldmap) => {\n\t\t\tconst newmap = mapguids(root, guid);\n\t\t\t[\n\t\t\t\t...getcallbackdiffs(root, guid, ofun, nfun, oids, nids),\n\t\t\t\t...getsetandcall(root, guid, doelm, dogui)\n\t\t\t].forEach(diff => diff(newmap, oldmap));\n\t\t}\n\t];\n}\n"
						}
					]
				},
				{
					"title": "Diffing callbacks ",
					"tabs": "",
					"sections": [
						{
							"line": 246,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "root",
									"text": "- The root element"
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "guid",
									"text": "- The root guid"
								},
								{
									"name": "@param",
									"type": "{Map<string,string>}",
									"desc": "ofun",
									"text": "- Callbacks found in old VDOM"
								},
								{
									"name": "@param",
									"type": "{Map<string,string>}",
									"desc": "nfun",
									"text": "- Callbacks found in new VDOM"
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "oids",
									"text": "- Guid elements in old VDOM"
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "nids",
									"text": "- Guid elements in new VDOM"
								},
								{
									"name": "@returns",
									"type": "{Array<function>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Remove old event callbaks and assign new callbacks. ",
							"code": "function getcallbackdiffs(root, guid, ofun, nfun, oids, nids) {\n\treturn [\n\t\t(newmap, oldmap) => {\n\t\t\tupdateevents(root, guid, ofun, nfun, oids, nids, newmap, oldmap);\n\t\t}\n\t];\n}\n"
						},
						{
							"line": 263,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "root",
									"text": "- The root element"
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "guid",
									"text": "- The root guid"
								},
								{
									"name": "@param",
									"type": "{Map<string,Map<string,Function>>}",
									"desc": "doelm",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Map<string,Map<string,Function>>}",
									"desc": "dogui",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "nids",
									"text": "- Guid elements in new VDOM"
								},
								{
									"name": "@returns",
									"type": "{Array<Function>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function getsetandcall(root, guid, doelm, dogui) {\n\tconst proplist = [...doelm.entries()];\n\tconst calllist = [...dogui.entries()];\n\tconst update = (newmap, [guid, action], iselm) => {\n\t\tconst xelm = newmap.get(guid);\n\t\tiselm ? action(xelm) : console.warn('TODO: do:gui');\n\t};\n\treturn [\n\t\t...proplist.map(up => newmap => update(newmap, up, true)),\n\t\t...calllist.map(up => newmap => update(newmap, up, false))\n\t];\n}\n"
						}
					]
				},
				{
					"title": "Patching elements ",
					"tabs": "",
					"sections": [
						{
							"line": 284,
							"tags": [
								{
									"name": "@param",
									"type": "{Range}",
									"desc": "range",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "xelm",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Element|DocumentFragment}",
									"desc": "newn",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "oids",
									"text": "Guid elements in the old VDOM"
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "nids",
									"text": "Guid elements in the new VDOM"
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "originals",
									"text": "Guid elements in the real DOM"
								}
							],
							"tabs": "",
							"desc": "TODO: Consider using a temporary document fragment for this operation. ",
							"code": "function patchstart(range, xelm, newn, oids, nids, originals) {\n\treplacekids(range, xelm, newn, oids, nids, originals);\n\trestoreoriginals(range, xelm, oids, nids, originals);\n}\n"
						},
						{
							"line": 297,
							"tags": [
								{
									"name": "@param",
									"type": "{Range}",
									"desc": "range",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Element|DocumentFragment}",
									"desc": "elm",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "oids",
									"text": "Guid elements in the old VDOM"
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "nids",
									"text": "Guid elements in the new VDOM"
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "originals",
									"text": "Guid elements removed from real DOM"
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function restoreoriginals(range, elm, oids, nids, originals) {\n\tconst changelings = mapguids(elm);\n\tchangelings.forEach((changeling, guid) => {\n\t\tif (originals.has(guid)) {\n\t\t\tconst original = originals.get(guid);\n\t\t\tif (changeling !== original) {\n\t\t\t\tswapchangeling(range, changeling, original, oids, nids);\n\t\t\t}\n\t\t}\n\t});\n}\n"
						},
						{
							"line": 315,
							"tags": [
								{
									"name": "@param",
									"type": "{Range}",
									"desc": "range",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "changeling",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "original",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "oids",
									"text": "Guid elements in the old VDOM"
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "nids",
									"text": "Guid elements in the new VDOM"
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function swapchangeling(range, changeling, original, oids, nids) {\n\tconst guid = getguid(original);\n\tconst olde = oids.get(guid);\n\tconst newe = nids.get(guid);\n\tremovekids(range, original);\n\treplacenode(changeling, original);\n\treplacekids(range, original, changeling);\n\tsyncattribs(original, olde, newe);\n}\n"
						}
					]
				},
				{
					"title": "Patching attributes ",
					"tabs": "",
					"sections": [
						{
							"line": 332,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm",
									"text": "The DOM element as seen on stage"
								},
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "oldn",
									"text": "The equivalent element in old VDOM"
								},
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "newn",
									"text": "The equivalent element in new VDOM"
								}
							],
							"tabs": "",
							"desc": "Synchronize attributes. ",
							"code": "function syncattribs(elm, oldn, newn) {\n\tif (hasatts(oldn) || hasatts(newn)) {\n\t\tconst oatts = mapatts(oldn);\n\t\tconst natts = mapatts(newn);\n\t\tconst names = ['class', 'data-plastique-id'];\n\t\tconst skips = name => names.some(n => name === n);\n\t\tnatts.forEach((v, n) => (skips(n) ? void 0 : setatt(elm, n, v)));\n\t\toatts.forEach(\n\t\t\t(v, n) => (skips(n) || natts.has(n) ? void 0 : delatt(elm, n))\n\t\t);\n\t\tif (hasclass(oldn) || hasclass(newn)) {\n\t\t\tsyncclass(classes(elm), classes(oldn), classes(newn));\n\t\t}\n\t}\n}\n"
						},
						{
							"line": 353,
							"tags": [
								{
									"name": "@param",
									"type": "{ClassList}",
									"desc": "list",
									"text": "current"
								},
								{
									"name": "@param",
									"type": "{ClassList}",
									"desc": "olist",
									"text": "before"
								},
								{
									"name": "@param",
									"type": "{ClassList}",
									"desc": "nlist",
									"text": "after"
								}
							],
							"tabs": "",
							"desc": "Synchronize class list. ",
							"code": "function syncclass(list, olist, nlist) {\n\tconst added = c => !olist || !olist.contains(c);\n\tconst nuked = c => !nlist.contains(c);\n\tasarray(nlist)\n\t\t.filter(added)\n\t\t.forEach(c => list.add(c));\n\tif (olist) {\n\t\tasarray(olist)\n\t\t\t.filter(nuked)\n\t\t\t.forEach(c => list.remove(c));\n\t}\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edbml-runtime/src/diffengine/mutate.js": {
			"title": "mutate",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [
								{
									"name": "@param",
									"type": "{Range}",
									"desc": "range",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Remove element childnodes. ",
							"code": "export function removekids(range, elm) {\n\trange.selectNodeContents(elm);\n\trange.deleteContents();\n}\n"
						},
						{
							"line": 9,
							"tags": [
								{
									"name": "@param",
									"type": "{Node}",
									"desc": "oldn",
									"text": "The node to replace."
								},
								{
									"name": "@param",
									"type": "{Node}",
									"desc": "newn",
									"text": "The node to insert."
								},
								{
									"name": "@returns",
									"type": "{Node}",
									"desc": "",
									"text": "Returns the new node."
								}
							],
							"tabs": "",
							"desc": "Swap node with other node. ",
							"code": "export function replacenode(oldn, newn) {\n\tconst parent = oldn.parentNode;\n\tparent.replaceChild(newn, oldn);\n\treturn newn;\n}\n"
						},
						{
							"line": 20,
							"tags": [
								{
									"name": "@param",
									"type": "{Range}",
									"desc": "range",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "other",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Replace element childnodes with other childnodes. ",
							"code": "export function replacekids(range, elm, other) {\n\tremovekids(range, elm);\n\trange.selectNodeContents(other);\n\telm.appendChild(range.extractContents());\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edbml-runtime/src/diffengine/updates.js": {
			"title": "updates",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "guid",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Defines a hard update. The entire DOM subtree of the element will be replaced except all descendants with a declared `guid` will be substituted back again. ",
							"code": "export function hardupdate(guid) {\n\treturn { type: 'hardupdate', guid };\n}\n"
						},
						{
							"line": 9,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "guid",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Defines an attribute update. Attributes will be updated yo. ",
							"code": "export function attsupdate(guid) {\n\treturn { type: 'attsupdate', guid };\n}\n"
						},
						{
							"line": 17,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "guid",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Node}",
									"desc": "oldn",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Node}",
									"desc": "newn",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Defines a \"soft\" update where nodes are removed, inserted or moved around provided that 1) the parent has a `guid` and 2) all children have a `guid`. Typical operations such as adding an item to a list can thus perform max. ",
							"code": "export function softupdate(guid, oldn, newn) {\n\treturn { type: 'softupdate', guid, operations: getoperations(oldn, newn) };\n}\n"
						},
						{
							"line": 29,
							"tags": [
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "oids",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "oldn",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "newn",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Before scheduling a soft update, confirm that all new elements are indeed new and not simply moved into the local node list from somewhere else in the document (the system will in that case fall back to a `hardupdate`). ",
							"code": "export function softqualify(oids, oldn, newn) {\n\tconst { oldkids, newkids } = breakdown(oldn, newn);\n\tconst moved = guid => oldkids.includes(guid);\n\tconst isnew = guid => !oids.has(guid) || moved(guid);\n\treturn newkids.every(isnew);\n}\n"
						},
						{
							"line": 44,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "guid",
									"text": "- guid for parent whose children are updated."
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "xids",
									"text": "- Guid elements in real DOM"
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "nids",
									"text": "- Guid elements in new VDOM"
								},
								{
									"name": "@param",
									"type": "{Array<Object>}",
									"desc": "operations",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export function updatesoft(guid, xids, nids, operations) {\n\toperations.forEach(op => executesoft(guid, xids, nids, op));\n}\n"
						},
						{
							"line": 53,
							"tags": [
								{
									"name": "@param",
									"type": "{Node}",
									"desc": "oldn",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Node}",
									"desc": "newn",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: Document members of the returned object here! ",
							"code": "export function breakdown(oldn, newn) {\n\tconst [oldkids, newkids] = [childguids(oldn), childguids(newn)];\n\tconst [addlist, outlist] = [uniq(newkids, oldkids), uniq(oldkids, newkids)];\n\tconst remains = uniq(oldkids, outlist);\n\tconst results = remains.concat(newkids);\n\treturn { oldkids, newkids, addlist, outlist, remains, results };\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 66,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "const uniq = (a1, a2) => a1.filter(e => !a2.includes(e));\nconst getguid = elm => elm.getAttribute('data-plastique-id');\nconst childguids = elm => Array.from(elm.children).map(getguid);\n"
						},
						{
							"line": 70,
							"tags": [],
							"tabs": "",
							"desc": "\n\n",
							"code": "const operations = (operation => ({\n\tremove: guid => operation('remove', guid),\n\tmove: (guid, prev) => operation('move', guid, prev),\n\tinsert: (guid, prev) => operation('insert', guid, prev)\n}))((type, guid, prev) => ({ type, guid, prev }));\n"
						},
						{
							"line": 78,
							"tags": [
								{
									"name": "@param",
									"type": "{Node}",
									"desc": "oldn",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Node}",
									"desc": "newn",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<Object>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function getoperations(oldn, newn) {\n\tconst { newkids, addlist, outlist, remains } = breakdown(oldn, newn);\n\treturn newkids.reduce(\n\t\tgetreducer(remains, addlist),\n\t\toutlist.map(operations.remove)\n\t);\n}\n"
						},
						{
							"line": 90,
							"tags": [
								{
									"name": "@param",
									"type": "{Array<string>}",
									"desc": "remains",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<string>}",
									"desc": "addlist",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Function}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function getreducer(remains, addlist) {\n\treturn (ops, newguid, i) => {\n\t\tconst oldguid = remains[i];\n\t\tconst preguid = remains[i - 1];\n\t\tif (oldguid !== newguid) {\n\t\t\tremains.splice(i, 0, newguid);\n\t\t\tops.push(\n\t\t\t\taddlist.includes(newguid)\n\t\t\t\t\t? operations.insert(newguid, preguid)\n\t\t\t\t\t: operations.move(newguid, preguid)\n\t\t\t);\n\t\t}\n\t\treturn ops;\n\t};\n}\n"
						},
						{
							"line": 110,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "parent",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "xids",
									"text": "- Guid elements in real DOM"
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "nids",
									"text": "- Guid elements in new VDOM"
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "operation",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function executesoft(parent, xids, nids, { type, guid, prev }) {\n\treturn executions[type](parent, guid, prev, xids, nids, guid);\n}\n"
						},
						{
							"line": 120,
							"tags": [],
							"tabs": "\t",
							"desc": "Methods to execute the soft operations (patch the diffs). TODO: Sync the attributes :/ TODO: Use the Range object for these operations. ",
							"code": "const executions = (() => {\n"
						},
						{
							"line": 126,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "parent",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "guid",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "prev",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "xids",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\tfunction remove(parent, guid, prev, xids) {\n\t\txids.get(guid).remove();\n\t}\n"
						},
						{
							"line": 135,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "parent",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "guid",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "prev",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "xids",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\tfunction move(parent, guid, prev, xids) {\n\t\tconst oldnode = xids.get(guid);\n\t\tif (oldnode.parentNode === (parent = xids.get(parent))) {\n\t\t\tif (prev) {\n\t\t\t\tprev = xids.get(prev);\n\t\t\t\tparent.insertBefore(oldnode, prev.nextSibling);\n\t\t\t} else {\n\t\t\t\tparent.prepend(oldnode);\n\t\t\t}\n\t\t}\n\t}\n"
						},
						{
							"line": 152,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "parent",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "guid",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "prev",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "xids",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Map<string,Element>}",
									"desc": "nids",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "\tfunction insert(parent, guid, prev, xids, nids) {\n\t\tparent = xids.get(parent);\n\t\tconst newnode = nids.get(guid);\n\t\tif (prev) {\n\t\t\tprev = xids.get(prev) || nids.get(prev);\n\t\t\tparent.insertBefore(newnode, prev.nextSibling);\n\t\t} else {\n\t\t\tparent.prepend(newnode);\n\t\t}\n\t}\n\treturn { remove, move, insert };\n})();\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/edbml-runtime/src/index.js": {
			"title": "index",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import Out from './Out/';\nimport { fixvalue } from './Out/fixes';\nimport { getdiffs, patchdiffs } from './diffengine/';\n"
						},
						{
							"line": 3,
							"tags": [
								{
									"name": "@type",
									"type": "{Function}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Function to collects markup during EDBML rendering phase. It works like this: When the initial EDBML function is called, it will render directly via this function. All subsequent (nested) function calls will render indirectly via another function. Only the first function (this function) has the ability to produce the HTML result and this operation will also reset the whole setup. This way, any public (exported) function can become the rendering entry point even though they all have the same basic code structure. ",
							"code": "let first = null;\n"
						},
						{
							"line": 14,
							"tags": [
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "[defer]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Function}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: Make this stuff run in Node and Workers. Could JSDOM help us? ",
							"code": "export function output() {\n\treturn first ? nextout : (first = firstout());\n}\n"
						},
						{
							"line": 22,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "root",
									"text": "- The root element"
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "guid",
									"text": "- The root guid"
								},
								{
									"name": "@param",
									"type": "{Out}",
									"desc": "newout",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Out|null}",
									"desc": "[oldout]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<function>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export function diff(root, guid, newout, oldout) {\n\treturn getdiffs(root, guid, newout, oldout || new Out());\n}\n"
						},
						{
							"line": 32,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "root",
									"text": "The root element"
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "guid",
									"text": "The root guid"
								},
								{
									"name": "@param",
									"type": "{Array<function>}",
									"desc": "diffs",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Map<string,Function>}",
									"desc": "calls",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: Advanced render summary goes here! ",
							"code": "export function patch(root, guid, diffs, calls) {\n\treturn patchdiffs(root, guid, diffs, calls);\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 44,
							"tags": [
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "[defer]",
									"text": "- collecting callbacks for `on:click` type events."
								},
								{
									"name": "@returns",
									"type": "{Function}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Creates the entry point `out` to be used via some tagged template string. ",
							"code": "function firstout(defer) {\n\tlet markup = '';\n\tlet unsafe = [];\n\tlet others = [];\n\tlet defers = new Map();\n\tlet bypass = new Set();\n\tfunction out(arg, ...args) {\n\t\tif (arguments.length) {\n\t\t\tmarkup += replace(arg, args, unsafe, others, bypass);\n\t\t\tbypass.clear();\n\t\t} else {\n\t\t\treturn finalize(markup, unsafe, others, defers);\n\t\t}\n\t}\n\treturn proxy(out, {\n\t\tdefer: defer,\n\t\tblargh: dec => {\n\t\t\tbypass.add(dec);\n\t\t\treturn dec;\n\t\t},\n\t\tguargh: val => {\n\t\t\tunsafe.push(val);\n\t\t\treturn fixvalue(val, unsafe, others);\n\t\t},\n\t\tarrghs: fun => {\n\t\t\tconst key = `cb${generatekey()}`;\n\t\t\tdefers.set(key, fun);\n\t\t\treturn key;\n\t\t}\n\t});\n}\n"
						},
						{
							"line": 80,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "arg",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{...string}",
									"desc": "args",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Nested `out` will simply delegate to the entry point `out` except nothing will happen when called without arguments. ",
							"code": "const nextout = (function(out) {\n\treturn proxy(out, {\n\t\tblargh: dec => (first ? first.blargh(dec) : ''),\n\t\tguargh: val => (first ? first.guargh(val) : ''),\n\t\tarrghs: fun => (first ? first.arrghs(fun) : '')\n\t});\n})(function out(arg, ...args) {\n\tif (arguments.length) {\n\t\tfirst(...arguments);\n\t} else {\n\t\treturn '';\n\t}\n});\n"
						},
						{
							"line": 100,
							"tags": [
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "out",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "expandos",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Proxy}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function proxy(out, expandos) {\n\treturn new Proxy(Object.assign(out, expandos), Out);\n}\n"
						},
						{
							"line": 108,
							"tags": [
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "[defer]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Function}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Passing the list of callbacks on to nested `out`. TODO: This would make it possible to change them! TODO: Could these be internalized in the {Out} ? ",
							"code": "function passtonext(defer) {\n\tnextout.defer = first.defer;\n\treturn nextout;\n}\n"
						},
						{
							"line": 119,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "[fix]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Generate random key for historic reasons. TODO: Attempt to simply increment counter. ",
							"code": "function generatekey(fix = 'cb') {\n\treturn String(Math.random()).slice(2, 11);\n}\n"
						},
						{
							"line": 128,
							"tags": [
								{
									"name": "@throws",
									"type": "{Error}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "The `defer` method is used for collecting callbacks for `on:click` statements and stuff like that. The `ScriptPlugin` will usually set this up automatically, but this plugin is not involved whenever the EDBML function is called directly by the developer and so we will throw an exception if it is not implemented. Note that this is only relevant if the function outputs inline event handlers. ",
							"code": "function nodefer() {\n\tthrow new Error(\n\t\t`In order to support deferred callbakcs, the EDBML function \n\t\tmust be stamped with a method \"defer()\" before it is called.`\n\t);\n}\n"
						},
						{
							"line": 142,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Array<string>}",
									"desc": "strings",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<string>}",
									"desc": "values",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<string>}",
									"desc": "unsafe",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<Node>}",
									"desc": "others",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Set<String>}",
									"desc": "bypass",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "If `out` is used as a tagged template, we replace all these `${strings}` with an intermediary value that can be evaluated for XSS safety later on. If `oout` is called directly, we bypass this step and output the argument. IDEA: ENABLE AND DISABLE `$att` PROXY STUFF WITHIN THIS METHOD (?) ",
							"code": "function replace(strings, values, unsafe, others, bypass) {\n\treturn Array.isArray(strings) && strings.raw\n\t\t? strings.raw.reduce((result, string, i) => {\n\t\t\t\treturn result + string + johnson(values[i], unsafe, others, bypass);\n\t\t  }, '')\n\t\t: String(strings);\n}\n"
						},
						{
							"line": 161,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "value",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<string>}",
									"desc": "unsafe",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<Node>}",
									"desc": "others",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Set<String>}",
									"desc": "bypass",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function johnson(value, unsafe, others, bypass) {\n\treturn bypass.has(value) && value.includes('=')\n\t\t? value\n\t\t: fixvalue(value, unsafe, others);\n}\n"
						},
						{
							"line": 173,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "markup",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array}",
									"desc": "unsafe",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array}",
									"desc": "others",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Map<string,Function>}",
									"desc": "defers",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Out}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Finally reset and return an {Out} which can be converted to HTML or DOM. ",
							"code": "function finalize(markup, unsafe, others, defers) {\n\tfirst = null;\n\tnextout.defer = null;\n\treturn new Out(markup, unsafe, others, defers);\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/gui-plugins/src/SpiritPlugin.js": {
			"title": "SpiritPlugin",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { Plugin as BasePlugin } from '@dataplastique/edb';\nimport { plugin as baseplugin } from '@dataplastique/edb';\nimport { Spirit } from '@dataplastique/gui';\n"
						},
						{
							"line": 3,
							"tags": [],
							"tabs": "\t",
							"desc": "\n\n",
							"code": "export default class SpiritPlugin extends BasePlugin {\n"
						},
						{
							"line": 7,
							"tags": [
								{
									"name": "@type",
									"type": "{String}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Identification. ",
							"code": "\tget [Symbol.toStringTag]() {\n\t\treturn `[plugin ${this.constructor.name}]`;\n\t}\n"
						},
						{
							"line": 14,
							"tags": [
								{
									"name": "@type",
									"type": "{Spirit}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\tget spirit() {\n\t\treturn this.host;\n\t}\n"
						},
						{
							"line": 20,
							"tags": [
								{
									"name": "@type",
									"type": "{Element}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\tget element() {\n\t\treturn this.host.element;\n\t}\n"
						},
						{
							"line": 26,
							"tags": [
								{
									"name": "@returns",
									"type": "{Spirit}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Plugin will accept any Spirit host (at least by default). TODO: Allow multiple? ",
							"code": "\tstatic host() {\n\t\treturn Spirit;\n\t}\n}\n"
						},
						{
							"line": 35,
							"tags": [
								{
									"name": "@returns",
									"type": "{Function}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export function plugin() {\n\treturn baseplugin(...arguments);\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/gui-plugins/src/TrackerPlugin.js": {
			"title": "TrackerPlugin",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import SpiritPlugin from './SpiritPlugin';\nimport { Mapping } from '@dataplastique/util';\nimport { chained } from '@dataplastique/util';\n"
						},
						{
							"line": 3,
							"tags": [],
							"tabs": "\t",
							"desc": "TODO: Move this thing over to `@dataplastique/util/Immutable` (IMapping?) Plugin that needs to keep track of things, let's say the arguments for \n`addEventListener`, so that the listener is never registered twice with the same arguments and can be cleanup up for garbage collection later on. ",
							"code": "export default class TrackerPlugin extends SpiritPlugin {\n"
						},
						{
							"line": 10,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "type",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Add handler for type of event. The subclass will implement this. ",
							"code": "\ton(type) {\n\t\timplementationError(this);\n\t}\n"
						},
						{
							"line": 18,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "type",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Remove handler for type of event. The subclass will implement this. ",
							"code": "\toff(type) {\n\t\timplementationError(this);\n\t}\n"
						},
						{
							"line": 26,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "type",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Remove handler for type of event whenever the event is registered. The subclass will implement this. ",
							"code": "\tone(type) {\n\t\timplementationError(this);\n\t}\n"
						},
						{
							"line": 35,
							"tags": [
								{
									"name": "@param",
									"type": "{truthy|falsy}",
									"desc": "on",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string|Array<string>}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{BroadcastHandler}",
									"desc": "[handler]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{this}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Add or remove handlers based on truthy first param. ",
							"code": "\t@chained\n\tshift(on, ...rest) {\n\t\t!!on ? this.on(...rest) : this.off(...rest);\n\t}\n"
						},
						{
							"line": 46,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "TODO: Replace with `has`. Has (handler for) type? ",
							"code": "\tcontains(type) {\n\t\treturn this._checklist.has(type);\n\t}\n"
						},
						{
							"line": 55,
							"tags": [
								{
									"name": "@deprecated",
									"type": "",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\tadd() {\n\t\tthrow new Error('Deprecated API is deprecated');\n\t}\n"
						},
						{
							"line": 61,
							"tags": [
								{
									"name": "@deprecated",
									"type": "",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\tremove() {\n\t\tthrow new Error('Deprecated API is deprecated');\n\t}\n"
						}
					]
				},
				{
					"title": "Privileged ",
					"tabs": "\t",
					"sections": [
						{
							"line": 68,
							"tags": [
								{
									"name": "@param",
									"type": "{Spirit}",
									"desc": "spirit",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Create the checklist (in real constructor because unittest). The global flag is relevant for some subclasses around here. ",
							"code": "\tconstructor(spirit) {\n\t\tsuper(spirit);\n\t\tthis._checklist = new Mapping();\n\t\tthis._global = false;\n\t}\n"
						},
						{
							"line": 78,
							"tags": [],
							"tabs": "\t",
							"desc": "Deconstruct. ",
							"code": "\tondestruct() {\n\t\tlet checklist = this._checklist;\n\t\tif (checklist) {\n\t\t\tif (checklist.size) {\n\t\t\t\tchecklist.forAll((key, checks) => {\n\t\t\t\t\tthis._cleanupchecks(key, checks);\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.log(\n\t\t\t\tthis.constructor.name,\n\t\t\t\tthis.spirit.toString(),\n\t\t\t\t'no checklist :/'\n\t\t\t);\n\t\t}\n\t\tthis._checklist = null;\n\t\tsuper.ondestruct();\n\t}\n"
						}
					]
				},
				{
					"title": "Private ",
					"tabs": "\t",
					"sections": [
						{
							"line": 100,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<object>}",
									"desc": "checks",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": "- Was added?"
								}
							],
							"tabs": "\t",
							"desc": "Can add checks for type? If so, do it now. ",
							"code": "\t_addchecks(type, checks) {\n\t\tconst list = this._checklist;\n\t\tif (true) {\n\t\t\tconsole.warn('TODO! Use immutable stuff');\n\t\t\tlist.add(type, checks);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n"
						},
						{
							"line": 115,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<object>}",
									"desc": "checks",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": "- Was removed?"
								}
							],
							"tabs": "\t",
							"desc": "Can remove checks for type? If so, do it now. ",
							"code": "\t_removechecks(type, checks) {\n\t\tconst list = this._checklist;\n\t\tif ((checks = list.getSimilar(type, checks))) {\n\t\t\tlist.remove(type, checks);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n"
						},
						{
							"line": 129,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<object>}",
									"desc": "checks",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Subclass could implement: This gets called upon disposal so that we can remove all event listeners and what not. ",
							"code": "\t_cleanupchecks(type, checks) {}\n"
						},
						{
							"line": 136,
							"tags": [
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "operation",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Execute operation in global mode. Note that sometimes it's still recommended to flip the '_global' flag back to `false` in order to avoid the global mode leaking the into repeated (nested) calls. ",
							"code": "\t_globalize(operation) {\n\t\tthis._global = true;\n\t\tlet res = operation.call(this);\n\t\tthis._global = false;\n\t\treturn res;\n\t}\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 151,
							"tags": [
								{
									"name": "@param",
									"type": "{Plugin}",
									"desc": "plugin",
									"text": ""
								},
								{
									"name": "@throws",
									"type": "{Error}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "A required method was not defined in the subclass. TODO: Create some kind of ES7 decorator for this. ",
							"code": "function implementationError(plugin) {\n\tthrow new Error(`${plugin} expected an implementation`);\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/gui-plugins/src/att/AttPlugin.js": {
			"title": "AttPlugin",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import SpiritPlugin from '../SpiritPlugin';\nimport { cast, chained } from '@dataplastique/util';\n"
						},
						{
							"line": 2,
							"tags": [],
							"tabs": "",
							"desc": "TODO: How to bypass potential type system when assigning this to spirit? ",
							"code": "const symbol = Symbol.for('@dataplastique/attributes');\n"
						},
						{
							"line": 6,
							"tags": [],
							"tabs": "\t",
							"desc": "Managing the spirits (element) attributes. ",
							"code": "export default class AttPlugin extends SpiritPlugin {\n"
						},
						{
							"line": 10,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{*}",
									"desc": "value",
									"text": "- Use `null` to delete the attribute"
								},
								{
									"name": "@returns",
									"type": "{this}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Set attribute value (always as a string). TODO: Support a hashmap (object) to set multiple attributes. ",
							"code": "\t@chained\n\tset(name, value) {\n\t\tvalue === null\n\t\t\t? this.delete(name)\n\t\t\t: this.element.setAttribute(name, String(value));\n\t}\n"
						},
						{
							"line": 23,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string|number|boolean|null}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Get attribute value as an inferred primitive type. TODO: support an array of names to return a hashmap (object). TODO: support *no* argument to return all the attributes (object). ",
							"code": "\tget(name) {\n\t\treturn cast(this.element.getAttribute(name));\n\t}\n"
						},
						{
							"line": 33,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Has attribute(s) name declared? TODO: Support a list of names to check for multiple attributes. ",
							"code": "\thas(name) {\n\t\treturn this.element.hasAttribute(name);\n\t}\n"
						},
						{
							"line": 42,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{this}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Delete attribute. ",
							"code": "\t@chained\n\tdelete(name) {\n\t\tthis.element.removeAttribute(name);\n\t}\n"
						},
						{
							"line": 51,
							"tags": [
								{
									"name": "@alias",
									"type": "{delete}",
									"desc": "",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{this}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Delete attribute (via short method name). ",
							"code": "\t@chained\n\tdel(name) {\n\t\tthis.delete(name);\n\t}\n"
						},
						{
							"line": 61,
							"tags": [
								{
									"name": "@param",
									"type": "{truthy}",
									"desc": "truthy",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{*}",
									"desc": "[value]",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Set or remove attribute depending on the first argument. ",
							"code": "\tshift(truthy, name, value = name) {\n\t\t!!truthy ? this.set(name, value) : this.delete(name);\n\t}\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/gui-plugins/src/broadcast/Broadcast.js": {
			"title": "Broadcast",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import {\n\tMapping,\n\tisComplex,\n\tisFunction,\n\tasarray,\n\tchained\n} from '@dataplastique/util';\n"
						},
						{
							"line": 7,
							"tags": [],
							"tabs": "\t",
							"desc": "Broadcast. TODO: Rename `add/remove` `on/off` TODO: Move to `dataplastique-util` project (sans global stuff) TODO: Support array arguments (batched broadcasts). TODO: Pool broadcasts. ",
							"code": "export default class Broadcast {\n"
						},
						{
							"line": 15,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "[data]",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{boolean}",
									"desc": "[isglobal]",
									"text": ""
								}
							],
							"tabs": "\t\t",
							"desc": "Use static methods `dispatch` and `dispatchGlobal` to create broadcasts. ",
							"code": "\tconstructor(type, data = null, isglobal = false) {\n"
						},
						{
							"line": 22,
							"tags": [
								{
									"name": "@type",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t\t",
							"desc": "Broadcast type. ",
							"code": "\t\tthis.type = type;\n"
						},
						{
							"line": 27,
							"tags": [
								{
									"name": "@type",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t\t",
							"desc": "Broadcast data. ",
							"code": "\t\tthis.data = data;\n"
						},
						{
							"line": 32,
							"tags": [
								{
									"name": "@type",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Global broadcast? ",
							"code": "\t\tthis.global = isglobal;\n\t}\n"
						},
						{
							"line": 38,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Array<string>}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{object|constructor}",
									"desc": "handler",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Constructor}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Subscribe handler to type. ",
							"code": "\t@chained\n\tstatic add(type, handler) {\n\t\tadd(type, handler);\n\t}\n"
						},
						{
							"line": 48,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Array<string>}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{object|constructor}",
									"desc": "handler",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Constructor}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Unsubscribe handler from broadcast. ",
							"code": "\t@chained\n\tstatic remove(type, handler) {\n\t\tremove(type, handler);\n\t}\n"
						},
						{
							"line": 58,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Array<string>}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{object|constructor}",
									"desc": "handler",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Constructor}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Subscribe handler to type globally. ",
							"code": "\t@chained\n\tstatic addGlobal(type, handler) {\n\t\tadd(type, handler, true);\n\t}\n"
						},
						{
							"line": 68,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Array<string>}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{object|constructor}",
									"desc": "handler",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Constructor}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Unsubscribe handler from global broadcast. ",
							"code": "\t@chained\n\tstatic removeGlobal(type, handler) {\n\t\tremove(type, handler, true);\n\t}\n"
						},
						{
							"line": 78,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "data",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Publish broadcast in local scope (this window). TODO: queue for incoming dispatch (finish current type first). ",
							"code": "\t@chained\n\tstatic dispatch(type, data) {\n\t\tdispatch(type, data, false);\n\t}\n"
						},
						{
							"line": 88,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "data",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{gui.Broadcast}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Dispatch broadcast in global scope (all windows). TODO: queue for incoming dispatch (finish current first). TODO: Handle remote domain iframes ;) ",
							"code": "\t@chained\n\tstatic dispatchGlobal(type, data) {\n\t\tdispatch(type, data, true);\n\t}\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 101,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "const PREFIX = '@dataplastique/broadcast:';\nconst LOCALS = new Mapping();\nconst GLOBALS = new Mapping();\n"
						},
						{
							"line": 105,
							"tags": [
								{
									"name": "@param",
									"type": "{Array<string>|string}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{IBroadcastHandler}",
									"desc": "handler",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{boolan}",
									"desc": "isglobal",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Subscribe handler to type(s). confirmed('array|string', 'object|function') ",
							"code": "function add(type, handler, isglobal) {\n\tlet handlers = isglobal ? GLOBALS : LOCALS;\n\tasarray(type, t => handlers.add(t, handler));\n}\n"
						},
						{
							"line": 116,
							"tags": [
								{
									"name": "@param",
									"type": "{Array<string>|string}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{IBroadcastHandler}",
									"desc": "handler",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{boolan}",
									"desc": "isglobal",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function remove(type, handler, isglobal) {\n\tlet handlers = isglobal ? GLOBALS : LOCALS;\n\tasarray(type, t => handlers.remove(t, handler));\n}\n"
						},
						{
							"line": 125,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Array<string>}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{*}",
									"desc": "data",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{boolan}",
									"desc": "isglobal",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Dispatch broadcast. TODO: cache broadcasts while booting and redispatch on bootstrap done. ",
							"code": "function dispatch(type, data, isglobal) {\n\tasarray(type, t => {\n\t\tlet b = new Broadcast(t, data, isglobal);\n\t\tlet handlers = isglobal ? GLOBALS : LOCALS;\n\t\tif (handlers.has(t)) {\n\t\t\thandlers.toArray(t).forEach(handler => {\n\t\t\t\thandler.onbroadcast(b);\n\t\t\t});\n\t\t}\n\t\tif (isglobal) {\n\t\t\tpropagate(b);\n\t\t}\n\t});\n}\n"
						},
						{
							"line": 146,
							"tags": [
								{
									"name": "@param",
									"type": "{Broadcast}",
									"desc": "b",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function propagate(b) {\n}\n"
						},
						{
							"line": 151,
							"tags": [
								{
									"name": "@param",
									"type": "{Broacast}",
									"desc": "b",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Encode broadcast to be posted xdomain. TODO: IE9 is gone, so we can post non-string stuff nowadays ",
							"code": "function stringify(b) {\n\treturn (\n\t\tPREFIX +\n\t\t(function() {\n\t\t\tb.data = (function(d) {\n\t\t\t\tif (isComplex(d)) {\n\t\t\t\t\tif (isFunction(d.stringify)) {\n\t\t\t\t\t\td = d.stringify();\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tJSON.stringify(d);\n\t\t\t\t\t\t} catch (jsonexception) {\n\t\t\t\t\t\t\td = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn d;\n\t\t\t})(b.data);\n\t\t\treturn JSON.stringify(b);\n\t\t})()\n\t);\n}\n"
						},
						{
							"line": 179,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "msg",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Decode broadcast posted from xdomain and return a broadcast-like object. ",
							"code": "function parse(msg) {\n\tif (msg.startsWith(PREFIX)) {\n\t\treturn JSON.parse(msg.split(PREFIX)[1]);\n\t}\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/gui-plugins/src/broadcast/BroadcastPlugin.js": {
			"title": "BroadcastPlugin",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import TrackerPlugin from '../TrackerPlugin';\nimport Broadcast from './Broadcast';\nimport { chained, asarray } from '@dataplastique/util';\n"
						},
						{
							"line": 3,
							"tags": [],
							"tabs": "\t",
							"desc": "Tracking and dispatching broadcasts. ",
							"code": "export default class BroadcastPlugin extends TrackerPlugin {\n"
						},
						{
							"line": 7,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Array<string>}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{BroadcastHandler}",
									"desc": "[handler]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{BroadcastPlugin}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Add one or more broadcast handlers. ",
							"code": "\t@chained\n\ton(type, handler = this.spirit) {\n\t\tasarray(type, t => {\n\t\t\tif (this._addchecks(t, [handler, this._global])) {\n\t\t\t\tif (this._global) {\n\t\t\t\t\tBroadcast.addGlobal(t, handler);\n\t\t\t\t} else {\n\t\t\t\t\tBroadcast.add(t, handler);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n"
						},
						{
							"line": 25,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Array<string>}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{BroadcastHandler}",
									"desc": "[handler]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{BroadcastPlugin}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Remove one or more broadcast handlers. ",
							"code": "\t@chained\n\toff(type, handler = this.spirit) {\n\t\tasarray(type, t => {\n\t\t\tif (this._addchecks(t, [handler, this._global])) {\n\t\t\t\tif (this._global) {\n\t\t\t\t\tBroadcast.addGlobal(t, handler);\n\t\t\t\t} else {\n\t\t\t\t\tBroadcast.add(t, handler);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n"
						},
						{
							"line": 43,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Array<string>}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "[data]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{BroadcastPlugin}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Dispatch type(s). ",
							"code": "\t@chained\n\tdispatch(type, data) {\n\t\tlet global = this._global;\n\t\tthis._global = false;\n\t\tasarray(type, t => {\n\t\t\tif (global) {\n\t\t\t\tBroadcast.dispatchGlobal(t, data);\n\t\t\t} else {\n\t\t\t\tBroadcast.dispatch(t, data);\n\t\t\t}\n\t\t});\n\t}\n"
						},
						{
							"line": 61,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Array<string>}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{BroadcastHandler}",
									"desc": "[handler]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{BroadcastPlugin}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Add one or more global broadcast handlers. ",
							"code": "\t@chained\n\tonGlobal(type, handler) {\n\t\tthis._globalize(() => this.on(type, handler));\n\t}\n"
						},
						{
							"line": 71,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Array<string>}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{BroadcastHandler}",
									"desc": "[handler]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{BroadcastPlugin}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Rempve one or more broadcast handlers. ",
							"code": "\t@chained\n\toffGlobal(type, handler) {\n\t\tthis._globalize(() => this.off(type, handler));\n\t} \n"
						},
						{
							"line": 81,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Array<string>}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{BroadcastHandler}",
									"desc": "[handler]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{BroadcastPlugin}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Shift one or more global broadcast handlers based on truthy first param. ",
							"code": "\t@chained\n\tshiftGlobal(on, type, handler) {\n\t\tthis._globalize(() => this.shift(on, type, handler));\n\t}\n"
						},
						{
							"line": 91,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Array<string>}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "[data]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{gui.Broadcast}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Dispatch on or more broadcasts globally. ",
							"code": "\t@chained\n\tdispatchGlobal(type, data) {\n\t\tthis._globalize(() => this.dispatch(type, data));\n\t}\n"
						}
					]
				},
				{
					"title": "Private ",
					"tabs": "\t",
					"sections": [
						{
							"line": 102,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<object>}",
									"desc": "checks",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Remove broadcast handlers when the plugin destructs. ",
							"code": "\t_cleanupchecks(type, checks) {\n\t\tlet handler = checks[0];\n\t\tlet isglobal = checks[1];\n\t\tif (isglobal) {\n\t\t\tBroadcast.removeGlobal(type, handler);\n\t\t} else {\n\t\t\tBroadcast.remove(type, handler);\n\t\t}\n\t}\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/gui-plugins/src/css/CSSPlugin.js": {
			"title": "CSSPlugin",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import SpiritPlugin from '../SpiritPlugin';\nimport { Spirit } from '@dataplastique/gui';\nimport { chained } from '@dataplastique/util';\nimport { asarray } from '@dataplastique/util';\nimport { Environment } from '@dataplastique/util';\nconst COMMA = ',';\nconst FLOAT = 'float';\nconst BEFIX = '-beta-';\nconst AGENT = ['', '-webkit-', '-moz-', '-ms-'];\nconst DOCEL = Environment.browser ? document.documentElement : null;\nconst MATCH = Environment.browser ? matchmethod(DOCEL) : null;\n"
						},
						{
							"line": 11,
							"tags": [
								{
									"name": "@type",
									"type": "{Set<string>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Until we figure out something better, we'll manually track props that can or must be assigned as simple numbers (without a unit). Props not in this list will be suffixed with `px` when assigned as numbers via `this.css.xxxname`. TODO: Read all the specs and add more properties :/ ",
							"code": "const numbers = new Set(['fontWeight', 'opacity', 'zIndex']);\n"
						},
						{
							"line": 19,
							"tags": [],
							"tabs": "\t",
							"desc": "Working with CSS. ",
							"code": "export default class CSSPlugin extends SpiritPlugin {\n"
						},
						{
							"line": 23,
							"tags": [
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Hm. We don't need to \"observe\" this, we just need the proxy setter... ",
							"code": "\t$observable() {\n\t\treturn true;\n\t}\n"
						},
						{
							"line": 30,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string|number}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "This is the \"universal getter\" method. Whenever the Proxy cannot find a looked-up property, and if this method is declared, it will expose the property value via this methods return value. ",
							"code": "\tuniget(name) {\n\t\tif (name in this.element.style) {\n\t\t\tconst val = this.get(name);\n\t\t\tconst num = parseInt(val, 10);\n\t\t\treturn isNaN(num) ? val : num;\n\t\t}\n\t}\n"
						},
						{
							"line": 44,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{*}",
									"desc": "value",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{truthy}",
									"desc": "",
									"text": "- The property was handled here?"
								}
							],
							"tabs": "\t",
							"desc": "This is the \"universal setter\" method. When declared, the Proxy will call this method before (and not after!) it attempts to set the property. Return `true` to *not* assign the JS property. TODO: Should most likely return `false` to abort the JS setter :/ ",
							"code": "\tuniset(name, value) {\n\t\tif (name in this.element.style) {\n\t\t\tthis.set(name, value);\n\t\t\treturn true;\n\t\t}\n\t}\n"
						},
						{
							"line": 59,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Array<string>}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{CSSPlugin}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Add classname(s). confirmed('string|array') ",
							"code": "\t@chained\n\tadd(name) {\n\t\tasarray(name, n => CSSPlugin.add(this.element, n));\n\t}\n"
						},
						{
							"line": 69,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{CSSPlugin}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Remove classname(s). confirmed('string|array') ",
							"code": "\t@chained\n\tdelete(name) {\n\t\tasarray(name, n => CSSPlugin.delete(this.element, n));\n\t}\n"
						},
						{
							"line": 79,
							"tags": [
								{
									"name": "@param",
									"type": "{truthy|falsy}",
									"desc": "on",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{CSSPlugin}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Add or remove classname(s) according to truthy first param. confirmed('*', 'string|array') ",
							"code": "\t@chained\n\tshift(on, name) {\n\t\tasarray(name, n => CSSPlugin.shift(this.element, !!on, n));\n\t}\n"
						},
						{
							"line": 90,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Contains classname? confirmed('string') ",
							"code": "\thas(name) {\n\t\treturn CSSPlugin.has(this.element, name);\n\t}\n"
						},
						{
							"line": 99,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "prop",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "val",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{CSSPlugin}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Set single element.style. ",
							"code": "\t@chained\n\tset(prop, val) {\n\t\tCSSPlugin.set(this.element, prop, val);\n\t}\n"
						},
						{
							"line": 109,
							"tags": [
								{
									"name": "@param",
									"type": "{Object<string,string>}",
									"desc": "map",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{CSSPlugin}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Set multiple styles via key value map (object). ",
							"code": "\t@chained\n\tstyle(map) {\n\t\tCSSPlugin.style(this.element, map);\n\t}\n"
						},
						{
							"line": 118,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "prop",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Get single element.style (see also `compute` method). ",
							"code": "\tget(prop) {\n\t\treturn CSSPlugin.get(this.element, prop);\n\t}\n"
						},
						{
							"line": 126,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "prop",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Compute runtime style. ",
							"code": "\tcompute(prop) {\n\t\treturn CSSPlugin.compute(this.element, prop);\n\t}\n"
						},
						{
							"line": 134,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "[name]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string|CSSPlugin}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Get or set (full) className. ",
							"code": "\t@chained\n\tname(n) {\n\t\tif (arguments.length) {\n\t\t\tthis.element.className = n;\n\t\t} else {\n\t\t\treturn this.element.className;\n\t\t}\n\t}\n"
						},
						{
							"line": 147,
							"tags": [
								{
									"name": "@TODO:",
									"type": "movetoDOMPlugin!",
									"desc": "",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "selector",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Spirit element mathes selector? ",
							"code": "\tmatches(selector) {\n\t\treturn CSSPlugin.matches(this.element, selector);\n\t}\n"
						},
						{
							"line": 156,
							"tags": [
								{
									"name": "@deprecated",
									"type": "",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\tremove() {\n\t\tthrow new Error('Deprecated API is deprecated');\n\t}\n"
						},
						{
							"line": 162,
							"tags": [
								{
									"name": "@deprecated",
									"type": "",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\tcontains() {\n\t\tthrow new Error('Deprecated API is deprecated');\n\t}\n"
						}
					]
				},
				{
					"title": "Static ",
					"tabs": "\t",
					"sections": [
						{
							"line": 169,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "element",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "names",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{constructor}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "classList.add() ",
							"code": "\t@chained\n\tstatic add(element, name = '') {\n\t\tasarray(name, n => element.classList.add(n));\n\t}\n"
						},
						{
							"line": 179,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "element",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{constructor}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "classList.remove() ",
							"code": "\t@chained\n\tstatic delete(element, name = '') {\n\t\tasarray(name, n => element.classList.remove(n));\n\t}\n"
						},
						{
							"line": 189,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "element",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{truthy|falsy}",
									"desc": "on",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{constructor}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Add or remove classname according to second truthy param. ",
							"code": "\t@chained\n\tstatic shift(element, on, name) {\n\t\tif (!!on) {\n\t\t\tthis.add(element, name);\n\t\t} else {\n\t\t\tthis.delete(element, name);\n\t\t}\n\t}\n"
						},
						{
							"line": 204,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "element",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "classList.contains() ",
							"code": "\tstatic has(element, name) {\n\t\treturn element.classList.contains(name);\n\t}\n"
						},
						{
							"line": 213,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "prop",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Function}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Set single CSS property. Use style() for multiple properties. TODO: also automate shorthands such as '10px 20px 10px 20px' ",
							"code": "\t@chained\n\tstatic set(element, prop, value) {\n\t\tif (!isNaN(value) && !numbers.has(prop)) {\n\t\t\tvalue += 'px';\n\t\t}\n\t\tvalue = String(value);\n\t\tif (prop === FLOAT) {\n\t\t\tprop = 'cssFloat';\n\t\t} else {\n\t\t\tvalue = jsvalue(value);\n\t\t\tprop = jsproperty(prop);\n\t\t}\n\t\telement.style[prop] = value;\n\t}\n"
						},
						{
							"line": 234,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "element",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "prop",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "TODO: Get element.style property; if this has been set. Not to be confused with compute() for computedStyle!!! ",
							"code": "\tstatic get(element, prop) {\n\t\tprop = jsproperty(prop);\n\t\treturn jsvalue(element.style[prop]);\n\t}\n"
						},
						{
							"line": 245,
							"tags": [
								{
									"name": "@param",
									"type": "{Element|Spirit}",
									"desc": "thing",
									"text": "Spirit or element."
								},
								{
									"name": "@param",
									"type": "{Object<string,string>}",
									"desc": "styles",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Element|Spirit}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Set multiple element.style properties via hashmap. Note that this method returns the element (ie. it is not chainable). ",
							"code": "\tstatic style(thing, styles) {\n\t\tconst elm = Spirit.is(thing) ? thing.element : thing;\n\t\tObject.entries(styles).forEach(entry => {\n\t\t\tthis.set(elm, entry[0], entry[1]);\n\t\t});\n\t\treturn thing;\n\t}\n"
						},
						{
							"line": 259,
							"tags": [
								{
									"name": "@param",
									"type": "{Element|Spirit}",
									"desc": "thing",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "prop",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Compute runtime style. ",
							"code": "\tstatic compute(thing, prop) {\n\t\tconst elm = Spirit.is(thing) ? thing.element : thing;\n\t\tprop = standardcase(jsproperty(prop));\n\t\treturn getComputedStyle(elm, null).getPropertyValue(prop);\n\t}\n"
						},
						{
							"line": 270,
							"tags": [
								{
									"name": "@param",
									"type": "{Node}",
									"desc": "node",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "selector",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Node matches CSS selector? TODO: Something about try-catch not being JIT compatible? ",
							"code": "\tstatic matches(node, selector) {\n\t\treturn node[MATCH](selector);\n\t}\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 282,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "string",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "CamelCase string. ",
							"code": "function camelcase(string) {\n\treturn string.replace(/-([a-z])/gi, function(all, letter) {\n\t\treturn letter.toUpperCase();\n\t});\n}\n"
						},
						{
							"line": 292,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "string",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "This will standard-css-notate CamelCased string. ",
							"code": "function standardcase(string) {\n\treturn string.replace(/[A-Z]/g, function(all, letter) {\n\t\treturn '-' + string.charAt(letter).toLowerCase();\n\t});\n}\n"
						},
						{
							"line": 302,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "prop",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Normalize declaration property for use in element.style scenario. TODO: Should be possible to skip this vendor prefixing nowadays? ",
							"code": "function jsproperty(prop) {\n\tlet test;\n\tlet fixt = prop;\n\tif ((prop = String(prop)).startsWith(BEFIX)) {\n\t\tAGENT.every(vendor => {\n\t\t\ttest = camelcase(prop.replace(BEFIX, vendor));\n\t\t\tif (DOCEL.style[test] !== undefined) {\n\t\t\t\tfixt = test;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t} else {\n\t\tfixt = camelcase(fixt);\n\t}\n\treturn fixt;\n}\n"
						},
						{
							"line": 325,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "value",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Normalize declaration value for use in element.style scenario. TODO: clean this up some day. ",
							"code": "function jsvalue(value) {\n\tlet test;\n\tif ((value = String(value)) && value.includes(BEFIX)) {\n\t\tlet parts = [];\n\t\tvalue.split(COMMA).forEach(part => {\n\t\t\tif ((part = part.trim()).startsWith(BEFIX)) {\n\t\t\t\tAGENT.every(vendor => {\n\t\t\t\t\ttest = camelcase(part.replace(BEFIX, vendor));\n\t\t\t\t\tif (DOCEL.style[test] !== undefined) {\n\t\t\t\t\t\tparts.push(part.replace(BEFIX, vendor));\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tparts.push(part);\n\t\t\t}\n\t\t});\n\t\tvalue = parts.join(COMMA);\n\t}\n\treturn value;\n}\n"
						},
						{
							"line": 353,
							"tags": [
								{
									"name": "@param",
									"type": "{HTMLHtmlElement}",
									"desc": "root",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Determine the vendor-prefixed `matchesSelector` method. ",
							"code": "function matchmethod(root) {\n\treturn [\n\t\t'matchesSelector',\n\t\t'msMatchesSelector',\n\t\t'mozMatchesSelector',\n\t\t'webkitMatchesSelector'\n\t].reduce((result, method) => {\n\t\treturn result || (root[method] ? method : null);\n\t}, null);\n}\n"
						}
					]
				},
				{
					"title": "Backup ",
					"tabs": "",
					"sections": [
						{
							"line": 369,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "prop",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "prop",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Normalize declaration property for use in CSS text. \n\nfunction cssproperty(prop) { \n\treturn standardcase(jsproperty(prop)); \n} \n/** Normalize declaration value for use in CSS text. \n\nfunction cssvalue(value) { \n\treturn standardcase(jsvalue(value)); \n} ",
							"code": ""
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/gui-plugins/src/dom/Crawler.js": {
			"title": "Crawler",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { Spirit } from '@dataplastique/gui';\nimport { isFunction } from '@dataplastique/util';\nconst ASCENDING = 'ascending';\nconst DESCENDING = 'descending';\nconst CONTINUE = 0;\nconst STOP = 1;\nconst SKIP = 2;\nconst SKIP_CHILDREN = 4;\n"
						},
						{
							"line": 8,
							"tags": [],
							"tabs": "\t",
							"desc": "Crawling up and down the DOM. TODO: Support SKIP directive. TODO: method `descendBelow` and 'ascendAbove' to skip start element ",
							"code": "export default class Crawler {\n"
						},
						{
							"line": 14,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "type",
									"text": "Identifies the crawler"
								}
							],
							"tabs": "\t",
							"desc": "Constructor. ",
							"code": "\tconstructor(type) {\n\t\tthis.type = type || null;\n\t\tthis.direction = null;\n\t\tthis.global = false;\n\t\tthis._stopped = false;\n\t}\n"
						},
						{
							"line": 24,
							"tags": [
								{
									"name": "@param",
									"type": "{Spirit|Node}",
									"desc": "start",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{CrawlerClient}",
									"desc": "client",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Crawl DOM ascending. ",
							"code": "\tascend(start, client) {\n\t\tthis._stopped = false;\n\t\tthis.direction = ASCENDING;\n\t\tlet onelm = Type.isFunction(client.onelement);\n\t\tlet onspi = Type.isFunction(client.onspirit);\n\t\tlet elm = Spirit.is(start) ? start.element : start;\n\t\tcrawlascending(this, elm, client, onelm, onspi);\n\t}\n"
						},
						{
							"line": 37,
							"tags": [
								{
									"name": "@param",
									"type": "{Spirit|Node}",
									"desc": "start",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{CrawlerClient}",
									"desc": "client",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Crawl DOM ascending, transcend into ancestor frames. ",
							"code": "\tascendGlobal(start, client) {\n\t\tthis.global = true;\n\t\tthis.ascend(start, client);\n\t\tthis.global = false;\n\t}\n"
						},
						{
							"line": 47,
							"tags": [
								{
									"name": "@param",
									"type": "{Spirit|Node}",
									"desc": "start",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{CrawlerClient}",
									"desc": "client",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Crawl DOM descending. ",
							"code": "\tdescend(start, client) {\n\t\tthis._stopped = false;\n\t\tthis.direction = DESCENDING;\n\t\tlet onelm = Type.isFunction(client.onelement);\n\t\tlet onspi = Type.isFunction(client.onspirit);\n\t\tlet elm = Spirit.is(start) ? start.element : start;\n\t\telm = elm.nodeType === Node.DOCUMENT_NODE ? elm.documentElement : elm;\n\t\tcrawldescending(this, elm, client, onelm, onspi, true);\n\t}\n"
						},
						{
							"line": 61,
							"tags": [
								{
									"name": "@param",
									"type": "{Spirit|Node}",
									"desc": "start",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{CrawlerClient}",
									"desc": "client",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Crawl DOM descending, transcend into iframes. ",
							"code": "\tdescendGlobal(start, client) {\n\t\tthis.global = true;\n\t\tthis.descend(start, client);\n\t\tthis.global = false;\n\t}\n}\n"
						},
						{
							"line": 72,
							"tags": [],
							"tabs": "",
							"desc": "Interface constants. TODO: As constants :/ ",
							"code": "Object.assign(Crawler, {\n\tASCENDING: ASCENDING,\n\tDESCENDING: DESCENDING,\n\tCONTINUE: CONTINUE,\n\tSTOP: STOP,\n\tSKIP: SKIP,\n\tSKIP_CHILDREN: SKIP_CHILDREN\n});\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 85,
							"tags": [
								{
									"name": "@param",
									"type": "{Crawler}",
									"desc": "crawler",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{CrawlerClient}",
									"desc": "client",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{boolean}",
									"desc": "onelm",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{boolean}",
									"desc": "onspi",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{boolean}",
									"desc": "[start]",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Iterate nodes descending. ",
							"code": "function crawldescending(crawler, elm, client, onelm, onspi, start) {\n\tlet next;\n\tlet directive = handleElement(crawler, elm, client, onelm, onspi);\n\tswitch (directive) {\n\t\tcase STOP:\n\t\t\tcrawler._stopped = true;\n\t\t\tbreak;\n\t\tcase CONTINUE:\n\t\tcase SKIP_CHILDREN:\n\t\t\tif (directive !== SKIP_CHILDREN) {\n\t\t\t\tif (elm.childElementCount) {\n\t\t\t\t\tcrawldescending(crawler, elm.firstElementChild, client, onelm, onspi);\n\t\t\t\t} else if (crawler.global && elm.localName === 'iframe') {\n\t\t\t\t\tconsole.log('TODO: transcend crawler descending');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!crawler._stopped) {\n\t\t\t\tif (!start && (next = elm.nextElementSibling)) {\n\t\t\t\t\tcrawldescending(crawler, next, client, onelm, onspi);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n}\n"
						},
						{
							"line": 118,
							"tags": [
								{
									"name": "@param",
									"type": "{Crawler}",
									"desc": "crawler",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{CrawlerClient}",
									"desc": "client",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{boolean}",
									"desc": "onelm",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{boolean}",
									"desc": "onspi",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Iterate nodes ascending. ",
							"code": "function crawlascending(crawler, elm, client, onelm, onspi) {\n\tdo {\n\t\tif (elm.nodeType === Node.DOCUMENT_NODE) {\n\t\t\tconsole.log('TODO: transcend crawler ascending');\n\t\t\telm = null;\n\t\t}\n\t\tif (elm) {\n\t\t\tlet directive = handleElement(crawler, elm, client, onelm, onspi);\n\t\t\tswitch (directive) {\n\t\t\t\tcase STOP:\n\t\t\t\t\telm = null;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\telm = elm.parentNode;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (elm);\n}\n"
						},
						{
							"line": 145,
							"tags": [
								{
									"name": "@param",
									"type": "{Crawler}",
									"desc": "crawler",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "element",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{CrawlerClient}",
									"desc": "client",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{boolean}",
									"desc": "onelm",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{boolean}",
									"desc": "onspi",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{number}",
									"desc": "",
									"text": "directive"
								}
							],
							"tabs": "",
							"desc": "Handle element and/or spirit for crawler client. ",
							"code": "function handleElement(crawler, element, client, onelm, onspi) {\n\tlet spirit;\n\tlet directive = CONTINUE;\n\tif (client) {\n\t\tif (onelm) {\n\t\t\tdirective = client.onelement(element);\n\t\t}\n\t\tif (!directive && (spirit = Spirit.get(element))) {\n\t\t\tdirective = spirit.oncrawler(crawler);\n\t\t\tif (!directive && onspi) {\n\t\t\t\tdirective = client.onspirit(spirit);\n\t\t\t}\n\t\t}\n\t}\n\treturn directive || CONTINUE;\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/gui-plugins/src/dom/DOMPlugin.js": {
			"title": "DOMPlugin",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import SpiritPlugin from '../SpiritPlugin';\nimport Crawler from './Crawler';\nimport { Spirit } from '@dataplastique/gui';\nimport { Key } from '@dataplastique/util';\nimport { asarray } from '@dataplastique/util';\nimport { chained } from '@dataplastique/util';\nimport { Environment } from '@dataplastique/util';\nimport { typeOf, isString, isClass } from '@dataplastique/util';\nimport { isDefined, isFunction, isElement } from '@dataplastique/util';\nconst CLASS_HIDDEN = 'gui-hidden';\n"
						},
						{
							"line": 10,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "thing",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Element|Text}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Normalize something to element or textnode. ",
							"code": "const normalize = thing =>\n\tSpirit.is(thing)\n\t\t? thing.element\n\t\t: thing && thing.nodeType\n\t\t\t? thing\n\t\t\t: textual(thing);\n"
						},
						{
							"line": 21,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "thing",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Text}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Anything as textnode. ",
							"code": "const textual = thing => document.createTextNode(String(thing));\n"
						},
						{
							"line": 27,
							"tags": [],
							"tabs": "\t",
							"desc": "DOM query and manipulation. TODO: add `prependTo` method TODO: https://stackoverflow.com/questions/31991235/sort-elements-by-document-order-in-javascript ",
							"code": "export default class DOMPlugin extends SpiritPlugin {\n"
						},
						{
							"line": 33,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "[newid]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string|DOMPlugin}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Set or get element id. ",
							"code": "\t@chained\n\tid(newid) {\n\t\tconst elm = this.element;\n\t\tif (arguments.length) {\n\t\t\telm.id = newid;\n\t\t} else {\n\t\t\treturn elm.id;\n\t\t}\n\t}\n"
						},
						{
							"line": 47,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "[newtitle]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string|DOMPlugin}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Get or set element title (tooltip). ",
							"code": "\t@chained\n\ttitle(newtitle) {\n\t\tconst elm = this.element;\n\t\tif (arguments.length) {\n\t\t\telm.title = newtitle;\n\t\t} else {\n\t\t\treturn elm.title;\n\t\t}\n\t}\n"
						},
						{
							"line": 61,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "[markup]",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "[position]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string|DOMPlugin}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Get or set element markup. ",
							"code": "\t@chained\n\thtml(markup, position) {\n\t\tconst elm = this.element;\n\t\tif (arguments.length) {\n\t\t\tDOMPlugin.html(elm, markup, position);\n\t\t} else {\n\t\t\treturn DOMPlugin.html(elm);\n\t\t}\n\t}\n"
						},
						{
							"line": 76,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "[markup]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string|DOMPlugin}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Get or set element outer markup. ",
							"code": "\t@chained\n\touterHtml(markup) {\n\t\tconst elm = this.element;\n\t\tif (arguments.length) {\n\t\t\tDOMPlugin.outerHtml(elm, markup);\n\t\t} else {\n\t\t\treturn DOMPlugin.outerHtml();\n\t\t}\n\t}\n"
						},
						{
							"line": 90,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "[string]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{String|DOMPlugin}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Get or set element textContent. ",
							"code": "\t@chained\n\ttext(value) {\n\t\tconst elm = this.element;\n\t\tif (arguments.length) {\n\t\t\tDOMPlugin.text(elm, value);\n\t\t} else {\n\t\t\treturn DOMPlugin.text(elm);\n\t\t}\n\t}\n"
						},
						{
							"line": 104,
							"tags": [
								{
									"name": "@returns",
									"type": "{DOMPlugin}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Empty spirit subtree. ",
							"code": "\t@chained\n\tempty() {\n\t\tthis.html('');\n\t}\n"
						},
						{
							"line": 112,
							"tags": [
								{
									"name": "@returns",
									"type": "{DOMPlugin}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Mark spirit invisible. ",
							"code": "\t@chained\n\thide() {\n\t\tthis.spirit.css.add(CLASS_HIDDEN);\n\t}\n"
						},
						{
							"line": 120,
							"tags": [
								{
									"name": "@returns",
									"type": "{DOMPlugin}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Mark spirit visible. ",
							"code": "\t@chained\n\tshow() {\n\t\tthis.spirit.css.remove(CLASS_HIDDEN);\n\t}\n"
						},
						{
							"line": 128,
							"tags": [
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Get spirit element tag. ",
							"code": "\ttag() {\n\t\treturn this.element.localName;\n\t}\n"
						},
						{
							"line": 135,
							"tags": [
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Is positioned in page DOM? Otherwise plausible createElement or documentFragment scenario. ",
							"code": "\tembedded() {\n\t\treturn DOMPlugin.embedded(this.element);\n\t}\n"
						},
						{
							"line": 143,
							"tags": [],
							"tabs": "\t",
							"desc": "Removing this spirit from it's parent container. Note that this will schedule destruction of the spirit unless it gets reinserted somewhere. Also note that this method is called on the spirit, not on the parent. TODO: Investigate support for `element.remove()` nowadays... ",
							"code": "\t@chained\n\tremove() {\n\t\tlet parent = this.element.parentNode;\n\t\tparent.removeChild(this.element);\n\t}\n"
						},
						{
							"line": 154,
							"tags": [
								{
									"name": "@returns",
									"type": "{Element}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Clone spirit element. ",
							"code": "\tclone() {\n\t\treturn this.element.cloneNode(true);\n\t}\n"
						},
						{
							"line": 161,
							"tags": [
								{
									"name": "@returns",
									"type": "{number}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Get ordinal index of element. TODO: Support 'of-same-type' or something ",
							"code": "\tordinal() {\n\t\treturn DOMPlugin.ordinal(this.element);\n\t}\n"
						},
						{
							"line": 169,
							"tags": [
								{
									"name": "@see",
									"type": "http://mdn.io/compareDocumentPosition",
									"desc": "",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Element|Spirit}",
									"desc": "other",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{number}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Compare the DOM position of this spirit against something else. ",
							"code": "\tcompare(other) {\n\t\treturn DOMPlugin.compare(this.element, other);\n\t}\n"
						},
						{
							"line": 178,
							"tags": [
								{
									"name": "@param",
									"type": "{Node|Spirit}",
									"desc": "other",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Contains other node or spirit? ",
							"code": "\tcontains(other) {\n\t\treturn DOMPlugin.contains(this.element, other);\n\t}\n"
						},
						{
							"line": 186,
							"tags": [
								{
									"name": "@param",
									"type": "{Node|Spirit}",
									"desc": "other",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Contained by other node or spirit? ",
							"code": "\tcontainedBy(other) {\n\t\treturn DOMPlugin.contains(other, this.element);\n\t}\n"
						},
						{
							"line": 194,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "id",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Class<Spirit>}",
									"desc": "[type]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Element|Spirit}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\tguid(id, type) {\n\t\tconst rootguid = this.spirit.$id;\n\t\tconst selector = `[data-plastique-id=${rootguid}-${id}]`;\n\t\tconst expanded = arguments.length > 1;\n\t\treturn expanded ? this.q(selector, type) : this.q(selector);\n\t}\n"
						},
						{
							"line": 205,
							"tags": [
								{
									"name": "@param",
									"type": "{Class<Spirit>}",
									"desc": "[type]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<Element>|Array<Spirit>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\tguids(type) {\n\t\tconst selector = '[data-plastique-id]';\n\t\tconst expanded = arguments.length > 1;\n\t\treturn expanded ? this.qall(selector, type) : this.qall(selector);\n\t}\n"
						},
						{
							"line": 214,
							"tags": [
								{
									"name": "@returns",
									"type": "{Map<string,Element>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "TODO: Some kind of `mapguids` method? ",
							"code": "\tmapguids() {\n\t\treturn new Map(this.guids().map(guid => {}));\n\t}\n"
						},
						{
							"line": 221,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "selector",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{constructor}",
									"desc": "[type]",
									"text": "Spirit constructor"
								},
								{
									"name": "@returns",
									"type": "{Element|Spirit}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Get first descendant element matching selector. Optional type argument returns spirit for first element to be associated to spirit of this type. Note that this may not be the first element to match the selector. Also note that type performs slower than betting on &lt;code&gt;Spirit.get(this.dom.q(selector))&lt;/code&gt; ",
							"code": "\t@query\n\tq(selector, type) {\n\t\treturn DOMPlugin.q(this.element, selector, type);\n\t}\n"
						},
						{
							"line": 234,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "selector",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{constructor}",
									"desc": "[type]",
									"text": "Spirit constructor"
								},
								{
									"name": "@returns",
									"type": "{Array<Element|Spirit>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Get list of all descendant elements that matches a selector. Optional type arguments returns instead all associated spirits to match the given type. ",
							"code": "\t@query\n\tqall(selector, type) {\n\t\treturn DOMPlugin.qall(this.element, selector, type);\n\t}\n"
						},
						{
							"line": 245,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "selector",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{constructor}",
									"desc": "[type]",
									"text": "Spirit constructor"
								},
								{
									"name": "@returns",
									"type": "{Element|Spirit}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Same as q, but scoped from the document root. Use wisely. ",
							"code": "\t@query\n\tqdoc(selector, type) {\n\t\treturn DOMPlugin.qdoc(selector, type);\n\t}\n"
						},
						{
							"line": 255,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "selector",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{constructor}",
									"desc": "[type]",
									"text": "Spirit constructor"
								},
								{
									"name": "@returns",
									"type": "{Array<Element|Spirit>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Same as qall, but scoped from the document root. Use wisely. ",
							"code": "\t@query\n\tqdocall(selector, type) {\n\t\treturn DOMPlugin.qdocall(selector, type);\n\t}\n"
						},
						{
							"line": 265,
							"tags": [
								{
									"name": "@param",
									"type": "{constructor}",
									"desc": "[type]",
									"text": "Spirit constructor"
								},
								{
									"name": "@returns",
									"type": "{Element|Spirit}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Next element or next spirit of given type. ",
							"code": "\t@lookup\n\tnext(type) {\n\t\tlet result = null;\n\t\tlet spirit = null;\n\t\tlet el = this.element;\n\t\tif (type) {\n\t\t\twhile ((el = el.nextElementSibling) !== null) {\n\t\t\t\tif ((spirit = type.get(el))) {\n\t\t\t\t\tresult = spirit;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tresult = el.nextElementSibling;\n\t\t}\n\t\treturn result;\n\t}\n"
						},
						{
							"line": 287,
							"tags": [
								{
									"name": "@param",
									"type": "{constructor}",
									"desc": "[type]",
									"text": "Spirit constructor"
								},
								{
									"name": "@returns",
									"type": "{Element|Spirit}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Previous element or previous spirit of given type. ",
							"code": "\t@lookup\n\tprevious(type) {\n\t\tlet result = null;\n\t\tlet spirit = null;\n\t\tlet el = this.element;\n\t\tif (type) {\n\t\t\twhile ((el = el.previousElementSibling) !== null) {\n\t\t\t\tif ((spirit = type.get(el))) {\n\t\t\t\t\tresult = spirit;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tresult = el.previousElementSibling;\n\t\t}\n\t\treturn result;\n\t}\n"
						},
						{
							"line": 309,
							"tags": [
								{
									"name": "@param",
									"type": "{constructor}",
									"desc": "[type]",
									"text": "Spirit constructor"
								},
								{
									"name": "@returns",
									"type": "{Element|Spirit}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "First element or first spirit of type. ",
							"code": "\t@lookup\n\tfirst(type) {\n\t\tlet result = null;\n\t\tlet spirit = null;\n\t\tlet el = this.element.firstElementChild;\n\t\tif (type) {\n\t\t\twhile (result === null && el !== null) {\n\t\t\t\tif ((spirit = type.get(el))) {\n\t\t\t\t\tresult = spirit;\n\t\t\t\t}\n\t\t\t\tel = el.nextElementSibling;\n\t\t\t}\n\t\t} else {\n\t\t\tresult = el;\n\t\t}\n\t\treturn result;\n\t}\n"
						},
						{
							"line": 331,
							"tags": [
								{
									"name": "@param",
									"type": "{constructor}",
									"desc": "[type]",
									"text": "Spirit constructor"
								},
								{
									"name": "@returns",
									"type": "{Element|Spirit}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Last element or last spirit of type. ",
							"code": "\t@lookup\n\tlast(type) {\n\t\tlet result = null;\n\t\tlet spirit = null;\n\t\tlet el = this.element.lastElementChild;\n\t\tif (type) {\n\t\t\twhile (result === null && el !== null) {\n\t\t\t\tspirit = type.get(el);\n\t\t\t\tif (spirit) {\n\t\t\t\t\tresult = spirit;\n\t\t\t\t}\n\t\t\t\tel = el.previoustElementSibling;\n\t\t\t}\n\t\t} else {\n\t\t\tresult = el;\n\t\t}\n\t\treturn result;\n\t}\n"
						},
						{
							"line": 354,
							"tags": [
								{
									"name": "@param",
									"type": "{constructor}",
									"desc": "[type]",
									"text": "Spirit constructor"
								},
								{
									"name": "@returns",
									"type": "{Element|Spirit}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Parent parent or parent spirit of type. ",
							"code": "\t@lookup\n\tparent(type) {\n\t\tlet spirit;\n\t\tlet result = this.element.parentNode;\n\t\tif (type) {\n\t\t\tif ((spirit = type.get(result))) {\n\t\t\t\tresult = spirit;\n\t\t\t} else {\n\t\t\t\tresult = null;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n"
						},
						{
							"line": 372,
							"tags": [
								{
									"name": "@param",
									"type": "{constructor}",
									"desc": "[type]",
									"text": "Spirit constructor"
								},
								{
									"name": "@returns",
									"type": "{Element|Spirit}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Child element or child spirit of type. ",
							"code": "\t@lookup\n\tchild(type) {\n\t\tlet result = this.element.firstElementChild;\n\t\tif (type) {\n\t\t\tresult = this.children(type)[0] || null;\n\t\t}\n\t\treturn result;\n\t}\n"
						},
						{
							"line": 385,
							"tags": [
								{
									"name": "@param",
									"type": "{constructor}",
									"desc": "[type]",
									"text": "Spirit constructor"
								},
								{
									"name": "@returns",
									"type": "{Array<Element|Spirit>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Children elements or children spirits of type. ",
							"code": "\t@lookup\n\tchildren(type) {\n\t\tlet result = [...this.element.children];\n\t\tif (type) {\n\t\t\tresult = result\n\t\t\t\t.filter(el => {\n\t\t\t\t\treturn type.get(el);\n\t\t\t\t})\n\t\t\t\t.map(el => {\n\t\t\t\t\treturn type.get(el);\n\t\t\t\t});\n\t\t}\n\t\treturn result;\n\t}\n"
						},
						{
							"line": 404,
							"tags": [
								{
									"name": "@param",
									"type": "{constructor}",
									"desc": "[type]",
									"text": "Spirit constructor"
								},
								{
									"name": "@returns",
									"type": "{Element|Spirit}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "First ancestor element (parent!) or first ancestor spirit of type. ",
							"code": "\t@lookup\n\tancestor(type) {\n\t\tlet result = this.parent();\n\t\tif (type) {\n\t\t\tresult = null;\n\t\t\tnew Crawler().ascend(this.element, {\n\t\t\t\tonspirit(spirit) {\n\t\t\t\t\tif (type.is(spirit)) {\n\t\t\t\t\t\tresult = spirit;\n\t\t\t\t\t\treturn Crawler.STOP;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn result;\n\t}\n"
						},
						{
							"line": 425,
							"tags": [
								{
									"name": "@param",
									"type": "{constructor}",
									"desc": "[type]",
									"text": "Spirit constructor"
								},
								{
									"name": "@returns",
									"type": "{Array<Element|Spirit>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "First ancestor elements or ancestor spirits of type. ",
							"code": "\t@lookup\n\tancestors(type) {\n\t\tlet result = [];\n\t\tlet crawler = new Crawler();\n\t\tif (type) {\n\t\t\tcrawler.ascend(this.element, {\n\t\t\t\tonspirit(spirit) {\n\t\t\t\t\tif (type.is(spirit)) {\n\t\t\t\t\t\tresult.push(spirit);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tcrawler.ascend(this.element, {\n\t\t\t\tonelement(el) {\n\t\t\t\t\tresult.push(el);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn result;\n\t}\n"
						},
						{
							"line": 451,
							"tags": [
								{
									"name": "@param",
									"type": "{constructor}",
									"desc": "[type]",
									"text": "Spirit constructor"
								},
								{
									"name": "@returns",
									"type": "{Element|Spirit}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "First descendant element or first descendant spirit of type. ",
							"code": "\t@lookup\n\tdescendant(type) {\n\t\tlet result = this.child();\n\t\tlet me = this.element;\n\t\tif (type) {\n\t\t\tnew Crawler().descend(me, {\n\t\t\t\tonspirit(spirit) {\n\t\t\t\t\tif (type.is(spirit)) {\n\t\t\t\t\t\tif (spirit.element !== me) {\n\t\t\t\t\t\t\tresult = spirit;\n\t\t\t\t\t\t\treturn Crawler.STOP;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn result;\n\t}\n"
						},
						{
							"line": 474,
							"tags": [
								{
									"name": "@param",
									"type": "{constructor}",
									"desc": "[type]",
									"text": "Spirit constructor"
								},
								{
									"name": "@returns",
									"type": "{Array<Element|Spirit>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "All descendant elements or all descendant spirits of type. ",
							"code": "\t@lookup\n\tdescendants(type) {\n\t\tlet result = [];\n\t\tlet me = this.element;\n\t\tnew Crawler().descend(me, {\n\t\t\tonelement(element) {\n\t\t\t\tif (!type && element !== me) {\n\t\t\t\t\tresult.push(element);\n\t\t\t\t}\n\t\t\t},\n\t\t\tonspirit(spirit) {\n\t\t\t\tif (type && type.is(spirit)) {\n\t\t\t\t\tif (spirit.element !== me) {\n\t\t\t\t\t\tresult.push(spirit);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn result;\n\t}\n"
						},
						{
							"line": 499,
							"tags": [
								{
									"name": "@param",
									"type": "{constructor}",
									"desc": "[type]",
									"text": "Spirit constructor"
								},
								{
									"name": "@returns",
									"type": "{Array<element|Spirit>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Get following sibling elements or spirits of type. ",
							"code": "\t@lookup\n\tfollowing(type) {\n\t\tlet result = [];\n\t\tlet spirit;\n\t\tlet el = this.element;\n\t\twhile ((el = el.nextElementSibling)) {\n\t\t\tif (type) {\n\t\t\t\tif ((spirit = type.get(el))) {\n\t\t\t\t\tresult.push(spirit);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult.push(el);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n"
						},
						{
							"line": 520,
							"tags": [
								{
									"name": "@param",
									"type": "{constructor}",
									"desc": "[type]",
									"text": "Spirit constructor"
								},
								{
									"name": "@returns",
									"type": "{Array<element|Spirit>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Get preceding sibling elements or spirits of type. ",
							"code": "\t@lookup\n\tpreceding(type) {\n\t\tlet result = [];\n\t\tlet spirit;\n\t\tlet el = this.element;\n\t\twhile ((el = el.previousElementSibling)) {\n\t\t\tif (type) {\n\t\t\t\tif ((spirit = type.get(el))) {\n\t\t\t\t\tresult.push(spirit);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult.push(el);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n"
						},
						{
							"line": 541,
							"tags": [
								{
									"name": "@param",
									"type": "{constructor}",
									"desc": "[type]",
									"text": "Spirit constructor"
								},
								{
									"name": "@returns",
									"type": "{Array<element|Spirit>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Get sibling elements or spirits of type. ",
							"code": "\t@lookup\n\tsiblings(type) {\n\t\treturn this.preceding(type).concat(this.following(type));\n\t}\n"
						},
						{
							"line": 550,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "things",
									"text": "Complicated argument"
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": "Returns the argument"
								}
							],
							"tabs": "\t",
							"desc": "Append spirit OR element OR array of either. ",
							"code": "\t@insert\n\tappend(things) {\n\t\tlet els = things;\n\t\tlet element = this.element;\n\t\tels.forEach(el => {\n\t\t\telement.appendChild(el);\n\t\t});\n\t\treturn things;\n\t}\n"
						},
						{
							"line": 564,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "things",
									"text": "Complicated argument"
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": "Returns the argument"
								}
							],
							"tabs": "\t",
							"desc": "Prepend spirit OR element OR array of either. ",
							"code": "\t@insert\n\tprepend(things) {\n\t\tlet els = things;\n\t\tlet element = this.element;\n\t\tlet first = element.firstChild;\n\t\tels.reverse().forEach(el => {\n\t\t\telement.insertBefore(el, first);\n\t\t});\n\t\treturn things;\n\t}\n"
						},
						{
							"line": 579,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "things",
									"text": "Complicated argument"
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": "Returns the argument"
								}
							],
							"tabs": "\t",
							"desc": "Insert spirit OR element OR array of either before this spirit. ",
							"code": "\t@insert\n\tbefore(things) {\n\t\tlet els = things;\n\t\tlet target = this.element;\n\t\tlet parent = target.parentNode;\n\t\tels.reverse().forEach(el => {\n\t\t\tparent.insertBefore(el, target);\n\t\t});\n\t\treturn things;\n\t}\n"
						},
						{
							"line": 594,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "things",
									"text": "Complicated argument"
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": "Returns the argument"
								}
							],
							"tabs": "\t",
							"desc": "Insert spirit OR element OR array of either after this spirit. ",
							"code": "\t@insert\n\tafter(things) {\n\t\tlet els = things;\n\t\tlet target = this.element;\n\t\tlet parent = target.parentNode;\n\t\tels.forEach(el => {\n\t\t\tparent.insertBefore(el, target.nextSibling);\n\t\t});\n\t\treturn things;\n\t}\n"
						},
						{
							"line": 609,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "things",
									"text": "Complicated argument."
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": "Returns the argument"
								}
							],
							"tabs": "\t",
							"desc": "Replace the spirit with something else. This may nuke the spirit. Note that this method is called on the spirit, not on the parent. ",
							"code": "\t@insert\n\treplace(things) {\n\t\tthis.after(things);\n\t\tthis.remove();\n\t\treturn things;\n\t}\n"
						},
						{
							"line": 621,
							"tags": [
								{
									"name": "@param",
									"type": "{Element|Spirit}",
									"desc": "thing",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{DOMPlugin}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Append spirit (element) to another spirit or element. ",
							"code": "\t@insertme\n\tappendTo(thing) {\n\t\tthing.appendChild(this.element);\n\t\treturn this;\n\t}\n"
						},
						{
							"line": 631,
							"tags": [
								{
									"name": "@param",
									"type": "{Element|Spirit}",
									"desc": "thing",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{DOMPlugin}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Append spirit (element) as the first child of spirit or element. ",
							"code": "\t@insertme\n\tprependTo(thing) {\n\t\tthing.parentNode.insertBefore(this.element, thing.firstChild);\n\t\treturn this;\n\t}\n"
						},
						{
							"line": 641,
							"tags": [
								{
									"name": "@param",
									"type": "{object}",
									"desc": "thing",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{DOMPlugin}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Insert spirit (element) before another spirit or element. ",
							"code": "\t@insertme\n\tinsertBefore(thing) {\n\t\tthing.parentNode.insertBefore(this.element, thing);\n\t\treturn this;\n\t}\n"
						},
						{
							"line": 651,
							"tags": [
								{
									"name": "@param",
									"type": "{Element|Spirit}",
									"desc": "thing",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{DOMPlugin}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Insert spirit (element) after another spirit or element. ",
							"code": "\t@insertme\n\tinsertAfter(thing) {\n\t\tthing.parentNode.insertBefore(this.element, thing.nextSibling);\n\t\treturn this;\n\t}\n"
						}
					]
				},
				{
					"title": "Static ",
					"tabs": "\t",
					"sections": [
						{
							"line": 662,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "[markup]",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "[pos]",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Spiritual-aware innerHTML (WebKit first aid). ",
							"code": "\t@chained\n\tstatic html(elm, markup, pos) {\n\t\tif (arguments.length > 1) {\n\t\t\tif (pos) {\n\t\t\t\treturn elm.insertAdjacentHTML(pos, markup);\n\t\t\t} else {\n\t\t\t\telm.innerHTML = markup;\n\t\t\t}\n\t\t} else {\n\t\t\treturn elm.innerHTML;\n\t\t}\n\t}\n"
						},
						{
							"line": 680,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "[markup]",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Spiritual-aware outerHTML (WebKit first aid). TODO: deprecate and support 'replace' value for position? TODO: can outerHTML carry multiple root-nodes? ",
							"code": "\t@chained\n\tstatic outerHtml(elm, markup) {\n\t\tif (arguments.length > 1) {\n\t\t\telm.outerHTML = markup;\n\t\t} else {\n\t\t\treturn elm.outerHTML;\n\t\t}\n\t}\n"
						},
						{
							"line": 695,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "[html]",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "[position]",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Spiritual-aware textContent (WebKit first aid). ",
							"code": "\t@chained\n\tstatic text(elm, value) {\n\t\tif (arguments.length > 1) {\n\t\t\telm.textContent = value;\n\t\t} else {\n\t\t\treturn elm.textContent;\n\t\t}\n\t}\n"
						},
						{
							"line": 709,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{number}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Get ordinal position of element within container. ",
							"code": "\tstatic ordinal(elm) {\n\t\tlet result = 0;\n\t\tlet parent = elm.parentNode;\n\t\tif (parent) {\n\t\t\tlet node = parent.firstElementChild;\n\t\t\twhile (node && node !== elm) {\n\t\t\t\tnode = node.nextElementSibling;\n\t\t\t\tresult++;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n"
						},
						{
							"line": 726,
							"tags": [
								{
									"name": "@param",
									"type": "{Node|Spirit}",
									"desc": "node1",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Node|Spirit}",
									"desc": "node2",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{number}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Compare document position of two nodes. \n\n",
							"code": "\tstatic compare(node1, node2) {\n\t\tnode1 = normalize(node1);\n\t\tnode2 = normalize(node2);\n\t\treturn node1.compareDocumentPosition(node2);\n\t}\n"
						},
						{
							"line": 738,
							"tags": [
								{
									"name": "@param",
									"type": "{Node|Spirit}",
									"desc": "node",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Node|Spirit}",
									"desc": "othernode",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Node contains other node? TODO: Just use `node.contains(othernode)` :) ",
							"code": "\tstatic contains(node, othernode) {\n\t\tlet check =\n\t\t\tNode.DOCUMENT_POSITION_CONTAINS + Node.DOCUMENT_POSITION_PRECEDING;\n\t\treturn this.compare(othernode, node) === check;\n\t}\n"
						},
						{
							"line": 750,
							"tags": [
								{
									"name": "@param",
									"type": "{Node|Spirit}",
									"desc": "node",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Node|Spirit}",
									"desc": "othernode",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Other node is a following sibling to node? ",
							"code": "\tstatic follows(node, othernode) {\n\t\treturn this.compare(othernode, node) === Node.DOCUMENT_POSITION_FOLLOWING;\n\t}\n"
						},
						{
							"line": 759,
							"tags": [
								{
									"name": "@param",
									"type": "{Node|Spirit}",
									"desc": "node",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Node|Spirit}",
									"desc": "othernode",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Other node is a preceding sibling to node? ",
							"code": "\tstatic precedes(node, othernode) {\n\t\treturn this.compare(othernode, node) === Node.DOCUMENT_POSITION_PRECEDING;\n\t}\n"
						},
						{
							"line": 768,
							"tags": [
								{
									"name": "@param",
									"type": "{Element|Spirit}",
									"desc": "node",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Is node positioned in page DOM? ",
							"code": "\tstatic embedded(node) {\n\t\tnode = normalize(node);\n\t\treturn this.contains(node.ownerDocument, node);\n\t}\n"
						},
						{
							"line": 777,
							"tags": [
								{
									"name": "@param",
									"type": "{Array<Element|Spirit>}",
									"desc": "nodes",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<Element|Spirit>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Remove from list all nodes that are contained by others. TODO: Move this to `spiritual-util` if not used nowhere. ",
							"code": "\tstatic group(nodes) {\n\t\tlet node;\n\t\tlet groups = [];\n\t\tconst containedby = (target, others) => {\n\t\t\treturn others.some(other => DOMPlugin.contains(other, target));\n\t\t};\n\t\twhile ((node = nodes.pop())) {\n\t\t\tif (!containedby(node, nodes)) {\n\t\t\t\tgroups.push(node);\n\t\t\t}\n\t\t}\n\t\treturn groups;\n\t}\n"
						},
						{
							"line": 796,
							"tags": [
								{
									"name": "@param",
									"type": "{Array<Node>}",
									"desc": "nodes",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Sort nodes in document order. ",
							"code": "\tstatic sort(nodes) {\n\t\treturn nodes.sort(documentPositionComparator);\n\t}\n"
						},
						{
							"line": 804,
							"tags": [
								{
									"name": "@param",
									"type": "{Node}",
									"desc": "node",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "selector",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{constructor}",
									"desc": "[type]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Element|Spirit}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Get first element that matches a selector. Optional type argument filters to spirit of type. ",
							"code": "\tstatic q(node, selector, type) {\n\t\tlet result = null;\n\t\tif (type) {\n\t\t\tresult = this.qall(node, selector, type)[0] || null;\n\t\t} else {\n\t\t\tresult = node.querySelector(selector);\n\t\t}\n\t\treturn result;\n\t}\n"
						},
						{
							"line": 821,
							"tags": [
								{
									"name": "@param",
									"type": "{Node}",
									"desc": "node",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "selector",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{constructor}",
									"desc": "[type]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<Element|Spirit>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Get list of all elements that matches a selector. Optional type argument filters to spirits of type. Method always returns a (potentially empty) array. ",
							"code": "\tstatic qall(node, selector, type) {\n\t\tlet result = Array.from(node.querySelectorAll(selector));\n\t\tif (type) {\n\t\t\tconst has = elm => !!type.get(elm);\n\t\t\tconst get = elm => type.get(elm);\n\t\t\tresult = result.filter(has).map(get);\n\t\t}\n\t\treturn result;\n\t}\n"
						},
						{
							"line": 839,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "selector",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{constructor}",
									"desc": "[type]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Element|Spirit}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Get first element in document that matches a selector. Optional type argument filters to spirit of type. ",
							"code": "\tstatic qdoc(selector, type) {\n\t\treturn this.q(document, selector, type);\n\t}\n"
						},
						{
							"line": 849,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "selector",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{constructor}",
									"desc": "[type]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<Element|Spirit>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get list of all elements in document that matches a selector. Optional type argument filters to spirits of type. Method always returns a (potentially empty) array. ",
							"code": "\tstatic qdocall(selector, type) {\n\t\treturn this.qall(document, selector, type);\n\t}\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 861,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "const [FOLLOWING, PRECEDING, CONTAINS, CONTAINED_BY] = Environment.browser\n\t? [\n\t\t\tNode.DOCUMENT_POSITION_FOLLOWING,\n\t\t\tNode.DOCUMENT_POSITION_PRECEDING,\n\t\t\tNode.DOCUMENT_POSITION_CONTAINS,\n\t\t\tNode.DOCUMENT_POSITION_CONTAINED_BY\n\t  ]\n\t: [];\n"
						},
						{
							"line": 870,
							"tags": [
								{
									"name": "@param",
									"type": "{Node}",
									"desc": "a",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Node}",
									"desc": "b",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Number}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "https://stackoverflow.com/questions/31991235/sort-elements-by-document-order-in-javascript ",
							"code": "function documentPositionComparator(a, b) {\n\tconst position = a.compareDocumentPosition(b);\n\treturn a === b\n\t\t? 0\n\t\t: position & FOLLOWING || position & CONTAINED_BY\n\t\t\t? -1\n\t\t\t: position & PRECEDING || position & CONTAINS\n\t\t\t\t? 1\n\t\t\t\t: 0;\n}\n"
						},
						{
							"line": 886,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "desc",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "DOM query methods accept a CSS selector and an optional spirit constructor as arguments. They return a spirit, an element or an array of either. ",
							"code": "function query(target, name, desc) {\n\tconst base = desc.value;\n\tdesc.value = function() {\n\t\tlet selector = arguments[0];\n\t\tlet type = arguments[1];\n\t\tif (isString(selector)) {\n\t\t\tif (arguments.length === 1 || isClass(type)) {\n\t\t\t\treturn base.apply(this, arguments);\n\t\t\t} else {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Unknown spirit for query ${name}: (${selector}, ${typeOf(type)})`\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new TypeError(`Bad selector for query ${name}: ${selector}`);\n\t\t}\n\t};\n\treturn desc;\n}\n"
						},
						{
							"line": 913,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "desc",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "DOM lookup methods accept an optional spirit constructor as argument. These methods return a spirit, an element or an array of either. ",
							"code": "function lookup(target, name, desc) {\n\tconst base = desc.value;\n\tdesc.value = function(type) {\n\t\tif (!isDefined(type) || isFunction(type)) {\n\t\t\treturn base.apply(this, arguments);\n\t\t} else {\n\t\t\tthrow new TypeError(\n\t\t\t\t`Unknown spirit for query ${name}: (${typeOf(type)})`\n\t\t\t);\n\t\t}\n\t};\n\treturn desc;\n}\n"
						},
						{
							"line": 934,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "desc",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "DOM insertion methods accept one argument: one spirit OR one element OR an array of either or both. The input argument is returned as given, this allows for the following one-liner: \n`this.something = this.dom.append(gui.SomeThingSpirit.summon()); // imagine 15 more` TODO: Go for compliance with DOM4 method matches (something about textnoding string arguments) TODO: Validate input either Spirit or element TODO: DocumentFragment and friends :) ",
							"code": "function insert(target, name, desc) {\n\tconst base = desc.value;\n\tdesc.value = function(things) {\n\t\tlet elms = asarray(things).map(normalize);\n\t\tif (elms.length) {\n\t\t\tbase.call(this, elms);\n\t\t}\n\t\treturn things;\n\t};\n\treturn desc;\n}\n"
						},
						{
							"line": 957,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "desc",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Bonus DOM insertion methods takes an element or spirit as argument. ",
							"code": "function insertme(target, name, desc) {\n\tconst base = desc.value;\n\tdesc.value = function(thing) {\n\t\tthing = normalize(thing);\n\t\tif (isElement(thing)) {\n\t\t\tbase.call(this, thing);\n\t\t\treturn this;\n\t\t} else {\n\t\t\tthrow new TypeError(`Expected spirit or element, got ${typeOf(thing)}`);\n\t\t}\n\t};\n\treturn desc;\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/gui-plugins/src/event/EventPlugin.js": {
			"title": "EventPlugin",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import TrackerPlugin from '../TrackerPlugin';\nimport { Spirit } from '@dataplastique/gui';\nimport { asarray, isWindow, chained } from '@dataplastique/util';\n"
						},
						{
							"line": 3,
							"tags": [],
							"tabs": "\t",
							"desc": "Tracking and dispatching DOM events. ",
							"code": "export default class EventPlugin extends TrackerPlugin {\n"
						},
						{
							"line": 7,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Array<string>}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Element|Spirit}",
									"desc": "[target]",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{EventHandler}",
									"desc": "[handler]",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{boolean|Object}",
									"desc": "[capture]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{this}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Add one or more event handlers. TODO: Support config via object ",
							"code": "\t@chained\n\ton(type, target = this.element, handler = this.spirit, capture = false) {\n\t\tlet checks = [(target = qualify(target)), handler, capture];\n\t\tasarray(type, t => {\n\t\t\tif (this._addchecks(t, checks)) {\n\t\t\t\tthis._shiftEventListener(true, target, t, handler, capture);\n\t\t\t}\n\t\t});\n\t}\n"
						},
						{
							"line": 25,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Array<string>}",
									"desc": "arg",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Element|Spirit}",
									"desc": "[target]",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{EventHandler}",
									"desc": "[handler]",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{boolean}",
									"desc": "[capture]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{this}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Remove one or more event handlers. TODO: Support config via object ",
							"code": "\t@chained\n\toff(type, target = this.element, handler = this.spirit, capture = false) {\n\t\tlet checks = [(target = qualify(target)), handler, capture];\n\t\tasarray(type, t => {\n\t\t\tif (this._removechecks(t, checks)) {\n\t\t\t\tthis._shiftEventListener(false, target, t, handler, capture);\n\t\t\t}\n\t\t});\n\t}\n"
						}
					]
				},
				{
					"title": "Private ",
					"tabs": "\t",
					"sections": [
						{
							"line": 44,
							"tags": [
								{
									"name": "@param",
									"type": "{boolean}",
									"desc": "add",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Node}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "handler",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{boolean}",
									"desc": "capture",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Actual event registration has been isolated so that one may overwrite or overload this particular part. ",
							"code": "\t_shiftEventListener(add, target, type, handler, capture) {\n\t\tconst args = [type, handler, capture];\n\t\tadd\n\t\t\t? target.addEventListener(...args)\n\t\t\t: target.removeEventListener(...args);\n\t}\n"
						},
						{
							"line": 59,
							"tags": [
								{
									"name": "@see",
									"type": "{TrackerPlugin}",
									"desc": "",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<object>}",
									"desc": "checks",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Remove event listeners. ",
							"code": "\t_cleanupchecks(type, checks) {\n\t\tthis.off(type, ...checks);\n\t}\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 70,
							"tags": [
								{
									"name": "@param",
									"type": "{Spirit|Node|Window}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Node|Window}",
									"desc": "",
									"text": ""
								},
								{
									"name": "@throws",
									"type": "{TypeError}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Qualify target. TODO: XMLHttpRequest can for example also be a target. ",
							"code": "function qualify(target) {\n\tif (Spirit.is(target)) {\n\t\ttarget = target.element;\n\t}\n\tif (target && (target.nodeType || isWindow(target))) {\n\t\treturn target;\n\t} else {\n\t\tthrow new TypeError('Unqualified event target', target);\n\t}\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/gui-plugins/src/index.js": {
			"title": "index",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "export { default as SpiritPlugin, plugin } from './SpiritPlugin';\nexport { default as BroadcastPlugin } from './broadcast/BroadcastPlugin';\nexport { default as ScriptPlugin } from './script/ScriptPlugin';\nexport { default as ShadowPlugin } from './shadow/ShadowPlugin';\nexport { default as EventPlugin } from './event/EventPlugin';\nexport { default as TickPlugin } from './tick/TickPlugin';\nexport { default as LifePlugin } from './life/LifePlugin';\nexport { default as AttPlugin } from './att/AttPlugin';\nexport { default as CSSPlugin } from './css/CSSPlugin';\nexport { default as DOMPlugin } from './dom/DOMPlugin';\nexport { default as KeyPlugin } from './key/KeyPlugin';\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/gui-plugins/src/key/Key.js": {
			"title": "Key",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { Mapping } from '@dataplastique/util';\nimport { chained } from '@dataplastique/util';\nimport { Tick } from '@dataplastique/util';\nimport { Environment } from '@dataplastique/util';\nimport { asarray } from '@dataplastique/util';\n"
						},
						{
							"line": 5,
							"tags": [],
							"tabs": "\t",
							"desc": "Key. TODO: Rename `add/remove` `on/off` TODO: Broadcast global! ",
							"code": "export default class Key {\n"
						},
						{
							"line": 11,
							"tags": [
								{
									"name": "@param",
									"type": "{boolean}",
									"desc": "down",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{boolean}",
									"desc": "isglobal",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\tconstructor(down, type, isglobal = false) {\n\t\tObject.assign(this, { down, type, isglobal }); \n\t}\n"
						}
					]
				},
				{
					"title": "Static ",
					"tabs": "\t",
					"sections": [
						{
							"line": 20,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "type",
									"text": "String or array of strings"
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "handler",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Constructor}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Add handler for tick. ",
							"code": "\t@chained\n\tstatic add(type, handler) {\n\t\tadd(type, handler);\n\t}\n"
						},
						{
							"line": 30,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "type",
									"text": "String or array of strings"
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "handler",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Constructor}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Remove handler for tick. ",
							"code": "\t@chained\n\tstatic remove(type, handler) {\n\t\tremove(type, handler);\n\t}\n"
						},
						{
							"line": 40,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "type",
									"text": "String or array of strings"
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "handler",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Constructor}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Add auto-removing handler for tick. ",
							"code": "\t@chained\n\tstatic one(type, handler) {\n\t\tadd(type, handler, true);\n\t}\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 52,
							"tags": [
								{
									"name": "@type",
									"type": "{Map<string,Set<IKeyHandler>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "const allhandlers = new Mapping();\n"
						},
						{
							"line": 56,
							"tags": [],
							"tabs": "",
							"desc": "TODO! ",
							"code": "const onehandlers = new Mapping();\n"
						},
						{
							"line": 60,
							"tags": [],
							"tabs": "",
							"desc": "\n\n",
							"code": "const keymap = new Map();\n"
						},
						{
							"line": 64,
							"tags": [
								{
									"name": "@see",
									"type": "http://www.w3.org/TR/DOM-Level-3-Events/#key-values",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Mapping DOM0 key codes to some DOM3 key values. Note that keycodes aren't used on an API level. TODO: AltGraph CapsLoc Fn FnLock Meta Process NumLock SymbolLock OS Compose ",
							"code": "const keys = new Map([\n\t[38, 'Up'],\n\t[40, 'Down'],\n\t[37, 'Left'],\n\t[39, 'Right'],\n\t[18, 'Alt'],\n\t[17, 'Control'],\n\t[16, 'Shift'],\n\t[32, 'Space'],\n\t[27, 'Esc'],\n\t[13, 'Enter']\n]);\n"
						},
						{
							"line": 82,
							"tags": [],
							"tabs": "",
							"desc": "Key modifiers. ",
							"code": "const mods = {\n\tshiftDown: false, \n\tctrlDown: false, \n\taltDown: false, \n\tmetaDown: false, \n\taccelDown: false, \n\taccessDown: false \n};\nlet keycode = 0;\n"
						},
						{
							"line": 94,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Array<string>}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{TickHandler}",
									"desc": "handler",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{boolean}",
									"desc": "one",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function add(type, handler, one) {\n\tasarray(type).forEach(t => {\n\t\tallhandlers.add(t, handler);\n\t\tif (one) {\n\t\t\tonehandlers.add(t, handler);\n\t\t}\n\t});\n\tif (allhandlers.size === 1) {\n\t\tlisten(true);\n\t}\n}\n"
						},
						{
							"line": 110,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Array<string>}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{TickHandler}",
									"desc": "handler",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function remove(type, handler) {\n\tasarray(type).forEach(t => {\n\t\tallhandlers.remove(type, handler);\n\t\tonehandlers.remove(type, handler);\n\t});\n\tif (allhandlers.size === 0) {\n\t\tlisten(false);\n\t}\n}\n"
						},
						{
							"line": 123,
							"tags": [
								{
									"name": "@param",
									"type": "{boolean}",
									"desc": "on",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function listen(on) {\n\tif (Environment.browser) {\n\t\t['keydown', 'keypress', 'keyup'].forEach(type => {\n\t\t\tconst args = [type, handleKey]; \n\t\t\tif (on) {\n\t\t\t\tdocument.addEventListener(...args);\n\t\t\t} else {\n\t\t\t\tdocument.removeEventListener(...args);\n\t\t\t}\n\t\t});\n\t}\n}\n"
						},
						{
							"line": 138,
							"tags": [
								{
									"name": "@param",
									"type": "{KeyEvent}",
									"desc": "e",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Handle key event. ",
							"code": "function handleKey(e) {\n\tlet n = e.keyCode;\n\tlet c = keymap.get(n);\n\tlet b = 'BROADCAST_KEYEVENT';\n\tswitch (e.type) {\n\t\tcase 'keydown':\n\t\t\tif (c === undefined) {\n\t\t\t\tkeycode = n;\n\t\t\t\tkeymap.set(n, String.fromCharCode(e.which).toLowerCase());\n\t\t\t\tTick.next(() => {\n\t\t\t\t\tc = keymap.get(n);\n\t\t\t\t\tupdate(true, null, c, n);\n\t\t\t\t\tkeycode = null;\n\t\t\t\t});\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'keypress':\n\t\t\tif (keycode) {\n\t\t\t\tc = keychar(e.keyCode, e.charCode, e.which);\n\t\t\t\tkeymap.set(keycode, c);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'keyup':\n\t\t\tif (c !== undefined) {\n\t\t\t\tupdate(false, null, c, n);\n\t\t\t\tkeymap.delete(n);\n\t\t\t}\n\t\t\tbreak;\n\t}\n}\n"
						},
						{
							"line": 172,
							"tags": [
								{
									"name": "@param",
									"type": "{number}",
									"desc": "n",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{number}",
									"desc": "c",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{number}",
									"desc": "which",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{String}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get character for event details on keypress only. Returns null for special keys such as arrows etc. http://javascript.info/tutorial/keyboard-events ",
							"code": "function keychar(n, c, which) {\n\tif (which === null || which === undefined) {\n\t\treturn String.fromCharCode(n); \n\t} else if (which !== 0 && c) {\n\t\treturn String.fromCharCode(which); \n\t}\n\treturn null;\n}\n"
						},
						{
							"line": 189,
							"tags": [
								{
									"name": "@param",
									"type": "{boolean}",
									"desc": "down",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{String}",
									"desc": "key",
									"text": "Newschool ABORTED FOR NOW!"
								},
								{
									"name": "@param",
									"type": "{String}",
									"desc": "c",
									"text": "(char) Bothschool"
								},
								{
									"name": "@param",
									"type": "{number}",
									"desc": "code",
									"text": "Oldschool"
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function update(down, key, c, code) {\n\tconst type = keys.get(code) || c;\n\tconst all = allhandlers;\n\tconst one = onehandlers;\n\tif (all.has(type)) {\n\t\tconst k = new Key(down, type); \n\t\tall\n\t\t\t.toArray(type)\n\t\t\t.filter(handler => {\n\t\t\t\thandler.onkey(k);\n\t\t\t\treturn one.has(type, handler);\n\t\t\t})\n\t\t\t.forEach(handler => {\n\t\t\t\tall.remove(type, handler);\n\t\t\t\tone.remove(type, handler);\n\t\t\t});\n\t}\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/gui-plugins/src/key/KeyPlugin.js": {
			"title": "KeyPlugin",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import Key from './Key';\nimport TrackerPlugin from '../TrackerPlugin';\nimport { chained } from '@dataplastique/util';\nimport { asarray } from '@dataplastique/util';\n"
						},
						{
							"line": 4,
							"tags": [],
							"tabs": "\t",
							"desc": "Everything keyboard plugin. ",
							"code": "export default class KeyPlugin extends TrackerPlugin {\n"
						},
						{
							"line": 8,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Array<string>}",
									"desc": "arg",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "[handler]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{this}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Add one or more key handlers. ",
							"code": "\t@chained\n\ton(type, handler = this.spirit) {\n\t\tasarray(type, t => {\n\t\t\tif (this._addchecks(t, [handler])) {\n\t\t\t\tKey.add(t, handler);\n\t\t\t}\n\t\t});\n\t}\n"
						},
						{
							"line": 22,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Array<string>}",
									"desc": "arg",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "[handler]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{this}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Add one or more key handlers. ",
							"code": "\t@chained\n\toff(type, handler = this.spirit) {\n\t\tasarray(type, t => {\n\t\t\tif (this._removechecks(t, [handler])) {\n\t\t\t\tKey.remove(t, handler);\n\t\t\t}\n\t\t});\n\t}\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/gui-plugins/src/life/Life.js": {
			"title": "Life",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "\t",
							"desc": "A non-bubbling kind of event that exposes the lifecycle of a spirit. TODO: Fountain of Life (optimize) ",
							"code": "export default class Life {\n"
						},
						{
							"line": 6,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Spirit}",
									"desc": "target",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "\tconstructor(type, target) {\n\t\tthis.target = target;\n\t\tthis.type = type;\n\t}\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/gui-plugins/src/life/LifePlugin.js": {
			"title": "LifePlugin",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import Life from './Life';\nimport TrackerPlugin from '../TrackerPlugin';\nimport { chained } from '@dataplastique/util';\nimport { asarray } from '@dataplastique/util';\nconst LIFE_CONFIGURE = 'gui-life-configure';\nconst LIFE_ENTER = 'gui-life-enter';\nconst LIFE_ATTACH = 'gui-life-attach';\nconst LIFE_READY = 'gui-life-ready';\nconst LIFE_RENDER = 'gui-life-render';\nconst LIFE_DETACH = 'gui-life-detach';\nconst LIFE_EXIT = 'gui-life-exit';\nconst LIFE_ASYNC = 'gui-life-async';\nconst LIFE_DESTRUCT = 'gui-life-destruct';\n"
						},
						{
							"line": 13,
							"tags": [],
							"tabs": "\t",
							"desc": "Tracking the spirit lifecycle. TODO: Prevent one-offs from changing state twice ",
							"code": "export default class LifePlugin extends TrackerPlugin {\n\tconfigured = false;\n\tentered = false;\n\tattached = false;\n\tready = false;\n\tasync = false;\n\tdestructed = false;\n\trendered = false; \n"
						},
						{
							"line": 25,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Array<string>}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{LifeHandler}",
									"desc": "[handler]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{this}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Add handler for life event(s). ",
							"code": "\t@chained\n\ton(type, handler = this.spirit) {\n\t\tasarray(type).forEach(t => {\n\t\t\tthis._addchecks(t, [handler]);\n\t\t});\n\t}\n"
						},
						{
							"line": 37,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Array<string>}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{LifeHandler}",
									"desc": "[handler]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{this}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Remove handler for life event(s). ",
							"code": "\t@chained\n\toff(type, handler = this.spirit) {\n\t\tasarray(type).forEach(t => {\n\t\t\tthis._removechecks(t, [handler]);\n\t\t});\n\t}\n"
						},
						{
							"line": 49,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Array<string>}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{this}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Dispatch life event(s). ",
							"code": "\t@chained\n\tdispatch(type) {\n\t\tlet list = this._checklist;\n\t\tif (list && list.size) {\n\t\t\tasarray(type).forEach(t => {\n\t\t\t\tif (list.has(t)) {\n\t\t\t\t\tgodispatch(t, this.spirit, list);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 67,
							"tags": [
								{
									"name": "@type",
									"type": "{Set<string>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "These may happen only once. ",
							"code": "const singlerun = new Set([\n\tLIFE_CONFIGURE.LIFE_ENTER,\n\tLIFE_READY,\n\tLIFE_DESTRUCT\n]);\n"
						},
						{
							"line": 76,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Spirit}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<LifeHandler>}",
									"desc": "checklist",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Dispatch life event. ",
							"code": "function godispatch(type, target, checklist) {\n\tlet life = new Life(type, target);\n\tchecklist\n\t\t.toArray(type)\n\t\t.map(checks => checks[0])\n\t\t.forEach(handler => {\n\t\t\thandler.onlife(life);\n\t\t});\n\tif (singlerun.has(type)) {\n\t\tchecklist.delete(type);\n\t}\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/gui-plugins/src/script/ScriptPlugin.js": {
			"title": "ScriptPlugin",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import SpiritPlugin from '../SpiritPlugin';\nimport { addGlobalObserver, removeGlobalObserver } from '@dataplastique/edb';\nimport { diff, patch } from '@dataplastique/edbml-runtime';\nimport {\n\tConfigurationError,\n\tMapping,\n\tTick,\n\tKey,\n\tchained\n} from '@dataplastique/util';\n"
						},
						{
							"line": 10,
							"tags": [],
							"tabs": "\t",
							"desc": "Script plugin. TODO: General purpose decorator to `bind` methods ('run', 'one', 'stop'). ",
							"code": "export default class ScriptPlugin extends SpiritPlugin {\n"
						},
						{
							"line": 15,
							"tags": [
								{
									"name": "@type",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Script loaded? ",
							"code": "\tget loaded() {\n\t\treturn !!this._script;\n\t}\n"
						},
						{
							"line": 22,
							"tags": [
								{
									"name": "@type",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Script is running? ",
							"code": "\tget running() {\n\t\treturn !!this._running;\n\t}\n"
						},
						{
							"line": 29,
							"tags": [
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "script",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{ScriptPlugin}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Load script. ",
							"code": "\t@chained\n\tload(script) {\n\t\tif ((this._script = script)) {\n\t\t\tthis._params = [];\n\t\t}\n\t}\n"
						},
						{
							"line": 40,
							"tags": [
								{
									"name": "@returns",
									"type": "{this}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Run the script and watch for future model updates. TODO: Consider (and test) always running this on a micro schedule ",
							"code": "\t@chained\n\trun(...args) {\n\t\tthis._running = true;\n\t\tthis._params = args;\n\t\tif (this._runnable()) {\n\t\t\taddGlobalObserver(this);\n\t\t\tthis._watch = true;\n\t\t\tthis._props.clear();\n\t\t\tthis.one(...args);\n\t\t}\n\t}\n"
						},
						{
							"line": 56,
							"tags": [
								{
									"name": "@returns",
									"type": "{this}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Stop running and ignore future model updates. ",
							"code": "\t@chained\n\tstop() {\n\t\tremoveGlobalObserver(this);\n\t\tthis._running = false;\n\t\tthis._watch = false;\n\t\tthis._props.clear();\n\t}\n"
						},
						{
							"line": 67,
							"tags": [
								{
									"name": "@returns",
									"type": "{this}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Simply run the script once and ignore future model updates. ",
							"code": "\t@chained\n\tone(...args) {\n\t\tthis._params = args;\n\t\tTick.cancelFrame(this._scheduleid);\n\t\tif (this._runnable()) {\n\t\t\tconst oldout = this._output;\n\t\t\tconst newout = this._script.apply(this.spirit, args);\n\t\t\tthis._watch = false; \n\t\t\tthis._output = render(this.spirit, this.root(), oldout, newout);\n\t\t}\n\t}\n"
						},
						{
							"line": 82,
							"tags": [
								{
									"name": "@returns",
									"type": "{Element}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Get the script context root element, mostly so that derived plugin `ShadowPlugin` can overwrite this very return value. ",
							"code": "\troot() {\n\t\treturn this.element;\n\t}\n"
						},
						{
							"line": 90,
							"tags": [
								{
									"name": "@implements",
									"type": "{IObserver}",
									"desc": "",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "model",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Model property inspected. ",
							"code": "\tonpeek(model, name) {\n\t\tif (this.running && this._watch) {\n\t\t\tthis._props.add(model.$id, name);\n\t\t}\n\t}\n"
						},
						{
							"line": 101,
							"tags": [
								{
									"name": "@implements",
									"type": "{IObserver}",
									"desc": "",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "model",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{*}",
									"desc": "newval",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{*}",
									"desc": "oldval",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Model property changed. ",
							"code": "\tonpoke(model, name, newval, oldval) {\n\t\tif (this._dependson(model, name)) {\n\t\t\tif (this._watch) {\n\t\t\t\tthrow updateerror(model, name);\n\t\t\t} else {\n\t\t\t\tthis._schedule();\n\t\t\t}\n\t\t}\n\t}\n"
						},
						{
							"line": 118,
							"tags": [
								{
									"name": "@implements",
									"type": "{IObserver}",
									"desc": "",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Collection}",
									"desc": "collection",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<Any>}",
									"desc": "added",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<Any>}",
									"desc": "removed",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Collection updated. ",
							"code": "\tonsplice(collection, added, removed) {\n\t\tif (this._dependson(collection) && (added.length || removed.length)) {\n\t\t\tif (this._watch) {\n\t\t\t\tthrow updateerror(collection);\n\t\t\t} else {\n\t\t\t\tthis._schedule();\n\t\t\t}\n\t\t}\n\t}\n"
						},
						{
							"line": 134,
							"tags": [],
							"tabs": "\t",
							"desc": "Release everything. TODO: destruct sequence automated! ",
							"code": "\tondestruct() {\n\t\tsuper.ondestruct();\n\t\tremoveGlobalObserver(this);\n\t\tthis._watch = false;\n\t\tthis._params = null;\n\t\tthis._props = null;\n\t\tif (this._io) {\n\t\t\tthis._io.dispose();\n\t\t}\n\t}\n"
						}
					]
				},
				{
					"title": "Private ",
					"tabs": "\t",
					"sections": [
						{
							"line": 149,
							"tags": [
								{
									"name": "@type",
									"type": "{Function}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Currently loaded script. ",
							"code": "\t_script = null;\n"
						},
						{
							"line": 154,
							"tags": [],
							"tabs": "\t",
							"desc": "Hm. ",
							"code": "\t_props = new Mapping();\n"
						},
						{
							"line": 158,
							"tags": [],
							"tabs": "\t",
							"desc": "Hm. ",
							"code": "\t_watch = false;\n"
						},
						{
							"line": 162,
							"tags": [
								{
									"name": "@type",
									"type": "{Array<Any>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Snapshot latest arguments served to the `run` method. ",
							"code": "\t_params = [];\n"
						},
						{
							"line": 167,
							"tags": [
								{
									"name": "@type",
									"type": "{Out}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Snapshot the latest script output so that we may use it to diff the next. ",
							"code": "\t_output = '';\n"
						},
						{
							"line": 173,
							"tags": [
								{
									"name": "@type",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Script is running? ",
							"code": "\t_running = false;\n"
						},
						{
							"line": 178,
							"tags": [
								{
									"name": "@type",
									"type": "{number}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Rerun booking number. ",
							"code": "\t_scheduleid = -1;\n"
						},
						{
							"line": 183,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "model",
									"text": "- Either a Model or a Collection"
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "[name]",
									"text": "- Omitted if the `model` is a Collection"
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Script depends on the model (or a specific property of the model)? ",
							"code": "\t_dependson(model, name) {\n\t\tconst map = this._props;\n\t\tconst $id = model.$id;\n\t\treturn name ? map.has($id, name) : map.has($id);\n\t}\n"
						},
						{
							"line": 194,
							"tags": [
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "[reject]",
									"text": "- For use in Promise based scenario"
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Confirm that we are ready to `run()` the script, otherwise fail miserably. ",
							"code": "\t_runnable(reject) {\n\t\tif (this.loaded) {\n\t\t\treturn true;\n\t\t} else if (reject) {\n\t\t\treject('No script loaded.');\n\t\t} else {\n\t\t\tthrow new ConfigurationError('No script loaded.');\n\t\t}\n\t}\n"
						},
						{
							"line": 208,
							"tags": [],
							"tabs": "\t",
							"desc": "Schedule rerun. TODO: Make all scripts in the primary DOM run in continuous document order. TODO: Think about, would we ever need to cancel the requestAnimationFrame? ",
							"code": "\t_schedule() {\n\t\tTick.cancelFrame(this._scheduleid);\n\t\tthis._scheduleid = Tick.nextFrame(() => this._onschedule());\n\t}\n"
						},
						{
							"line": 217,
							"tags": [],
							"tabs": "",
							"desc": "\n\n",
							"code": "\t_onschedule() {\n\t\tif (this.running && this._runnable()) {\n\t\t\tthis.run(...this._params);\n\t\t}\n\t}\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 227,
							"tags": [
								{
									"name": "@param",
									"type": "{Spirit}",
									"desc": "spirit",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Element|ShadowRoot}",
									"desc": "elm",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Out}",
									"desc": "oldout",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Out}",
									"desc": "newout",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "resolve",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "reject",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Out}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Compare current to previous rendering and update the DOM. ",
							"code": "function render(spirit, elm, oldout, newout, resolve) {\n\tconst $id = spirit.$id;\n\tconst dif = diff(elm, $id, newout, oldout);\n\tconst log = dif.length ? patch(elm, $id, dif) : {};\n\treport(spirit, log);\n\treturn newout;\n}\n"
						},
						{
							"line": 244,
							"tags": [
								{
									"name": "@param",
									"type": "{Spirit}",
									"desc": "spirit",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "log",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "resolve",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Feedback to user. ",
							"code": "function report(spirit, log) {\n\tlog.first = !spirit.life.rendered;\n\tspirit.life.rendered = true;\n\tspirit.onrun(log);\n}\n"
						},
						{
							"line": 255,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "model",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "[propname];",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Error}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function updateerror(model, propname) {\n\tconst typename = model.constructor.name;\n\tconst offender = typename + (propname ? `.${propname}` : '');\n\treturn new Error(\n\t\t`Don't update the ${offender} while the script is being evaluated.` +\n\t\t\t` The update will cause the rendering to run in an endless loop.`\n\t);\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/gui-plugins/src/shadow/ShadowPlugin.js": {
			"title": "ShadowPlugin",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import ScriptPlugin from '../script/ScriptPlugin';\nimport { Tick, chained } from '@dataplastique/util';\nimport { reboot } from '@dataplastique/gui';\nimport { observe } from './SlotObserver';\n"
						},
						{
							"line": 4,
							"tags": [],
							"tabs": "\t",
							"desc": "Shadow DOM scripts and queries. ",
							"code": "export default class ShadowPlugin extends ScriptPlugin {\n"
						},
						{
							"line": 8,
							"tags": [
								{
									"name": "@returns",
									"type": "{ShadowRoot}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Returns and potentially creates the `shadowRoot`. ",
							"code": "\troot() {\n\t\treturn (\n\t\t\tthis.element.shadowRoot ||\n\t\t\treboot(this.element.attachShadow({ mode: 'open' }))\n\t\t);\n\t}\n"
						},
						{
							"line": 18,
							"tags": [
								{
									"name": "@param",
									"type": "{Function|ISlotHandler}",
									"desc": "handler",
									"text": "- not used just yet!!!"
								},
								{
									"name": "@returns",
									"type": "{this}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Add callback or handler for fake slot changes. TODO: support function callbacks! ",
							"code": "\t@chained\n\tonslot(handler = this.spirit) {\n\t\tthis._observes = true; \n\t}\n"
						},
						{
							"line": 28,
							"tags": [],
							"tabs": "\t",
							"desc": "Disconnect potential `slotchange` observer. ",
							"code": "\tondestruct() {\n\t\tsuper.ondestruct();\n\t\tthis._unobserve && this._unobserve();\n\t}\n"
						},
						{
							"line": 35,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "selector",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Element}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "TODO: This thing should implement several query methods known from the \n{DOMPlugin} and it should in fact use this plugin to implement them! ",
							"code": "\tq(selector) {\n\t\treturn this.root().querySelector(selector);\n\t}\n"
						},
						{
							"line": 44,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "selector",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<Element>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\tqall(selector) {\n\t\treturn Array.from(this.root().querySelectorAll(selector));\n\t}\n"
						},
						{
							"line": 51,
							"tags": [
								{
									"name": "@overrides",
									"type": "{ScriptPlugin#one}",
									"desc": "",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{this}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "If initial rendering, run the virtual `slotchange` scenario. This is done async for parity with real `slotchange` events. TODO: The tick should somehow confirm plugin not destructed! TODO: Account for slot elm added later + `onslot` called later ",
							"code": "\tone(...args) {\n\t\tconst init = !this.spirit.life.rendered;\n\t\tconst that = super.one(...args);\n\t\tif (init && this.spirit.life.rendered) {\n\t\t\tTick.next(() => {\n\t\t\t\tif (this._observes) {\n\t\t\t\t\tthis._unobserve = observe(this);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn that;\n\t}\n"
						}
					]
				},
				{
					"title": "Private ",
					"tabs": "\t",
					"sections": [
						{
							"line": 72,
							"tags": [
								{
									"name": "@type",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\t_observes = false;\n"
						},
						{
							"line": 76,
							"tags": [
								{
									"name": "@type",
									"type": "{Function}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "\t_unobserve = null;\n}\n"
						}
					]
				},
				{
					"title": "Backup ",
					"tabs": "",
					"sections": [
						{
							"line": 82,
							"tags": [
								{
									"name": "@param",
									"type": "{ShadowPlugin}",
									"desc": "plugin",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "To avoid the FOUC, perhaps stay hidden until all stylesheets are loaded? This can of course be avoided with inline `style` tags, but CSP policy makes them non-trivial to use (and would also not be cached by agent). ",
							"code": "function perhapsdothis(plugin) {\n\tconst done = () => void 0; \n\tconst list = plugin.qall('link[rel=stylesheet]');\n\tlist.length ? Promise.all(list.map(loaded)).then(done) : done();\n}\n"
						},
						{
							"line": 93,
							"tags": [
								{
									"name": "@param",
									"type": "{HTMLLinkElement}",
									"desc": "link",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Promise}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Promise to be resolved whenever that stylesheet is loaded. TODO: Perhaps check if it already could be loaded. ",
							"code": "function loaded(link) {\n\treturn new Promise(resolve => {\n\t\tlink.addEventListener('load', resolve);\n\t});\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/gui-plugins/src/shadow/Slot.js": {
			"title": "Slot",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "\t",
							"desc": "\n\n",
							"code": "export default class Slot {\n"
						},
						{
							"line": 4,
							"tags": [
								{
									"name": "@type",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Slot name. ",
							"code": "\tname = '';\n"
						},
						{
							"line": 9,
							"tags": [
								{
									"name": "@type",
									"type": "{Array<Element>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Nodes assigned to slot. ",
							"code": "\tnodes = null;\n"
						},
						{
							"line": 14,
							"tags": [
								{
									"name": "@param",
									"type": "{HTMLSlotElement}",
									"desc": "slot",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{HTMLElement}",
									"desc": "scope",
									"text": "- the spirits own (root) element"
								}
							],
							"tabs": "",
							"desc": "",
							"code": "\tconstructor(slot, scope) {\n\t\tObject.assign(this, {\n\t\t\tnodes: assignedNodes(slot, scope),\n\t\t\tname: slot.name\n\t\t});\n\t}\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 25,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "const connected = node => node.isConnected;\nconst camelcase = name => name.replace(/-([a-z])/g, g => g[1].toUpperCase());\n"
						},
						{
							"line": 28,
							"tags": [
								{
									"name": "@param",
									"type": "{HTMLSlotElement}",
									"desc": "slot",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "scope",
									"text": "- the spirits own (root) element"
								},
								{
									"name": "@returns",
									"type": "{Array<Element>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Of course, `slot.assignedNodes()` is also randomly empty in Chrome for unknown reasons so we will throw in a patch for that as well :/ ",
							"code": "function assignedNodes(slot, scope) {\n\treturn [...scope.children].filter(child => {\n\t\treturn !slot.name || child.slot === name;\n\t});\n}\n"
						},
						{
							"line": 40,
							"tags": [
								{
									"name": "@see",
									"type": "https://github.com/nteract/vdom/blob/master/docs/spec.md",
									"desc": "",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Node}",
									"desc": "node",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "NOT USED: Perhaps use this to expose some kind of VDOM along with normal DOM? ",
							"code": "function vdom({ nodeType, localName, childNodes, attributes, data }) {\n\tswitch (nodeType) {\n\t\tcase Node.TEXT_NODE:\n\t\t\treturn data;\n\t\tcase Node.ELEMENT_NODE:\n\t\t\treturn {\n\t\t\t\ttagName: localName,\n\t\t\t\telement: arguments[0],\n\t\t\t\tchildren: Array.from(childNodes).map(vdom),\n\t\t\t\tattributes: Array.from(attributes).reduce((map, { name, value }) => {\n\t\t\t\t\treturn Object.assign(map, {\n\t\t\t\t\t\t[camelcase(name)]: value\n\t\t\t\t\t});\n\t\t\t\t}, {})\n\t\t\t};\n\t}\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/gui-plugins/src/shadow/SlotObserver.js": {
			"title": "SlotObserver",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import Slot from './Slot';\n"
						},
						{
							"line": 1,
							"tags": [
								{
									"name": "@filedesc",
									"type": "",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "There are numerous problems with the specification and implementation of the `slotchange` event in various browsers, so we'll roll our own implementation via Mutation Observers :/ ",
							"code": ""
						},
						{
							"line": 7,
							"tags": [
								{
									"name": "@see",
									"type": "https://github.com/whatwg/dom/issues/447",
									"desc": "",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{ShadowPlugin}",
									"desc": "plugin",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Function}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Trigger fake `slotchange` callback initially and watch for future updates. The real slotchange would fire at around when the `slot` element is first rendered in the Shadow DOM but that doesn't quite live up to expectations. ",
							"code": "export function observe(plugin) {\n\tconst [slots, scope] = [new Set(), plugin.element];\n\ttriggerslots(slots, plugin, [...scope.children]);\n\treturn (observer => observer.disconnect())(\n\t\tgetobserver(scope, record => {\n\t\t\thandlemutation(slots, plugin, record);\n\t\t})\n\t);\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 25,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "node",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "handle",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{MutationObserver}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get MutationObserver for element associated to the plugins spirit. We added support for attribute changes as a means to trigger the \n`slotchange` events since the real spec would not account for this. ",
							"code": "function getobserver(node, handle) {\n\tconst obs = new MutationObserver(records => {\n\t\trecords.forEach(handle);\n\t});\n\tobs.observe(node, {\n\t\tattributes: true,\n\t\tchildList: true,\n\t\tsubtree: true\n\t});\n\treturn obs;\n}\n"
						},
						{
							"line": 44,
							"tags": [
								{
									"name": "@param",
									"type": "{Set<HTMLSlotElement>}",
									"desc": "slots",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{ShadowPlugin}",
									"desc": "plugin",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{MutationRecord}",
									"desc": "record",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Handle mutations to support virtual `slotchange`. ",
							"code": "function handlemutation(slots, plugin, record) {\n\tconst { type, target, addedNodes, removedNodes } = record;\n\tconst atts = type === 'attributes';\n\tconst elms = atts ? [target] : [...addedNodes, ...removedNodes];\n\ttriggerslots(slots, plugin, elms);\n}\n"
						},
						{
							"line": 56,
							"tags": [
								{
									"name": "@param",
									"type": "{Set<HTMLSlotElement>}",
									"desc": "slots",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{ShadowPlugin}",
									"desc": "plugin",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<Element>}",
									"desc": "elms",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Trigger fake `slotchange` event for mutated (or newly initialized) DOM. Not sure what the spec would say, but we'll introduce the convention that the unslotted DOM is always registered for a `slot` element with no `name` attribute (if of course one such is found in the Shadow DOM). ",
							"code": "function triggerslots(slots, plugin, elms) {\n\tconst root = plugin.element;\n\tconst isok = elm => elm.parentNode === root;\n\tconst slot = elm => elm.hasAttribute('slot');\n\tconst anon = plugin.q('slot:not([name])');\n\tconst rest = elms.filter(isok).filter(slot);\n\tanon && registerchange(slots, plugin, anon);\n\trest.length &&\n\t\tmatchingslots(plugin, rest).forEach(slot => {\n\t\t\tregisterchange(slots, plugin, slot);\n\t\t});\n}\n"
						},
						{
							"line": 77,
							"tags": [
								{
									"name": "@param",
									"type": "{ShadowPlugin}",
									"desc": "plugin",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<Element>}",
									"desc": "elms",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<HTMLSlotElement>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Lookup `slot` elements in Shadow DOM to match mutated nodes in local DOM. ",
							"code": "function matchingslots(plugin, elms) {\n\tconst nuked = node => !plugin.element.contains(node);\n\tconst named = (names, { slot }) => names.concat(slot ? [slot] : []);\n\tconst query = name => plugin.q(`slot[name=${name}]`);\n\tconst exist = slot => !!slot;\n\treturn [...elms.reduce(named, []).map(query)].filter(exist);\n}\n"
						},
						{
							"line": 90,
							"tags": [
								{
									"name": "@param",
									"type": "{Set<HTMLSlotElement>}",
									"desc": "slots",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{ShadowPlugin}",
									"desc": "plugin",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{HTMLSlotElement}",
									"desc": "slot",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Register mutation in local DOM that matches a slot in Shadow DOM. TODO: `timeOut` takes too long, perhaps, but be careful with microscheduling since the purpose here is to collect multiple changes that might also have been microscheduled (by Angular, typically, since it uses microscheduling for almost anything). TODO: At least use the {TickPlugin} instead of `timeOut` to confirm that the plugin is not destructed (and make TickPlugin check that!) ",
							"code": "function registerchange(slots, plugin, slot) {\n\tconst was = slots.size;\n\tslots.add(slot);\n\tif (was === 0 && slots.size === 1) {\n\t\tschedule(slots, plugin);\n\t}\n}\n"
						},
						{
							"line": 109,
							"tags": [
								{
									"name": "@param",
									"type": "{Set<HTMLSlotElement>}",
									"desc": "slots",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{ShadowPlugin}",
									"desc": "plugin",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Schedule to callback all accumulated slot update notifications. TODO: `timeOut` might take too long, perhaps, but be careful with microscheduling since the purpose here is to collect multiple changes that might also have been microscheduled (by Angular, typically, since it uses microscheduling for almost anything). TODO: Confirm that the spirit is not destructed! ",
							"code": "function schedule(slots, { spirit, element }) {\n\tconst callback = slot => spirit.onslot(new Slot(slot, element));\n\tsetTimeout(() => {\n\t\tslots.forEach(callback);\n\t\tslots.clear();\n\t});\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/gui-plugins/src/tick/TickPlugin.js": {
			"title": "TickPlugin",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import TrackerPlugin from '../TrackerPlugin';\nimport { Tick } from '@dataplastique/util';\nimport { chained } from '@dataplastique/util';\nimport { asarray } from '@dataplastique/util';\n"
						},
						{
							"line": 4,
							"tags": [],
							"tabs": "\t",
							"desc": "Task scheduling and time micro management. ",
							"code": "export default class TickPlugin extends TrackerPlugin {\n"
						},
						{
							"line": 8,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Array<string>}",
									"desc": "arg",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "[handler]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{this}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Add one or more tick handlers. ",
							"code": "\t@chained\n\ton(type, handler = this.spirit) {\n\t\tasarray(type, t => {\n\t\t\tif (this._addchecks(t, [handler])) {\n\t\t\t\tTick.add(t, handler);\n\t\t\t}\n\t\t});\n\t}\n"
						},
						{
							"line": 22,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Array<string>}",
									"desc": "arg",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "[handler]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{this}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Add one or more tick handlers. ",
							"code": "\t@chained\n\toff(type, handler = this.spirit) {\n\t\tasarray(type, t => {\n\t\t\tif (this._removechecks(t, [handler])) {\n\t\t\t\tTick.remove(t, handler);\n\t\t\t}\n\t\t});\n\t}\n"
						},
						{
							"line": 36,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Array<string>}",
									"desc": "arg",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "[handler]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{this}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Add one or more self-removing tick handlers. TODO: Think about this for a while. ",
							"code": "\t@chained\n\tone(type, handler = this.spirit) {\n\t\tasarray(type, t => {\n\t\t\tthis._removechecks(t, [handler]);\n\t\t\tTick.remove(t, handler).one(t, handler);\n\t\t});\n\t}\n"
						},
						{
							"line": 50,
							"tags": [
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "action",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Execute action in next available tick. We don't return anything because we'd like at one point to make the tick cancellable and that actually is supported here in the browser (not in Node). UPDATE: This is actually supported now in Node via `setImmediate` ",
							"code": "\tnext(action) {\n\t\tTick.next(action);\n\t}\n"
						},
						{
							"line": 60,
							"tags": [
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "action",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{number}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Execute action in next animation frame. ",
							"code": "\tnextFrame(action) {\n\t\treturn Tick.nextFrame(action);\n\t}\n"
						},
						{
							"line": 68,
							"tags": [
								{
									"name": "@param",
									"type": "{number}",
									"desc": "n",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{this}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Cancel scheduled animation frame. ",
							"code": "\t@chained\n\tcancelFrame(n) {\n\t\tTick.cancelFrame(n);\n\t}\n"
						},
						{
							"line": 77,
							"tags": [
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "action",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{number}",
									"desc": "time",
									"text": "in milliseconds"
								},
								{
									"name": "@returns",
									"type": "{number}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Schedule timeout. ",
							"code": "\ttime(action, time) {\n\t\treturn Tick.time(action, time);\n\t}\n"
						},
						{
							"line": 86,
							"tags": [
								{
									"name": "@param",
									"type": "{number}",
									"desc": "n",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Cancel scheduled timeout. ",
							"code": "\t@chained\n\tcancelTime(n) {\n\t\tTick.cancelTime(n);\n\t}\n"
						},
						{
							"line": 94,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "type",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Start tick of type (if not already started). ",
							"code": "\t@chained\n\tstart(type) {\n\t\tTick.start(type);\n\t}\n"
						},
						{
							"line": 102,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "type",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Stop tick of type. This will stop the tick for all listeners, so perhaps you're looking for `remove`? ",
							"code": "\t@chained\n\tstop(type) {\n\t\tTick.stop(type);\n\t}\n"
						},
						{
							"line": 111,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{number}",
									"desc": "time",
									"text": "Milliseconds (omit for nextTick)"
								},
								{
									"name": "@returns",
									"type": "{this}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Dispatch tick after given time. ",
							"code": "\t@chained\n\tdispatch(type, time) {\n\t\tTick.dispatch(type, time);\n\t}\n"
						}
					]
				},
				{
					"title": "Private ",
					"tabs": "\t",
					"sections": [
						{
							"line": 122,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<object>}",
									"desc": "checks",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Abort ticks when plugin disposes. ",
							"code": "\t_cleanupchecks(type, checks) {\n\t\tTick.remove(type, checks[0]);\n\t}\n}\n"
						},
						{
							"line": 131,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "thisp",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: This will not work now because arrow functions hide the `thisp` :/ Let's not attempt to invoke any method that applies the `this` keyword to spirits (or plugins or models) that have been marked as disposed. ",
							"code": "function safeapply(thisp) {\n\tif ('disposed' in thisp) {\n\t\treturn !thisp.disposed;\n\t} else {\n\t\treturn true;\n\t}\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/gui/src/Config.js": {
			"title": "Config",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { Model } from '@dataplastique/edb';\nimport { ConfigurationError } from '@dataplastique/util';\nlet config = null;\n"
						},
						{
							"line": 3,
							"tags": [],
							"tabs": "\t",
							"desc": "TODO: Figure out a way to make this thing universally accessible! General configuration via `boot(options)`. We'll define this as a Model in orer to automatically catch any typos and invalid properties. ",
							"code": "export default class Config extends Model {\n"
						},
						{
							"line": 9,
							"tags": [
								{
									"name": "@param",
									"type": "{IMap}",
									"desc": "map",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Configuration interface. The desciption of these props are given down below. ",
							"code": "\tstatic model(map) {\n\t\treturn {\n\t\t\tdebug: Boolean, \n\t\t\txhtml: Boolean \n\t\t};\n\t}\n"
						},
						{
							"line": 20,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "object",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Initialize configuration. ",
							"code": "\tstatic init(object) {\n\t\tif (config) {\n\t\t\tthrow new ConfigurationError('Configuration dysfunction');\n\t\t} else {\n\t\t\tconfig = new Config(object);\n\t\t}\n\t}\n"
						},
						{
							"line": 31,
							"tags": [
								{
									"name": "@type",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Development mode enabled? Rarely the case in production, that is. ",
							"code": "\tstatic get debug() {\n\t\treturn config.debug;\n\t}\n"
						},
						{
							"line": 38,
							"tags": [
								{
									"name": "@type",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Expect all EDBML scripts to return well-formed XHTML markup? This has no practical implications unless `debug` is enabled. ",
							"code": "\tstatic get xhtml() {\n\t\treturn config.xhtml;\n\t}\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/gui/src/Const.js": {
			"title": "Const",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "export const LIFE_POSSESS = 'gui-life-possess';\nexport const LIFE_ATTACH = 'gui-life-attach';\nexport const LIFE_ENTER = 'gui-life-enter';\nexport const LIFE_READY = 'gui-life-ready';\nexport const LIFE_ASYNC = 'gui-life-async';\nexport const LIFE_DETACH = 'gui-life-detach';\nexport const LIFE_EXORCIZE = 'gui-life-exorcize';\nexport const CRAWLER_ACTION = 'gui-crawler-action';\nexport const CRAWLER_DETACH = 'gui-crawler-detach';\nexport const CRAWLER_SPIRITUALIZE = 'gui-crawler-spiritualize';\nexport const CRAWLER_MATERIALIZE = 'gui-crawler-materialize';\nexport const LIFE_VISIBLE = 'gui-life-visible';\nexport const LIFE_INVISIBLE = 'gui-life-invisible';\nexport const BROADCAST_ACCESS = 'edb-broadcast-access';\nexport const CLASS_HIDDEN = 'gui-hidden';\nexport const DATA_PLASTIQUE_ID = 'data-plastique-id';\nexport const EVENT_ATTRIBUTE_CHANGED = 'dataplastique-attribute-change';\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/gui/src/Cycle.js": {
			"title": "Cycle",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import * as Store from './Store';\nimport {\n\tLIFE_ATTACH,\n\tLIFE_ENTER,\n\tLIFE_READY,\n\tLIFE_ASYNC,\n\tLIFE_DETACH,\n\tLIFE_EXORCIZE\n} from './Const';\n"
						},
						{
							"line": 9,
							"tags": [
								{
									"name": "@classdesc",
									"type": "",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Attempting to manage the spirit lifecycle as much as possible in a single file. ",
							"code": ""
						},
						{
							"line": 13,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Class<Spirit>}",
									"desc": "SpiritC",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Spirit}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Construct spirit for element. Note that the spirits `onconstruct` call will be performed by the {Model} class that the spirit extends from. ",
							"code": "export function possess(elm, SpiritC) {\n\tconst spirit = register(elm, SpiritC);\n\treturn hackydecorator(spirit, SpiritC);\n}\n"
						},
						{
							"line": 24,
							"tags": [
								{
									"name": "@param",
									"type": "{Spirit}",
									"desc": "spirit",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Spirit}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Attach spirit for element. ",
							"code": "export function attach(spirit) {\n\tif (!spirit.life.attached) {\n\t\tspirit.life.attached = true;\n\t\tspirit.onattach();\n\t\tspirit.life.dispatch(LIFE_ATTACH);\n\t\tif (spirit.johnson && spirit.johnson.onattach) {\n\t\t\tspirit.johnson.onattach();\n\t\t}\n\t}\n\treturn spirit;\n}\n"
						},
						{
							"line": 40,
							"tags": [
								{
									"name": "@param",
									"type": "{Spirit}",
									"desc": "spirit",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Spirit}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Enter spirit for element (attach for the first time). ",
							"code": "export function enter(spirit) {\n\tif (!spirit.life.entered) {\n\t\tspirit.life.entered = true;\n\t\tspirit.onenter();\n\t\tspirit.life.dispatch(LIFE_ENTER);\n\t\tif (spirit.johnson && spirit.johnson.onenter) {\n\t\t\tspirit.johnson.onenter();\n\t\t}\n\t}\n\treturn spirit;\n}\n"
						},
						{
							"line": 56,
							"tags": [
								{
									"name": "@param",
									"type": "{Spirit}",
									"desc": "spirit",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Spirit}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Ready spirit for element. ",
							"code": "export function ready(spirit) {\n\tif (!spirit.life.ready) {\n\t\tspirit.life.ready = true;\n\t\tspirit.onready();\n\t\tspirit.life.dispatch(LIFE_READY);\n\t\tStore.applyDeferred(spirit);\n\t}\n\treturn spirit;\n}\n"
						},
						{
							"line": 70,
							"tags": [],
							"tabs": "",
							"desc": "TODO! ",
							"code": "export function async() {\n}\n"
						},
						{
							"line": 75,
							"tags": [
								{
									"name": "@param",
									"type": "{Spirit}",
									"desc": "spirit",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Spirit}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Detach spirit for element. This will also mark the spirit for destruction unless it is reinserted more or less immediately. ",
							"code": "export function detach(spirit) {\n\tif (spirit.life.attached) {\n\t\tspirit.life.attached = false;\n\t\tspirit.ondetach();\n\t\tspirit.life.dispatch(LIFE_DETACH);\n\t}\n\treturn spirit;\n}\n"
						},
						{
							"line": 89,
							"tags": [],
							"tabs": "",
							"desc": "TODO! ",
							"code": "export function exorcize() {\n\tconsole.warn('TODO: exorcize');\n}\n"
						},
						{
							"line": 95,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "oldval",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "newval",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Attribute changed. We'll let the {AttPlugin} handle that so that it can feel more in charge of things related to DOM attributes. ",
							"code": "export function onatt(elm, name, oldval, newval) {\n\tconsole.error('TODO');\n}\n"
						},
						{
							"line": 106,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: MOTE TO STORE! Called by the {Store} when a headless spirit gets unassigned from the element. Removing the `data-plastique-id` to make this fact apparent. ",
							"code": "export function ondispose(elm) {\n\tStore.del(elm);\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 116,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Class<Spirit>}",
									"desc": "SpiritC",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Spirit}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Newup spirit and register to element. ",
							"code": "function register(elm, SpiritC) {\n\treturn Store.set(\n\t\telm,\n\t\tnew SpiritC({\n\t\t\telement: elm\n\t\t})\n\t);\n}\n"
						},
						{
							"line": 130,
							"tags": [
								{
									"name": "@param",
									"type": "{Spirit}",
									"desc": "spirit",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Class<Spirit>}",
									"desc": "SpiritC",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Spirit}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Run sketchy setup to support for the `@attribute` decorator. TODO: Some kind of global lifecycle hook system so that we don't have to hack support for the `@attribute` decorator in this file. TODO: Setters should eval `onconstruct`, methods at `onready`!!! ",
							"code": "function hackydecorator(spirit, SpiritC) {\n\tconst atts = SpiritC[Symbol.for('@dataplastique/attributes')];\n\tif (atts) {\n\t\tatts.forEach((desc, name) => {\n\t\t\tif (spirit.element.hasAttribute(name)) {\n\t\t\t\tconst value = spirit.element.getAttribute(name);\n\t\t\t\tdesc.set\n\t\t\t\t\t? desc.set.call(spirit, value)\n\t\t\t\t\t: desc.value.call(spirit, value);\n\t\t\t}\n\t\t});\n\t}\n\treturn spirit;\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/gui/src/Deco.js": {
			"title": "Deco",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import * as Guide from './Guide';\n// @channeling decorator .......................................................\n"
						},
						{
							"line": 2,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "tag",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Class<Spirit>}",
									"desc": "[SpiritC]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Function}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Channeling the spirit. Optionally to be used as a class decorator. ",
							"code": "export function channeling(tag, SpiritC) {\n\tconst decorates = arguments.length === 1;\n\tif (decorates) {\n\t\treturn function decorated(SpiritC) {\n\t\t\tGuide.channel(tag, SpiritC);\n\t\t};\n\t} else {\n\t\tGuide.channel(tag, SpiritC);\n\t}\n}\n// @attribute decorator ........................................................\n"
						},
						{
							"line": 19,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Decorate method or accessor. ",
							"code": "export function attribute(name) {\n\treturn (target, key, desc) =>\n\t\tdesc.set ? accessor(target, name, desc) : method(target, name, desc);\n}\n"
						},
						{
							"line": 28,
							"tags": [
								{
									"name": "@param",
									"type": "{Class}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "desc",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Decorate method. Note that we will not invoke the method body if and when the first argument (corresponding to the attribute value) will not result in a changed attribute value. Notice also that when used as a getter, ie. when called without arguments, the return type will be cast to an inferred type so that the attribute value \"true\" will returned as the boolean `true`. TODO: Static methods in the {AttributePlugin} so that wo don't new it up! TODO: Decorate *validation* of primitive `val` value, no objects or arrays! ",
							"code": "function method(target, name, desc) {\n\treturn stamped(target, name, {\n\t\tconfigurable: false,\n\t\tvalue: function(val) {\n\t\t\tlistener(this, this.element, desc);\n\t\t\tif (arguments.length) {\n\t\t\t\tif (val !== this.att.get(val)) {\n\t\t\t\t\tthis.att.set(name, val);\n\t\t\t\t\tdesc.value.apply(this, arguments);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn this.att.get(name); \n\t\t\t}\n\t\t}\n\t});\n}\n"
						},
						{
							"line": 57,
							"tags": [
								{
									"name": "@param",
									"type": "{Class}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "desc",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Decorate accessor. Note that we will not invoke the `set` method if and when the proveded argument will not result in a changed attribute value. Notice also that the result of the `get` method will be cast to an inferred type so that the attribute value \"true\" will returned as the boolean value `true`. ",
							"code": "function accessor(target, name, desc) {\n\treturn stamped(target, name, {\n\t\tconfigurable: false,\n\t\tget: function() {\n\t\t\tlistener(this, this.element, desc);\n\t\t\treturn this.att.get(name); \n\t\t},\n\t\tset: function(val) {\n\t\t\tthis.att.set(name, val);\n\t\t\tif (val !== this.att.get(val)) {\n\t\t\t\tdesc.set.call(this, val);\n\t\t\t}\n\t\t}\n\t});\n}\n"
						},
						{
							"line": 82,
							"tags": [
								{
									"name": "@param",
									"type": "{Proto}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "desc",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Stamp the special attributes onto the Spirit constructor so that each instance can evaluate them during initialization. Please see {Cycle}. ",
							"code": "function stamped(target, name, desc) {\n\tconst proto = target.constructor;\n\tconst stamp = Symbol.for('@dataplastique/attributes');\n\tproto[stamp] = proto[stamp] || new Map();\n\tproto[stamp].set(name, desc);\n\treturn desc;\n}\n"
						},
						{
							"line": 97,
							"tags": [
								{
									"name": "@param",
									"type": "{Spirit}",
									"desc": "spirit",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "desc",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "When the accessor is first accessed, or when the method is first called, add event listener to invoke the accessor / method whenever the attribute changes. TODO: Memory leak!!! Remove listener upon disposal via the {EventPlugin} ",
							"code": "function listener(spirit, elm, desc) {\n\tlistener.done = listener.done || Symbol('done');\n\tif (!elm[listener.done]) {\n\t\telm[listener.done] = true;\n\t\telm.addEventListener('dataplastique-attribute-change', e => {\n\t\t\tif (e.detail.newvalue !== undefined) {\n\t\t\t\t(desc.set || desc.value).call(spirit, e.detail.newvalue);\n\t\t\t}\n\t\t});\n\t}\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/gui/src/Guide.js": {
			"title": "Guide",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { has as hasspirit, get as getspirit } from './Store';\nimport { possess, attach, enter, ready, detach, exorcize } from './Cycle';\nimport { DATA_PLASTIQUE_ID, EVENT_ATTRIBUTE_CHANGED } from './Const';\n"
						},
						{
							"line": 3,
							"tags": [
								{
									"name": "@type",
									"type": "{Map<string,Class<Spirit>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "const channelings = new Map();\n"
						},
						{
							"line": 7,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "tag",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Class<Spirit>}",
									"desc": "SpiritC",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export function channel(tag, SpiritC) {\n\tchannelings.set(tag, SpiritC);\n}\n"
						},
						{
							"line": 14,
							"tags": [
								{
									"name": "@param",
									"type": "{Class<Spirit>}",
									"desc": "SpiritC",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Spirit}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: Spawn with parameter tagname (and assign the `is` attribute). ",
							"code": "export function spawn(SpiritC) {\n\tconst tag = gettag(SpiritC);\n\tif (tag) {\n\t\treturn possess(document.createElement(tag), SpiritC);\n\t} else {\n\t\tthrow new Error(`${SpiritC.name} has not been channeled`);\n\t}\n}\n"
						},
						{
							"line": 27,
							"tags": [
								{
									"name": "@param",
									"type": "{Node}",
									"desc": "root",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Node}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Boot the shebang. ",
							"code": "export function bootstrap(root = document) {\n\tstartobserver(root);\n\ttreeupdate([root]);\n\treturn root;\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 37,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "const iselm = node => node.nodeType === Node.ELEMENT_NODE,\n\tentries = () => Array.from(channelings.entries()),\n\tspecialtag = elm => elm.localName.includes('-'),\n\tspecial = elm => specialtag(elm) || elm.hasAttribute('is'),\n\tchanneltag = elm => elm.getAttribute('is') || elm.localName,\n\tchanneled = elm => iselm(elm) && special(elm) && haschanneling(elm),\n\thaschanneling = elm => channelings.has(channeltag(elm)),\n\tgetchanneling = elm => channelings.get(channeltag(elm)),\n\telements = nodes => Array.from(nodes).filter(iselm),\n\theadless = added => spirit => !added.includes(spirit.element),\n\tpossession = elm => getspirit(elm) || possess(elm, getchanneling(elm));\n"
						},
						{
							"line": 49,
							"tags": [
								{
									"name": "@param",
									"type": "{Node}",
									"desc": "node",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function startobserver(node) {\n\tconst handler = list => list.forEach(handle);\n\tnew MutationObserver(handler).observe(node, {\n\t\tattributeOldValue: true,\n\t\tattributes: true,\n\t\tchildList: true,\n\t\tsubtree: true\n\t});\n}\n"
						},
						{
							"line": 61,
							"tags": [
								{
									"name": "@param",
									"type": "{MutationRecord}",
									"desc": "record",
									"text": ""
								},
								{
									"name": "@using",
									"type": "{NodeList}",
									"desc": "",
									"text": ""
								},
								{
									"name": "@using",
									"type": "{NodeList}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Handle mutations. ",
							"code": "function handle({\n\ttype,\n\ttarget,\n\taddedNodes,\n\tremovedNodes,\n\tattributeName,\n\toldValue\n}) {\n\ttype === 'childList'\n\t\t? treeupdate(elements(addedNodes), elements(removedNodes))\n\t\t: attsupdate(target, attributeName, oldValue);\n}\n"
						},
						{
							"line": 79,
							"tags": [
								{
									"name": "@param",
									"type": "{Array<Element>}",
									"desc": "added",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<Element>}",
									"desc": "[removed]",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Exorcize removed spirits and spiritualize added elements. ",
							"code": "function treeupdate(added, removed = []) {\n\tcollectall(removed)\n\t\t.filter(hasspirit)\n\t\t.map(getspirit)\n\t\t.map(detach)\n\t\t.filter(headless(added))\n\t\t.forEach(exorcize);\n\tcollectall(added)\n\t\t.map(possession)\n\t\t.map(attach)\n\t\t.map(enter)\n\t\t.reverse()\n\t\t.map(ready);\n}\n"
						},
						{
							"line": 98,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "oldval",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "newval",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Attribute changes are interesting for entities that will evolve much later in the ecosystem and so we will avoid hard and circular dependencies here by dispatching the attribute update information via a regular DOM event. ",
							"code": "function attsupdate(target, name, oldval, newval = target.getAttribute(name)) {\n\tif (hasspirit(target) && name !== DATA_PLASTIQUE_ID) {\n\t\ttarget.dispatchEvent(\n\t\t\tnew CustomEvent(EVENT_ATTRIBUTE_CHANGED, {\n\t\t\t\tdetail: { name, oldval, newval },\n\t\t\t\tbubbles: false\n\t\t\t})\n\t\t);\n\t}\n}\n"
						},
						{
							"line": 117,
							"tags": [
								{
									"name": "@param",
									"type": "{Array<Element>}",
									"desc": "elms",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<Element>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Collect all elements with existing or potential spirits. ",
							"code": "function collectall(elms) {\n\treturn elms.reduce((all, elm) => all.concat(collect(elm)), []);\n}\n"
						},
						{
							"line": 125,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<Spirit>}",
									"desc": "[all]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<Spirit>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Find in subtree all elements that should be or could already be possessed. ",
							"code": "function collect(elm, all = []) {\n\tif (elm) {\n\t\tchanneled(elm) ? all.push(elm) : void 0;\n\t\tcollect(elm.firstElementChild, all);\n\t\tcollect(elm.nextElementSibling, all);\n\t}\n\treturn all;\n}\n"
						},
						{
							"line": 139,
							"tags": [
								{
									"name": "@param",
									"type": "{Class<Spirit>}",
									"desc": "SpiritC",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get tag for possessor (get key for value). ",
							"code": "function gettag(SpiritC) {\n\treturn entries().reduce((result, [tag, klass]) => {\n\t\treturn result || (klass === SpiritC ? tag : null);\n\t}, null);\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/gui/src/Spirit.js": {
			"title": "Spirit",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import * as Guide from './Guide';\nimport * as Store from './Store';\nimport { Model } from '@dataplastique/edb';\nimport { isElement, isString, typeOf } from '@dataplastique/util';\n"
						},
						{
							"line": 4,
							"tags": [
								{
									"name": "@extends",
									"type": "{Model}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "That's the spirit. TODO: `uniget` and `uniset` should also be documented in here somehow, these static methods are currently only documented in the {CSSPlugin}. ",
							"code": "export default class Spirit extends Model {\n"
						},
						{
							"line": 11,
							"tags": [
								{
									"name": "@type",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Identification. ",
							"code": "\tget isSpirit() {\n\t\treturn true;\n\t}\n"
						},
						{
							"line": 18,
							"tags": [
								{
									"name": "@type",
									"type": "{String}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Identification. ",
							"code": "\tget [Symbol.toStringTag]() {\n\t\treturn 'Spirit';\n\t}\n"
						},
						{
							"line": 25,
							"tags": [
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Identification. ",
							"code": "\ttoString() {\n\t\treturn `[spirit ${this.constructor.name}]`;\n\t}\n"
						}
					]
				},
				{
					"title": "Lifecycle ",
					"tabs": "\t",
					"sections": [
						{
							"line": 33,
							"tags": [],
							"tabs": "\t",
							"desc": "Note that the element may not be positioned in the DOM at this point. ",
							"code": "\tonconstruct() {}\n"
						},
						{
							"line": 37,
							"tags": [],
							"tabs": "\t",
							"desc": "\n`onenter` gets called when the spirit element is first encounted in the page DOM. This is only called once in the lifecycle of a spirit (unlike `attach`, see below). ",
							"code": "\tonenter() {}\n"
						},
						{
							"line": 43,
							"tags": [],
							"tabs": "\t",
							"desc": "\n`onattach` gets called whenever \n\n\n1. The spirit element is already in DOM when the page loads \n2. The spirit element is later on attached to the main DOM ",
							"code": "\tonattach() {}\n"
						},
						{
							"line": 50,
							"tags": [],
							"tabs": "\t",
							"desc": "\n`onready` gets called (only once) when all descendant spirits are attached and ready. From a DOM tree perspective, this fires in reverse order, innermost first. ",
							"code": "\tonready() {}\n"
						},
						{
							"line": 56,
							"tags": [],
							"tabs": "\t",
							"desc": "\n`ondetach` gets callend whenever the spirit element is about to be detached from the DOM tree. Unless the element is appended somewhere else, this will schedule the spirit for destruction. ",
							"code": "\tondetach() {}\n"
						},
						{
							"line": 62,
							"tags": [],
							"tabs": "\t",
							"desc": "Note that the element may not be positioned in the DOM at this point. ",
							"code": "\tondestruct() {}\n"
						}
					]
				},
				{
					"title": "Runtime ",
					"tabs": "\t",
					"sections": [
						{
							"line": 67,
							"tags": [
								{
									"name": "@deprecated",
									"type": "(?)",
									"desc": "",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Crawler}",
									"desc": "crawler",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{number}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Handle crawler. ",
							"code": "\toncrawler(crawler) {\n\t\treturn 0;\n\t}\n"
						}
					]
				},
				{
					"title": "Static ",
					"tabs": "\t",
					"sections": [
						{
							"line": 77,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "arg",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "[cb]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Spirit}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Get spirit for argument. ",
							"code": "\tstatic get(arg, cb) {\n\t\tif (isElement(arg)) {\n\t\t\treturn Store.get(arg, cb);\n\t\t} else {\n\t\t\tthrow new TypeError(`Expected Element, got ${typeOf(arg)}`);\n\t\t}\n\t}\n"
						},
						{
							"line": 90,
							"tags": [
								{
									"name": "@param",
									"type": "{Element|string}",
									"desc": "arg",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Something has a spirit? ",
							"code": "\tstatic has(arg) {\n\t\treturn !!Spirit.get(arg);\n\t}\n"
						},
						{
							"line": 98,
							"tags": [
								{
									"name": "@returns",
									"type": "{Spirit}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Official factory method for spirit creation. The spirit subclasses may overwrite this to support various arguments and configuration options. ",
							"code": "\tstatic summon() {\n\t\treturn this.spawn();\n\t}\n"
						},
						{
							"line": 106,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Element}",
									"desc": "[arg]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Spirit}returnspawnInferred(this);",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Create a spirit based on the channeling for this class (constructor). Spawns the appropriate element and return the spirit. If an element is provided, the channeling will be confirmed to exist. If a string is provided, an element of that tagname will be created and validated. TODO: Actually support that last part. ",
							"code": "\tstatic spawn(arg) {\n\t\treturn arguments.length ? console.error('TODO') : spawnInferred(this);\n\t}\n"
						},
						{
							"line": 118,
							"tags": [
								{
									"name": "@param",
									"type": "{Class<HTMLElement>}",
									"desc": "Elm",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Spirit}",
									"desc": "spirit",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Class<HTMLElement>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Experimental! ",
							"code": "\tstatic api(Elm, spirit) {\n\t\treturn class extends Elm {};\n\t}\n"
						},
						{
							"line": 127,
							"tags": [
								{
									"name": "@param",
									"type": "{IMap}",
									"desc": "map",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Imap|null}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Spirit type interface. Equivalent to `static model` on {Model} classes. TODO: Implement type system support at least for `Element` so this can work! ",
							"code": "\tstatic spirit(map) {\n\t\treturn null;\n\t}\n"
						},
						{
							"line": 136,
							"tags": [
								{
									"name": "@type",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Identification for ducks. TODO: Rename this somehow ",
							"code": "\tstatic get isSpiritConstructor() {\n\t\treturn true;\n\t}\n"
						}
					]
				},
				{
					"title": "Privileged ",
					"tabs": "\t",
					"sections": [
						{
							"line": 145,
							"tags": [
								{
									"name": "@param",
									"type": "{IMap}",
									"desc": "map",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{IMap|null}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Framework internal. ",
							"code": "\tstatic [Symbol.for('@dataplastique/objectpipe')](map) {\n\t\treturn this.spirit(...arguments);\n\t}\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 155,
							"tags": [
								{
									"name": "@param",
									"type": "{Class<Spirit>}",
									"desc": "SpiritC",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Spirit}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Create a spirit based on the channeling for given constructor. ",
							"code": "function spawnInferred(SpiritC) {\n\treturn Guide.spawn(SpiritC);\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/gui/src/Store.js": {
			"title": "Store",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [
								{
									"name": "@type",
									"type": "{WeakMap<Element,Spirit>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Tracking spirits by element. ",
							"code": "const spirits = new WeakMap();\n"
						},
						{
							"line": 5,
							"tags": [
								{
									"name": "@type",
									"type": "{WeakMap<Element,Set<Function>>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "const expects = new WeakMap();\n"
						},
						{
							"line": 9,
							"tags": [
								{
									"name": "@type",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: `dataset.plastiqueId` not reliable in Firefox, remove this all over! TODO: This should be configurable, must read from the config. ",
							"code": "const ID = 'data-plastique-id';\n"
						},
						{
							"line": 15,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Spirit}",
									"desc": "spirit",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Spirit}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Register spirit for element. ",
							"code": "export function set(elm, spirit) {\n\tspirits.set(elm, spirit);\n\tstamp(elm, spirit.$id);\n\treturn spirit;\n}\n"
						},
						{
							"line": 26,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Unregister spirit for element. ",
							"code": "export function del(elm) {\n\tspirits.delete(elm);\n\texpects.delete(elm);\n\tstamp(elm, null);\n}\n"
						},
						{
							"line": 35,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "[cb]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Spirit}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get spirit for element. ",
							"code": "export function get(elm, cb) {\n\tcb = cb && typeof cb === 'function' ? cb : undefined;\n\tconst spirit = stamped(elm) ? spirits.get(elm) || null : null;\n\treturn cb ? applyOrDefer(spirit, elm, cb) : spirit;\n}\n"
						},
						{
							"line": 46,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Element has spirit? ",
							"code": "export function has(elm) {\n\treturn stamped(elm) && spirits.has(elm);\n}\n"
						},
						{
							"line": 54,
							"tags": [
								{
									"name": "@see",
									"type": "{Cycle#ready}",
									"desc": "",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Spirit}",
									"desc": "spirit",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Invoked after the spirits `onready` callback to evaluate whether or not any callbacks has been registed for the spirits element. ",
							"code": "export function applyDeferred(spirit, elm = spirit.element) {\n\tif (expects.has(elm)) {\n\t\tconst cbs = expects.get(elm);\n\t\texpects.delete(elm);\n\t\tcbs.forEach(cb => cb(spirit));\n\t}\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 69,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string|null}",
									"desc": "guid",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Stamp the element with the spirit `$id` mostly so that the developer can confirm that the spirit has been initialized. Note that the `data-plastique-id` attribute will not always be identical to the spirit `$id` property (when for example the element was created with the `data-plastique-id` in some EDBML). ",
							"code": "function stamp(elm, guid) {\n\tguid\n\t\t? stamped(elm)\n\t\t\t? void 0\n\t\t\t: elm.setAttribute(ID, guid)\n\t\t: elm.removeAttribute(ID);\n}\n"
						},
						{
							"line": 84,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Quickly test if element could be assoicated to a spirit before we confirm it via the WeakMap. ",
							"code": "function stamped(elm) {\n\treturn elm.hasAttribute(ID);\n}\n"
						},
						{
							"line": 93,
							"tags": [
								{
									"name": "@param",
									"type": "{Spirit|null}",
									"desc": "spirit",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "cb",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Spirit|null}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function applyOrDefer(spirit, elm, cb) {\n\tif (cb) {\n\t\tspirit\n\t\t\t? cb(spirit)\n\t\t\t: expects.has(elm)\n\t\t\t\t? expects.get(elm).add(cb)\n\t\t\t\t: expects.set(elm, new Set([cb]));\n\t}\n\treturn spirit;\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/gui/src/index.js": {
			"title": "index",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import Config from './Config';\nimport { get as getspirit } from './Store';\nimport { bootstrap } from './Guide';\nimport { isElement } from '@dataplastique/util';\nexport { default as Spirit } from './Spirit';\nexport { channeling, attribute } from './Deco';\nexport * from './Const'; \n"
						},
						{
							"line": 7,
							"tags": [
								{
									"name": "@param",
									"type": "{Config}",
									"desc": "[config]",
									"text": "- TODO: parse this into"
								},
								{
									"name": "@returns",
									"type": "{Promise}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "boot the entire shebang. We'll return a promise here in case we later find something promising to return. Note that this causes an async break, se consider an alternative (callback) if the initial rendering flashes. ",
							"code": "export function boot(config = {}) {\n\treturn new Promise((resolve, reject) => {\n\t\tboot.done\n\t\t\t? resolve()\n\t\t\t: do {\n\t\t\t\t\tdocument.readyState === 'loading'\n\t\t\t\t\t\t? reject(`Premature boot: Await DOMContentLoaded`)\n\t\t\t\t\t\t: do {\n\t\t\t\t\t\t\t\tConfig.init(config);\n\t\t\t\t\t\t\t\tbootstrap(document);\n\t\t\t\t\t\t\t\tboot.done = true;\n\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t  };\n\t\t\t  };\n\t});\n}\n"
						},
						{
							"line": 30,
							"tags": [
								{
									"name": "@param",
									"type": "{Node}",
									"desc": "node",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Node}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Activate the mutation observer system for given node, most likely some `shadowRoot` since otherwise it would otherwise already work. ",
							"code": "export function reboot(node) {\n\treturn bootstrap(node);\n}\n"
						},
						{
							"line": 39,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Spirit}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get spirit for element. ",
							"code": "export function get(elm) {\n\tif (isElement(elm)) {\n\t\treturn getspirit(elm);\n\t} else {\n\t\tthrow new TypeError('Element expected');\n\t}\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/test/src/edb/Collection.iso.spec.js": {
			"title": "Collection.iso.spec",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "\t\t",
							"desc": "",
							"code": "import { Model, Collection } from 'dataplastique';\nexport default function() {\n\tdescribe('edb.Collection', function likethis() {\n\t\tclass NumberCollection extends Collection {\n\t\t\tstatic collection() {\n\t\t\t\treturn Number;\n\t\t\t}\n\t\t}\n\t\tclass Person extends Model {\n\t\t\tstatic model() {\n\t\t\t\treturn {\n\t\t\t\t\tname: String\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tclass Animal extends Model {\n\t\t\tstatic model() {\n\t\t\t\treturn {\n\t\t\t\t\tspecies: String\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tclass PersonCollection extends Collection {\n\t\t\tstatic collection() {\n\t\t\t\treturn Person;\n\t\t\t}\n\t\t}\n\t\tclass LifeFormCollection extends Collection {\n\t\t\tstatic collection() {\n\t\t\t\treturn input => {\n\t\t\t\t\tif (input.species) {\n\t\t\t\t\t\treturn Animal;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn Person;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t}\n"
						}
					]
				},
				{
					"title": "Expectations ",
					"tabs": "\t\t",
					"sections": [
						{
							"line": 38,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "\t\t\t\tit('should be proxied, obviously', () => {\n\t\t\tlet persons = new PersonCollection();\n\t\t\texpect(persons.$CONFIRM_PROXY).toBe(true);\n\t\t});\n\t\tit('should behave like an array', () => {\n\t\t\tlet col = new Collection(1, 2, 3, 4, 5);\n\t\t\texpect(col.length).toBe(5);\n\t\t\tcol.push(undefined);\n\t\t\texpect(col.length).toBe(6);\n\t\t\tlet last = col.pop();\n\t\t\texpect(last).toBe(undefined);\n\t\t\texpect(col.length).toBe(5);\n\t\t\tlet first = col.shift();\n\t\t\texpect(first).toBe(1);\n\t\t\texpect(col.length).toBe(4);\n\t\t});\n\t\tit('should support simple objects and arrays', () => {\n\t\t\tlet simpleo = o => o.constructor === Object;\n\t\t\tlet simplea = a => a.constructor === Array;\n\t\t\tlet objects = new Collection(\n\t\t\t\t{ name: 'John' },\n\t\t\t\t{ name: 'Bob' },\n\t\t\t\t{ name: 'Bill' }\n\t\t\t);\n\t\t\texpect(objects.every(simpleo)).toBe(true);\n\t\t\texpect(objects.map(o => [o]).every(simplea)).toBe(true);\n\t\t});\n\t\tit('should convert objects into models', () => {\n\t\t\tlet persons = new PersonCollection(\n\t\t\t\t{ name: 'John' },\n\t\t\t\t{ name: 'Bob' },\n\t\t\t\t{ name: 'Bill' }\n\t\t\t);\n\t\t\texpect(persons.every(person => Person.is(person))).toBe(true);\n\t\t});\n\t\tit('should support multiple types of models', () => {\n\t\t\tlet persons = new LifeFormCollection(\n\t\t\t\t{ name: 'Billy' },\n\t\t\t\t{ name: 'Bobby' },\n\t\t\t\t{ species: 'Goat' },\n\t\t\t\t{ species: 'Stork' },\n\t\t\t\t{ species: 'Baboon' }\n\t\t\t);\n\t\t\texpect(Person.is(persons[0])).toBe(true);\n\t\t\texpect(Animal.is(persons[2])).toBe(true);\n\t\t});\n\t\tit('should mutate like an array', () => {\n\t\t\tlet persons = new PersonCollection();\n\t\t\tpersons.push({ name: 'D' });\n\t\t\tpersons.unshift({ name: 'C' });\n\t\t\tpersons.splice(0, 0, { name: 'A' }, { name: 'B' });\n\t\t\tpersons[4] = { name: 'E' };\n\t\t\texpect(persons.length).toBe(5);\n\t\t\texpect(persons.map(p => p.name)).toEqual(['A', 'B', 'C', 'D', 'E']);\n\t\t\texpect(persons.every(p => Person.is(p))).toBe(true);\n\t\t});\n\t\tit('should iterate and reduce like an array', () => {\n\t\t\tlet persons = new PersonCollection({ name: 'John' });\n\t\t\t['forEach', 'every', 'map', 'filter', 'find'].forEach(method => {\n\t\t\t\tpersons[method](function(elm, idx, src) {\n\t\t\t\t\texpect(Person.is(elm)).toBe(true);\n\t\t\t\t\texpect(idx).toBe(0);\n\t\t\t\t\texpect(src).toBe(persons);\n\t\t\t\t\texpect(this).toBe(Math.PI);\n\t\t\t\t}, Math.PI);\n\t\t\t});\n\t\t\t['reduce', 'reduceRight'].forEach(method => {\n\t\t\t\tpersons[method](function(pre, now, idx, src) {\n\t\t\t\t\texpect(pre).toBe(Math.PI);\n\t\t\t\t\texpect(Person.is(now)).toBe(true);\n\t\t\t\t\texpect(idx).toBe(0);\n\t\t\t\t\texpect(src).toBe(persons);\n\t\t\t\t}, Math.PI);\n\t\t\t});\n\t\t\tlet p = persons.find(x => x.name === 'John');\n\t\t\texpect(p.name).toBe('John');\n\t\t});\n\t\t\n\t\tit('should stringify to JSON as simple array of objects', () => {\n\t\t\tlet persons = new LifeFormCollection(\n\t\t\t\t{ name: 'Billy' },\n\t\t\t\t{ species: 'Goat' }\n\t\t\t);\n\t\t\texpect(persons.every(p => Model.is(p))).toBe(true);\n\t\t\texpect(JSON.parse(JSON.stringify(persons))).toEqual([\n\t\t\t\t{ name: 'Billy' },\n\t\t\t\t{ species: 'Goat' }\n\t\t\t]);\n\t\t});\n\t\tit('can be observed', done => {\n\t\t\tlet name = person => person.name;\n\t\t\tlet persons = new PersonCollection(\n\t\t\t\t{ name: 'John' },\n\t\t\t\t{ name: 'Bob' },\n\t\t\t\t{ name: 'Bill' }\n\t\t\t);\n\t\t\tpersons.addObserver({\n\t\t\t\tonsplice(collection, added, removed) {\n\t\t\t\t\texpect(collection).toBe(persons);\n\t\t\t\t\texpect(added.map(name)).toEqual(['Henrik', 'Miguel', 'Heino']);\n\t\t\t\t\texpect(removed.map(name)).toEqual(['John', 'Bob', 'Bill']);\n\t\t\t\t\tpersons.removeObserver(this);\n\t\t\t\t\tdone();\n\t\t\t\t}\n\t\t\t});\n\t\t\tpersons.pop();\n\t\t\tpersons[0] = { name: 'Henrik' };\n\t\t\tpersons[1] = { name: 'Miguel' };\n\t\t\tpersons.push({ name: 'Heino' });\n\t\t});\n\t});\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/test/src/edb/DevTools.web.spec.js": {
			"title": "DevTools.web.spec",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { Model, Collection } from 'dataplastique';\nexport default function() {\n\tdescribe('DevTools', () => {\n\t\tclass Person extends Model {\n\t\t\tstatic model() {\n\t\t\t\treturn {\n\t\t\t\t\tname: String,\n\t\t\t\t\tjob: String,\n\t\t\t\t\tage: Number,\n\t\t\t\t\tcv: Object,\n\t\t\t\t\thobbies: Array,\n\t\t\t\t\tspouse: Person,\n\t\t\t\t\tfriends: Collection.$of(Person)\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tconst person = new Person({\n\t\t\tname: 'Arne',\n\t\t\tjob: 'Actor',\n\t\t\tage: 45,\n\t\t\tcv: {\n\t\t\t\ta: 'A',\n\t\t\t\tb: 'B',\n\t\t\t\tc: 'C'\n\t\t\t},\n\t\t\thobbies: ['singing', 'dancing'],\n\t\t\tspouse: new Person({\n\t\t\t\tname: 'Bettina',\n\t\t\t\tjob: 'Bomber Pilot',\n\t\t\t\tage: 23\n\t\t\t}),\n\t\t\tfriends: [\n\t\t\t\tnew Person({\n\t\t\t\t\tname: 'Charlie',\n\t\t\t\t\tjob: 'Gentleman Spy',\n\t\t\t\t\tage: 52\n\t\t\t\t}),\n\t\t\t\tnew Person({\n\t\t\t\t\tname: 'Connor',\n\t\t\t\t\tjob: 'Antiques Dealer',\n\t\t\t\t\tage: 499,\n\t\t\t\t\thobbies: ['fencing', 'fighting']\n\t\t\t\t})\n\t\t\t]\n\t\t});\n\t\tit('formats models and classes in Chrome if \"Enable custom formatters\"', () => {\n\t\t\tconsole.log(Person);\n\t\t\tconsole.log(person);\n\t\t\texpect(!!'great expectations').toBe(!!'expected');\n\t\t});\n\t});\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/test/src/edb/Model.iso.spec.js": {
			"title": "Model.iso.spec",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { Model } from 'dataplastique';\nimport { Environment } from 'dataplastique';\nimport { isImmutable } from '@dataplastique/util';\nexport default function() {\n\tdescribe('edb.Model', function likethis() {\n\t\tclass MyModel extends Model {\n\t\t\tonconstruct() {\n\t\t\t\tsuper.onconstruct();\n\t\t\t\tthis.called = true;\n\t\t\t}\n\t\t}\n\t\tit('should call `onconstruct` when constructed', () => {\n\t\t\tlet model = new MyModel();\n\t\t\texpect(model.called).toBe(true);\n\t\t});\n\t\tit('should throw an AccessError', () => {\n\t\t\tclass MyModel extends Model {}\n\t\t\tconst model = new MyModel({ nickname: 'Morten' });\n\t\t\texpect(model.nickname).toBe('Morten');\n\t\t\tmodel.dispose();\n\t\t\texpecterror('destructed', () => {\n\t\t\t\tconsole.log(model.nickname);\n\t\t\t});\n\t\t});\n\t});\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/test/src/edb/Model.observers.iso.spec.js": {
			"title": "Model.observers.iso.spec",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "\t\t",
							"desc": "",
							"code": "import { Model } from 'dataplastique';\nexport default function() {\n\tdescribe('edb.Model can be observed', () => {\n\t\tclass MyModel extends Model {\n\t\t\t_private = 23;\n\t\t\tonconstruct() {\n\t\t\t\tthis.$privileged = 23;\n\t\t\t}\n\t\t}\n\t\tclass SecretModel extends Model {\n\t\t\tget $observable() {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tit('should know when properties are changed, inspected, added and removed', done => {\n\t\t\tlet poked = false;\n\t\t\tlet peekt = false;\n\t\t\tlet added = false;\n\t\t\tlet nuked = false;\n\t\t\tlet name1 = 'Bob';\n\t\t\tlet name2 = 'Jim';\n\t\t\tlet model = new MyModel({\n\t\t\t\tname: name1,\n\t\t\t\tage: 23\n\t\t\t});\n\t\t\tmodel.addObserver({\n\t\t\t\tonpeek(model, name) {\n\t\t\t\t\tpeekt = peekt || name === 'name';\n\t\t\t\t},\n\t\t\t\tonpoke(model, name, value) {\n\t\t\t\t\tpoked = poked || (name === 'name' && value === name2);\n\t\t\t\t\tnuked = nuked || (name === 'age' && value === undefined);\n\t\t\t\t\tadded = added || name === 'hobby';\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (model.name === name1) {\n\t\t\t\tmodel.hobby = 'Toys'; \n\t\t\t\tmodel.name = name2; \n\t\t\t\tdelete model.age; \n\t\t\t}\n\t\t\tlater(() => {\n\t\t\t\texpect(peekt && poked && added && nuked).toBe(true);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t\tit('should not notify observers on private or privileged props changed', done => {\n\t\t\tlet model = new MyModel();\n\t\t\tlet works = true;\n\t\t\tmodel.addObserver({\n\t\t\t\tonpeek() {\n\t\t\t\t\tworks = false;\n\t\t\t\t},\n\t\t\t\tonpoke() {\n\t\t\t\t\tworks = false;\n\t\t\t\t}\n\t\t\t});\n\t\t\tmodel._private = 0;\n\t\t\tmodel.$privileged = 0;\n\t\t\tlater(() => {\n\t\t\t\texpect(works).toBe(true);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n"
						},
						{
							"line": 63,
							"tags": [],
							"tabs": "",
							"desc": "IDEA: If the prop has a setter, try setting it and note what private prop changed. Then invoke the getter to see if it matches. Then finally *reset* the setter. If match is found, perhaps we can assume that the getter proxies this particular private property? This is of course sketchy :/ ",
							"code": "\t\tit(\"(should really trigger when a public getter exposes a private prop, but it won't)\", () => {\n\t\t\texpect(!!'we should figure this out somehow').toBe(true);\n\t\t});\n\t});\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/test/src/edb/Model.output.iso.spec.js": {
			"title": "Model.output.iso.spec",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { Model } from 'dataplastique';\nexport default function() {\n\tdescribe('edb.Model can output to connected handlers', () => {\n\t\tit('should connect and disconnect', () => {\n\t\t\tclass MyModel extends Model {}\n\t\t\tlet mymodel = new MyModel();\n\t\t\tMyModel.connect({\n\t\t\t\toninput(input) {\n\t\t\t\t\texpect(input).toEqual(mymodel);\n\t\t\t\t\tlet ignored = new MyModel();\n\t\t\t\t\tMyModel.disconnect(this);\n\t\t\t\t\tignored.output();\n\t\t\t\t}\n\t\t\t});\n\t\t\tmymodel.output();\n\t\t});\n\t\tit('should input the latest output', done => {\n\t\t\tclass MyModel extends Model {}\n\t\t\tlet mymodel = new MyModel().output();\n\t\t\tlater(() => {\n\t\t\t\tMyModel.connect({\n\t\t\t\t\toninput(input) {\n\t\t\t\t\t\texpect(input).toEqual(mymodel);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t\tit('should revoke the output', done => {\n\t\t\tclass MyModel extends Model {}\n\t\t\tlet mymodel = new MyModel();\n\t\t\tlet initial = true;\n\t\t\tMyModel.connect({\n\t\t\t\toninput(input) {\n\t\t\t\t\texpect(input).toEqual(mymodel);\n\t\t\t\t},\n\t\t\t\tonrevoke(C) {\n\t\t\t\t\texpect(C).toEqual(MyModel);\n\t\t\t\t\tdone();\n\t\t\t\t}\n\t\t\t});\n\t\t\tmymodel.output();\n\t\t\tmymodel.revoke();\n\t\t});\n\t\tit('should not trigger revoked output', done => {\n\t\t\tclass MyModel extends Model {}\n\t\t\tlet mymodel = new MyModel();\n\t\t\tmymodel.output().revoke();\n\t\t\tlater(() => {\n\t\t\t\tlet triggered = false;\n\t\t\t\tMyModel.connect({\n\t\t\t\t\toninput(input) {\n\t\t\t\t\t\ttriggered = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\texpect(triggered).toBe(false);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/test/src/edb/Model.pipes.iso.spec.js": {
			"title": "Model.pipes.iso.spec",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { Model } from 'dataplastique';\nimport { isImmutable } from '@dataplastique/util';\n"
						},
						{
							"line": 2,
							"tags": [],
							"tabs": "",
							"desc": "\n *TODO: allow private props that are not undefined even when note in model() - Symbols only?' ",
							"code": "export default function() {\n\tclass TypedModel extends Model {\n\t\tstatic model() {\n\t\t\treturn {\n\t\t\t\tname: String,\n\t\t\t\tage: Number,\n\t\t\t\tmarried: Boolean,\n\t\t\t\tobject: Object,\n\t\t\t\tarray: Array,\n\t\t\t\tonclick: Function,\n\t\t\t\tmultitype: [String, Number, Boolean]\n\t\t\t};\n\t\t}\n\t\tgreeting() {\n\t\t\treturn 'hi';\n\t\t}\n\t}\n\tdescribe('edb.Model pipes provide type safety', () => {\n\t\tit('should accept the constructor object', () => {\n\t\t\tlet model = new TypedModel({\n\t\t\t\tname: 'John',\n\t\t\t\tage: 23,\n\t\t\t\tmarried: false,\n\t\t\t\tobject: {},\n\t\t\t\tarray: []\n\t\t\t});\n\t\t\texpect(model.name).toBe('John');\n\t\t\texpect(model.age).toBe(23);\n\t\t\texpect(model.married).toBe(false);\n\t\t\texpect(model.object).toEqual(jasmine.any(Object));\n\t\t\texpect(model.array).toEqual(jasmine.any(Array));\n\t\t});\n\t\tit('should accept the property assigment', () => {\n\t\t\tlet model = new TypedModel();\n\t\t\tmodel.name = 'Jim Bob';\n\t\t\texpect(model.name).toBe('Jim Bob');\n\t\t});\n\t\tit('should explode on bad constructor object', () => {\n\t\t\texpecterror('bad assignment', () => {\n\t\t\t\tnew TypedModel({\n\t\t\t\t\tname: Math.random()\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t\tit('should explode on bad assignment', () => {\n\t\t\tlet model = new TypedModel();\n\t\t\texpecterror('bad assignment', () => {\n\t\t\t\tmodel.object = new Array(23);\n\t\t\t});\n\t\t});\n\t\tit('should explode on assignment to undeclared key', () => {\n\t\t\tlet model = new TypedModel();\n\t\t\texpecterror('cannot assign', () => {\n\t\t\t\tmodel.badname = 'Sauron';\n\t\t\t});\n\t\t});\n\t\tit('should explode on undeclared key in constructor argument', () => {\n\t\t\texpecterror('cannot assign', () => {\n\t\t\t\tnew TypedModel({\n\t\t\t\t\tbadname: 'Sauron'\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t\tit('should explode on overwriting a normal instance method', () => {\n\t\t\tlet model = new TypedModel();\n\t\t\texpecterror('cannot assign', () => {\n\t\t\t\tmodel.greeting = () => 'hello there';\n\t\t\t});\n\t\t});\n\t\tit('should however let you implement a configurable method', () => {\n\t\t\tlet model = new TypedModel();\n\t\t\tmodel.onclick = () => 'clicked';\n\t\t\texpect(model.onclick()).toBe('clicked');\n\t\t});\n\t\tit('should validate assignment of variable types', () => {\n\t\t\tconst model = new TypedModel();\n\t\t\t['x', 23, true].forEach(primitive => {\n\t\t\t\tmodel.multitype = primitive;\n\t\t\t\texpect(model.multitype).toBe(primitive);\n\t\t\t});\n\t\t\texpecterror('bad assignment', () => {\n\t\t\t\tmodel.multitype = [23];\n\t\t\t});\n\t\t});\n\t\tit('should throw on attempt to redefine the property descriptor', () => {\n\t\t\texpecterror('cannot redefine', () => {\n\t\t\t\tReflect.defineProperty(new TypedModel(), 'name', {\n\t\t\t\t\tget: function() {\n\t\t\t\t\t\treturn 'Arne';\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\tdescribe('edb.Model pipes are inherited and can be modified', () => {\n\t\tit('can inherit type interface from ancestor class', () => {\n\t\t\tclass SubModel extends TypedModel {}\n\t\t\texpecterror('cannot assign', () => {\n\t\t\t\tnew SubModel().bonusprop = true;\n\t\t\t});\n\t\t});\n\t\tit('can extend type interface from ancestor class', () => {\n\t\t\tclass AnotherSubModel extends TypedModel {\n\t\t\t\tstatic model() {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tbonusprop: Boolean\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst model = new AnotherSubModel({\n\t\t\t\tname: 'Jib Bob Johnson',\n\t\t\t\tbonusprop: true\n\t\t\t});\n\t\t\texpect(model.bonusprop).toBe(true);\n\t\t});\n\t\tit('always receives an immutable map, though it is rarely used', () => {\n\t\t\tnew class TestModel extends Model {\n\t\t\t\tstatic model(map) {\n\t\t\t\t\texpect(isImmutable(map)).toBe(true);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}({\n\t\t\t\ttrigger: 'poke'\n\t\t\t});\n\t\t});\n\t\tit('can use this map morph the ancestor interface into a new one', () => {\n\t\t\tclass ModelA extends TypedModel {}\n\t\t\tclass ModelB extends ModelA {}\n\t\t\tclass ModelC extends ModelB {\n\t\t\t\tstatic model(map) {\n\t\t\t\t\treturn map\n\t\t\t\t\t\t.delete('married')\n\t\t\t\t\t\t.delete('object')\n\t\t\t\t\t\t.delete('array')\n\t\t\t\t\t\t.delete('onclick')\n\t\t\t\t\t\t.set('bonusprop', Boolean);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst model = new ModelC({\n\t\t\t\tbonusprop: true,\n\t\t\t\tname: 'Boba'\n\t\t\t});\n\t\t\texpect(model.bonusprop).toBe(true);\n\t\t\texpecterror('bad assignment', () => {\n\t\t\t\tmodel.bonusprop = Math.PI;\n\t\t\t});\n\t\t\texpecterror('cannot assign', () => {\n\t\t\t\tmodel.married = false;\n\t\t\t});\n\t\t});\n\t});\n\t\n\tdescribe('edb.Model pipes convert objects and arrays to Models and Collections', () => {\n\t\tclass Person extends Model {\n\t\t\tstatic model() {\n\t\t\t\treturn {\n\t\t\t\t\tname: String,\n\t\t\t\t\tfriend: Person,\n\t\t\t\t\tpet: Animal\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tclass Animal extends Model {\n\t\t\tstatic model() {\n\t\t\t\treturn {\n\t\t\t\t\tname: String\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tit('should map objects to models in constructor argument', () => {\n\t\t\tconst jim = new Person({\n\t\t\t\tname: 'Jim Bob',\n\t\t\t\tpet: { name: 'Pretty' },\n\t\t\t\tfriend: {\n\t\t\t\t\tname: 'John Johnson',\n\t\t\t\t\tpet: { name: 'Beauty' }\n\t\t\t\t}\n\t\t\t});\n\t\t\texpect(jim.pet).toEqual(jasmine.any(Animal));\n\t\t\texpect(jim.friend).toEqual(jasmine.any(Person));\n\t\t\texpect(jim.friend.pet).toEqual(jasmine.any(Animal));\n\t\t});\n\t\tit('should map objects to models in setters', () => {\n\t\t\tconst jim = new Person();\n\t\t\tjim.pet = { name: 'Pretty' };\n\t\t\tjim.friend = { name: 'John' };\n\t\t\tjim.friend.pet = { name: 'Beauty' };\n\t\t\texpect(jim.pet).toEqual(jasmine.any(Animal));\n\t\t\texpect(jim.friend).toEqual(jasmine.any(Person));\n\t\t\texpect(jim.friend.pet).toEqual(jasmine.any(Animal));\n\t\t});\n\t\tit('should pass along instantiated valid models', () => {\n\t\t\tconst john = new Person();\n\t\t\tconst jim = new Person({\n\t\t\t\tfriend: john\n\t\t\t});\n\t\t\texpect(jim.friend).toBe(john);\n\t\t});\n\t\tit('should explode on instantiated invalid models', () => {\n\t\t\tconst pet = new Animal();\n\t\t\texpecterror('bad assignment', () => {\n\t\t\t\tnew Person({ friend: pet });\n\t\t\t});\n\t\t});\n\t\tit('should upgrade assignments of variable type', () => {\n\t\t\texpect(!!'todo').toBe(true);\n\t\t});\n\t});\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/test/src/edb/Model.proxy.iso.spec.js": {
			"title": "Model.proxy.iso.spec",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { Model } from 'dataplastique';\nimport { Environment } from 'dataplastique';\n"
						},
						{
							"line": 2,
							"tags": [
								{
									"name": "@type",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Prepare for the worst: Symbol assigned as properties (on the Proxy) may randomly return an `undefined` property value in Edge :/ ",
							"code": "const isEdge = Environment.browser && /Edge/.test(navigator.userAgent);\nexport default function() {\n\tdescribe('edb.Model proxy', function likethis() {\n\t\tclass MyModel extends Model {\n\t\t\t[Symbol('private')] = 23;\n\t\t}\n\t\tit('should be proxied, to begin with', () => {\n\t\t\tlet mymodel = new MyModel();\n\t\t\texpect(mymodel.$CONFIRM_PROXY).toBe(true);\n\t\t});\n\t\tit('should store public keys', () => {\n\t\t\tlet model = new MyModel();\n\t\t\tmodel.publickey = 'public';\n\t\t\texpect(model.publickey).toBe('public');\n\t\t});\n\t\tit('should store special keys', () => {\n\t\t\tlet model = new MyModel();\n\t\t\tlet symbolkey = Symbol('key');\n\t\t\tmodel._privatekey = 'private';\n\t\t\tmodel.$privilegedkey = 'privileged';\n\t\t\tmodel[symbolkey] = 'symbol';\n\t\t\texpect(model._privatekey).toBe('private');\n\t\t\texpect(model.$privilegedkey).toBe('privileged');\n\t\t\tif (isEdge) {\n\t\t\t\texpect(!!'TEST DISABLED BECAUSE RANDOMLY FAILS IN EDGE :/').toBe(true);\n\t\t\t} else {\n\t\t\t\texpect(model[symbolkey]).toBe('symbol');\n\t\t\t}\n\t\t});\n\t\tit('should support defineProperty', () => {\n\t\t\tlet ok = false;\n\t\t\tlet model = new MyModel();\n\t\t\tReflect.defineProperty(model, 'normal', {\n\t\t\t\twritable: true,\n\t\t\t\tvalue: 23\n\t\t\t});\n\t\t\tReflect.defineProperty(model, 'readonly', {\n\t\t\t\tvalue: 23\n\t\t\t});\n\t\t\texpecterror(\n\t\t\t\t'cannot assign',\n\t\t\t\t() => (model.readonly = 0),\n\t\t\t\t() => {\n\t\t\t\t\tReflect.defineProperty(model, 'normal', {\n\t\t\t\t\t\tvalue: 'changed'\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t);\n\t\t\texpect(model.normal).toBe(23);\n\t\t});\n\t\tit('should not casually reveal special properties', () => {\n\t\t\tlet ok = true;\n\t\t\tconst model = new MyModel();\n\t\t\tmodel._specialkey = 'private';\n\t\t\tmodel.$specialkey = 'privileged';\n\t\t\tmodel._CONSTANTED = 'CONSTANT';\n\t\t\tReflect.defineProperty(model, '_privatekey', {\n\t\t\t\tvalue: 'This will become non-enumarable!',\n\t\t\t\tenumerable: true,\n\t\t\t\twritable: true\n\t\t\t});\n\t\t\texpect(Object.keys(model).length).toBe(0);\n\t\t\texpect(JSON.parse(JSON.stringify(model))).toEqual({});\n\t\t\tfor (let prop in model) {\n\t\t\t\tok = false;\n\t\t\t}\n\t\t\texpect(ok).toBe(true);\n\t\t});\n\t\tit('should never reveal the value of symbol properties', () => {\n\t\t\tconst symbol = Symbol('secret');\n\t\t\tconst model = new MyModel();\n\t\t\tmodel[symbol] = 23;\n\t\t\tif (isEdge) {\n\t\t\t\texpect(!!'TEST DISABLED BECAUSE RANDOMLY FAILS IN EDGE :/').toBe(true);\n\t\t\t} else {\n\t\t\t\texpect(model[symbol]).toBe(23);\n\t\t\t}\n\t\t\tconst symbols = Object.getOwnPropertySymbols(model);\n\t\t\tconst undef = symbol => model[symbol] === undefined;\n\t\t\texpect(symbols.every(undef)).toBe(true);\n\t\t});\n\t\tit('should however reveal all normal properties', () => {\n\t\t\tlet model = new MyModel();\n\t\t\tmodel.name = 'John';\n\t\t\tmodel.age = '23';\n\t\t\tmodel.married = false;\n\t\t\texpect(Object.keys(model).length).toBe(3);\n\t\t\texpect(JSON.parse(JSON.stringify(model))).toEqual({\n\t\t\t\tname: 'John',\n\t\t\t\tage: '23',\n\t\t\t\tmarried: false\n\t\t\t});\n\t\t});\n\t\tit('should disallow special keys in constructor argument', () => {\n\t\t\texpecterror('not allowed', () => {\n\t\t\t\tlet model = new MyModel({\n\t\t\t\t\t_privatekey: 'a',\n\t\t\t\t\t$privilegedkey: 'b',\n\t\t\t\t\t[Symbol('key')]: 'c'\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t\tit('should have have a nonconfigurable `$id`', () => {\n\t\t\tlet model = new MyModel();\n\t\t\tlet fails = false;\n\t\t\texpect(typeof model.$id).toBe('string');\n\t\t\texpecterror('cannot assign', () => {\n\t\t\t\tmodel.$id = 'John';\n\t\t\t});\n\t\t});\n\t\tit('should declare uppercase property names as readonly', () => {\n\t\t\tlet model = new MyModel({\n\t\t\t\tCONSTANT_1: 'readonly',\n\t\t\t\tCONSTANT_2: 'readonly'\n\t\t\t});\n\t\t\tmodel.CONSTANT_3 = 'readonly';\n\t\t\texpecterror(\n\t\t\t\t'cannot assign',\n\t\t\t\t() => (model.CONSTANT_1 = 0),\n\t\t\t\t() => (model.CONSTANT_2 = 0),\n\t\t\t\t() => (model.CONSTANT_3 = 0),\n\t\t\t\t() => {\n\t\t\t\t\tReflect.defineProperty(model, 'CONSTANT_1', {\n\t\t\t\t\t\tvalue: 0\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t});\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/test/src/edb/Plugin.iso.spec.js": {
			"title": "Plugin.iso.spec",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { Model, plugin, Plugin } from 'dataplastique';\nclass MyPlugin extends Plugin {\n\tget $observable() {\n\t\treturn true;\n\t}\n}\nclass MyOtherPlugin extends Plugin {\n\tonconstruct() {\n\t\tsuper.onconstruct();\n\t\tthis.host.specialprop = true;\n\t}\n\tstatic lazy() {\n\t\treturn false;\n\t}\n}\n@plugin('myplugin', MyPlugin)\n@plugin('myotherplugin', MyOtherPlugin)\nclass MyModel extends Model {}\n"
						},
						{
							"line": 18,
							"tags": [],
							"tabs": "",
							"desc": "Start testing. ",
							"code": "export default function() {\n\tdescribe('edb.Plugin', function likethis() {\n\t\tconst hasproxy = plugin => !!plugin.$CONFIRM_PROXY;\n\t\tit('can newup the plugin on demand', () => {\n\t\t\tconst myplugin = new MyModel().myplugin; \n\t\t\texpect(MyPlugin.is(myplugin)).toBe(true);\n\t\t});\n\t\tit('correctly assigns the host', () => {\n\t\t\tconst mymodel = new MyModel();\n\t\t\texpect(mymodel.myplugin.host).toBe(mymodel);\n\t\t});\n\t\tit('will newup non-lazy plugins automatically', () => {\n\t\t\texpect(new MyModel().specialprop).toBe(true);\n\t\t});\n\t});\n\tconsole.log('TODO: Plugin can protect itself from accidental assignments');\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/test/src/edb/Tree.iso.spec.js": {
			"title": "Tree.iso.spec",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { Tree, Model, Collection } from 'dataplastique';\nconst stringify = obj => JSON.stringify(obj, 0, 4);\nexport default function() {\n\tclass MyModel extends Model {}\n\tclass MyCollection extends Collection {}\n\tconst mapping = {\n\t\tMyModel: MyModel,\n\t\tMyCollection: MyCollection\n\t};\n\tdescribe('edb.Tree', function likethis() {\n\t\tit('should encode and decode the Model', () => {\n\t\t\tconst source = new MyModel({\n\t\t\t\tone: 1,\n\t\t\t\ttwo: 2,\n\t\t\t\tmodel1: new MyModel({\n\t\t\t\t\tone: 1,\n\t\t\t\t\ttwo: 2\n\t\t\t\t}),\n\t\t\t\tmodel2: new MyModel({\n\t\t\t\t\tcollection: new MyCollection(1, 2, 3)\n\t\t\t\t})\n\t\t\t});\n\t\t\tconst mytree = Tree.encode(source);\n\t\t\tconst target = Tree.decode(mytree, mapping);\n\t\t\texpect(stringify(source)).toBe(stringify(target));\n\t\t});\n\t\tit('should encode and decode the Collection', () => {\n\t\t\tconst source = new MyCollection(1, 2, new MyModel({ one: 1 }));\n\t\t\tsource.prop1 = 'value';\n\t\t\tsource.prop2 = new MyModel({ one: 1, two: 2 });\n\t\t\tsource.push(new MyModel({ three: 3 }));\n\t\t\tsource.push(new MyCollection(1, 2, 3, new MyModel({ four: 4 })));\n\t\t\tconst mytree = Tree.encode(source);\n\t\t\tconst target = Tree.decode(mytree, mapping);\n\t\t\texpect(stringify(source)).toBe(stringify(target));\n\t\t});\n\t});\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/test/src/gui/AttPlugin.web.spec.js": {
			"title": "AttPlugin.web.spec",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { Spirit, channeling, attribute, boot } from 'dataplastique';\n"
						},
						{
							"line": 1,
							"tags": [],
							"tabs": "\t",
							"desc": "\n\n",
							"code": "export default function() {\n"
						},
						{
							"line": 5,
							"tags": [],
							"tabs": "\t",
							"desc": "We'll use this spirit to test the `attribute` decorator. ",
							"code": "\t@channeling('my-hairy-spirit')\n\tclass MyHairySpirit extends Spirit {\n\t\thaircolor = 'purple';\n\t\t@attribute('my-hair-color')\n\t\tset haircolor(value) {}\n\t}\n"
						},
						{
							"line": 14,
							"tags": [],
							"tabs": "",
							"desc": "TODO: Special business logig for non-primitive values TODO: Also check this with the (static) `model()` ",
							"code": "\tdescribe('gui.AttPlugin', function likethis() {\n\t\tit('should boot first', done => {\n\t\t\texpect(true).toBe(true);\n\t\t\tboot().then(done);\n\t\t});\n\t\tit('should set the attribute', () => {\n\t\t\tconst spirit = Spirit.summon();\n\t\t\tspirit.att.set('name', 'value');\n\t\t\texpect(spirit.element.getAttribute('name')).toBe('value');\n\t\t});\n\t\tit('should get the attribute', () => {\n\t\t\tconst spirit = Spirit.summon();\n\t\t\tspirit.att.set('name', 'value');\n\t\t\texpect(spirit.att.get('name')).toBe('value');\n\t\t});\n\t\tit('should query existance', () => {\n\t\t\tconst spirit = Spirit.summon();\n\t\t\tspirit.att.set('name', 'value');\n\t\t\texpect(spirit.att.has('name')).toBe(true);\n\t\t});\n\t\tit('should cast the number', () => {\n\t\t\tconst spirit = Spirit.summon();\n\t\t\tspirit.att.set('number', '23');\n\t\t\texpect(spirit.att.get('number')).toBe(23);\n\t\t});\n\t\tit('should cast the boolean', () => {\n\t\t\tconst spirit = Spirit.summon();\n\t\t\tspirit.att.set('boolean', 'true');\n\t\t\texpect(spirit.att.get('boolean')).toBe(true);\n\t\t});\n\t\tit('should delete the attribute', () => {\n\t\t\tconst spirit = Spirit.summon();\n\t\t\tspirit.att.set('name', 'value').set('name', null);\n\t\t\texpect(spirit.att.has('name')).toBe(false);\n\t\t});\n\t\tit('should also delete the attribute', () => {\n\t\t\tconst spirit = Spirit.summon();\n\t\t\tspirit.att.set('name', 'value').delete('name');\n\t\t\texpect(spirit.att.has('name')).toBe(false);\n\t\t});\n\t\tit('should shift the attribute', () => {\n\t\t\tconst spirit = Spirit.summon();\n\t\t\tlet truthy = this.constructor;\n\t\t\tspirit.att.shift(truthy, 'name', 'value');\n\t\t\texpect(spirit.att.get('name')).toBe('value');\n\t\t});\n\t\tit('should autoconvert strings to appropriate primitives', () => {\n\t\t\tconst spirit = Spirit.summon();\n\t\t\tspirit.element.setAttribute('test1', '23');\n\t\t\tspirit.element.setAttribute('test2', 'true');\n\t\t\texpect(spirit.att.get('test1')).toBe(23);\n\t\t\texpect(spirit.att.get('test2')).toBe(true);\n\t\t});\n\t\tit('should reflect HTML attributes into to JS properties', () => {\n\t\t\tconst spirit = MyHairySpirit.summon();\n\t\t\texpect(spirit.haircolor).toBe('purple');\n\t\t\tspirit.element.setAttribute('my-hair-color', 'lime');\n\t\t\texpect(spirit.haircolor).toBe('lime');\n\t\t});\n\t\tit('should reflect JS properties back to HTML attributes', () => {\n\t\t\tconst spirit = MyHairySpirit.summon();\n\t\t\tspirit.haircolor = 'pink';\n\t\t\texpect(spirit.element.getAttribute('my-hair-color')).toBe('pink');\n\t\t});\n\t\t\n\t});\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/test/src/gui/CSSPlugin.web.spec.js": {
			"title": "CSSPlugin.web.spec",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { Spirit, boot } from 'dataplastique';\n"
						},
						{
							"line": 1,
							"tags": [],
							"tabs": "",
							"desc": "\n\n",
							"code": "export default function() {\n\tdescribe('gui.CSSPlugin', function likethis() {\n\t\tit('obviously needs more testing', () => {\n\t\t\tboot();\n\t\t\tconst spirit = Spirit.summon();\n\t\t\tconst style = spirit.element.style;\n\t\t\tspirit.css.paddingTop = 23;\n\t\t\tspirit.css.marginLeft = 23;\n\t\t\tspirit.css.marginLeft += 2;\n\t\t\texpect(style.paddingTop).toBe('23px');\n\t\t\texpect(style.marginLeft).toBe('25px');\n\t\t});\n\t});\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/test/src/gui/DOMPlugin.web.spec.js": {
			"title": "DOMPlugin.web.spec",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "describe('gui.DOMPlugin', function likethis() {});\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/test/src/gui/IOPlugin.web.spec.js": {
			"title": "IOPlugin.web.spec",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { Model, Spirit, boot } from 'dataplastique';\n"
						},
						{
							"line": 1,
							"tags": [],
							"tabs": "",
							"desc": "Start testing ",
							"code": "export default function() {\n\tclass ModelA extends Model {}\n\tclass ModelB extends Model {}\n\tclass ModelC extends Model {}\n\tdescribe('IOPlugin', function likethis() {\n\t\tit('should work', () => {\n\t\t\tboot();\n\t\t\tconst spirit = Spirit.summon();\n\t\t\tconst result = [];\n\t\t\tspirit.io.on(ModelA, a => {\n\t\t\t\tif (ModelA.is(a)) {\n\t\t\t\t\tresult.push(1);\n\t\t\t\t}\n\t\t\t});\n\t\t\tspirit.io.on([ModelA, { ModelB, ModelC }], (a, x) => {\n\t\t\t\tif (ModelA.is(a) && (ModelB.is(x) || ModelC.is(x))) {\n\t\t\t\t\tresult.push(2);\n\t\t\t\t}\n\t\t\t});\n\t\t\tspirit.io.on([ModelA, ModelB, ModelC], (a, b, c) => {\n\t\t\t\tif (ModelA.is(a) && ModelB.is(b) && ModelC.is(c)) {\n\t\t\t\t\tresult.push(3);\n\t\t\t\t}\n\t\t\t});\n\t\t\tspirit.io.on([ModelA, [ModelB, [ModelC]]], (a, b, c) => {\n\t\t\t\tif (ModelA.is(a) && ModelB.is(b) && ModelC.is(c)) {\n\t\t\t\t\tresult.push(4);\n\t\t\t\t}\n\t\t\t});\n\t\t\tnew ModelA().output();\n\t\t\tnew ModelB().output();\n\t\t\tnew ModelC().output();\n\t\t\texpect(result).toEqual([1, 2, 2, 3, 4]);\n\t\t});\n\t});\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/test/src/gui/ScriptPlugin-0.web.spec.js": {
			"title": "ScriptPlugin-0.web.spec",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { Spirit, boot } from 'dataplastique';\nimport problem from './edbml/problem.edbml.js';\n\n"
						},
						{
							"line": 3,
							"tags": [],
							"tabs": "\t",
							"desc": "\n\n",
							"code": "export default function() {\n"
						},
						{
							"line": 7,
							"tags": [
								{
									"name": "@type",
									"type": "{Map<string,Element>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Confirms identity of elements. ",
							"code": "\tconst snapshot = new Map();\n"
						},
						{
							"line": 12,
							"tags": [
								{
									"name": "@param",
									"type": "{Spirit}",
									"desc": "spirit",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<string>}",
									"desc": "list",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\tfunction confirm(spirit, list) {\n\t\tconst actual = listguids(spirit);\n\t\texpect(actual).toEqual(list);\n\t\tactual.forEach(guid => {\n\t\t\tconst elm = spirit.dom.guid(guid);\n\t\t\tif (snapshot.has(guid)) {\n\t\t\t\texpect(snapshot.get(guid)).toBe(elm);\n\t\t\t}\n\t\t\tsnapshot.set(guid, elm);\n\t\t});\n\t}\n"
						},
						{
							"line": 27,
							"tags": [
								{
									"name": "@param",
									"type": "{Spirit}",
									"desc": "spirit",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<string>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "\tfunction listguids(spirit) {\n\t\treturn spirit.dom\n\t\t\t.guids()\n\t\t\t.map(elm => elm.getAttribute('data-plastique-id'))\n\t\t\t.filter(id => !id.includes('list'))\n\t\t\t.map(id => id.split('-')[1]);\n\t}\n\tdescribe('gui.ScriptPlugin (part 0)', function likethis() {\n\t\tit('must boot', () => {\n\t\t\tboot();\n\t\t\texpect(true).toBe(true);\n\t\t});\n\t\tit('should softupdate', () => {\n\t\t\tconst spirit = Spirit.summon();\n\t\t\tconst list = [1, 2, 3, 4, 5, 6, 7].map(String);\n\t\t\tspirit.script.load(problem).one(list);\n\t\t\tlist.splice(3, 0, 'A');\n\t\t\tlist.splice(2, '1');\n\t\t\tlist.splice(3, 0, 'B');\n\t\t\tlist.splice(4, 0, 'C');\n\t\t\tlist.splice(7, 1, '7');\n\t\t\tlist.splice(8, 1, '6');\n\t\t\tspirit.script.one(list);\n\t\t\tconfirm(spirit, list);\n\t\t\tlist.unshift('E');\n\t\t\tlist.push('D');\n\t\t\tspirit.script.one(list);\n\t\t\tconfirm(spirit, list);\n\t\t\tlist.pop();\n\t\t\tlist.unshift('D');\n\t\t\tspirit.script.one(list);\n\t\t\tconfirm(spirit, list);\n\t\t\tlist.reverse();\n\t\t\tspirit.script.one(list);\n\t\t\tconfirm(spirit, list);\n\t\t\tconst list2 = ['X', 'Y', 'Z'];\n\t\t\tspirit.script.one(list, list2);\n\t\t\tconfirm(spirit, list.concat(list2));\n\t\t\tspirit.script.one(list2, list);\n\t\t\tconfirm(spirit, list2.concat(list));\n\t\t});\n\t});\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/test/src/gui/ScriptPlugin-1.web.spec.js": {
			"title": "ScriptPlugin-1.web.spec",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { Spirit, boot } from 'dataplastique';\nimport hello_world from './edbml/hello-world.edbml.js';\nimport level1 from './edbml/level1.edbml.js';\nimport not_wellformed from './edbml/not_wellformed.edbml.js';\nimport attributes from './edbml/attributes.edbml.js';\nimport guid_recycle from './edbml/guid-recycle.edbml.js';\nimport inline_callbacks from './edbml/inline-callbacks.edbml.js';\nimport root_updates from './edbml/root-updates.edbml.js';\nimport nodes_and_spirits from './edbml/nodes-and-spirits.edbml.js';\n\n"
						},
						{
							"line": 10,
							"tags": [],
							"tabs": "",
							"desc": "\n\n",
							"code": "export default function() {\n\tdescribe('gui.ScriptPlugin (part 1)', function likethis() {\n\t\tit('must be configured to expect well-formed XHTML', () => {\n\t\t\tboot({\n\t\t\t\txhtml: true,\n\t\t\t\tdebug: true\n\t\t\t});\n\t\t\texpect(true).toBe(true);\n\t\t});\n\t\tit('should fail when no script is loaded', () => {\n\t\t\tconst spirit = Spirit.summon();\n\t\t\ttry {\n\t\t\t\tspirit.script.run('Hello World');\n\t\t\t} catch (exception) {\n\t\t\t\texpect(exception.message).toContain('No script loaded');\n\t\t\t}\n\t\t});\n\t\tit('should be able to run a simple script', () => {\n\t\t\tconst spirit = Spirit.summon();\n\t\t\tspirit.script.load(hello_world);\n\t\t\tspirit.script.run('Hello World');\n\t\t\texpect(spirit.script.loaded).toBe(true);\n\t\t\texpect(spirit.dom.html()).toContain('Hello World');\n\t\t\texpect(spirit.dom.html()).toContain('ending plus to continue');\n\t\t\texpect(spirit.dom.html()).toContain('leading plus to continue');\n\t\t});\n\t\tit('should work with the @attribute syntax', () => {\n\t\t\tconst spirit = Spirit.summon();\n\t\t\tspirit.script.load(attributes).run();\n\t\t\tconst p = spirit.dom.q('p');\n\t\t\texpect(p.id).toBe('myid');\n\t\t\texpect(p.className).toBe('myclass');\n\t\t\texpect(p.hasAttribute('href')).toBe(false);\n\t\t\texpect(p.hasAttribute('src')).toBe(false);\n\t\t\texpect(p.dataset.number).toBe('23');\n\t\t\texpect(p.dataset.boolean).toBe('true');\n\t\t\tconst table = spirit.dom.q('table');\n\t\t\texpect(table.getAttribute('cellspacing')).toBe('2');\n\t\t\texpect(table.getAttribute('cellpadding')).toBe('2');\n\t\t});\n\t\tit('should recycle all identified elements', () => {\n\t\t\tconst spirit = Spirit.summon();\n\t\t\tspirit.script.load(guid_recycle).run(0);\n\t\t\tconst elms = () => spirit.dom.guids();\n\t\t\tconst base = elms();\n\t\t\tconst same = list => list.every(elm => base.includes(elm));\n\t\t\tconst test = [0, 1, 2, 3, 4, 3, 2, 1, 0];\n\t\t\texpect(\n\t\t\t\ttest.every(scenario => {\n\t\t\t\t\tconsole.log('scenario', scenario);\n\t\t\t\t\tspirit.script.run(scenario);\n\t\t\t\t\tconsole.log('    result', same(elms()));\n\t\t\t\t\tconsole.log(spirit.dom.html());\n\t\t\t\t\treturn same(elms());\n\t\t\t\t})\n\t\t\t).toBe(true);\n\t\t});\n\t\tit('should convert inline events to DOM event listeners', () => {\n\t\t\tconst spirit = Spirit.summon();\n\t\t\tspirit.script.load(inline_callbacks).run(0);\n\t\t\tconst button = spirit.dom.q('button');\n\t\t\texpect(button.getAttribute('on:click')).toBe(null);\n\t\t\tbutton.click();\n\t\t\texpect(spirit.check).toBe('OK');\n\t\t});\n\t\tit('should refresh the event listeners on every rerun', () => {\n\t\t\tconst spirit = Spirit.summon();\n\t\t\tconst oldran = Math.random();\n\t\t\tspirit.script.load(inline_callbacks).run(0);\n\t\t\tconst button = spirit.dom.q('button');\n\t\t\t[1, 2, 3, 2, 1].reduce(oldran => {\n\t\t\t\tconst newran = Math.random();\n\t\t\t\tspirit.script.run(0, newran);\n\t\t\t\tbutton.click();\n\t\t\t\texpect(spirit.check).toBe(newran);\n\t\t\t\texpect(spirit.check).not.toBe(oldran); \n\t\t\t\treturn newran;\n\t\t\t}, oldran);\n\t\t});\n\t\tit('should remove the event listener when the attribute is gone', () => {\n\t\t\tconst spirit = Spirit.summon();\n\t\t\tspirit.script.load(inline_callbacks).run(0);\n\t\t\tconst button = spirit.dom.q('button');\n\t\t\tspirit.script.run(1);\n\t\t\tbutton.click();\n\t\t\texpect(spirit.check).toBe(undefined);\n\t\t});\n\t\tit('should remove the event listener when element itself is gone', () => {\n\t\t\tconst spirit = Spirit.summon();\n\t\t\tspirit.script.load(inline_callbacks).run(0);\n\t\t\tconst button = spirit.dom.q('button');\n\t\t\tspirit.script.run(2);\n\t\t\tbutton.click();\n\t\t\texpect(spirit.check).toBe(undefined);\n\t\t});\n\t\tit('should detect whenever event listeners appear and disappear', () => {\n\t\t\tconst spirit = Spirit.summon();\n\t\t\tspirit.script.load(inline_callbacks);\n\t\t\tspirit.script.run(1);\n\t\t\tconst button = spirit.dom.q('button');\n\t\t\tspirit.script.run(0);\n\t\t\tbutton.click();\n\t\t\texpect(spirit.check).toBe('OK');\n\t\t\tspirit.check = undefined;\n\t\t\tspirit.script.run(3);\n\t\t\tbutton.click();\n\t\t\texpect(spirit.check).toBe('still OK');\n\t\t\tspirit.check = undefined;\n\t\t\tspirit.script.run(1);\n\t\t\tbutton.click();\n\t\t\texpect(spirit.check).toBe(undefined);\n\t\t});\n\t\tit('should synchronize root element attributes', () => {\n\t\t\tconst spirit = Spirit.summon();\n\t\t\tconst hascss = css => spirit.css.has(css);\n\t\t\tconst hastip = tip => spirit.element.title === tip;\n\t\t\tspirit.script.load(root_updates);\n\t\t\tspirit.script.run(0).run(1, 'myclass');\n\t\t\texpect(hascss('myclass')).toBe(true);\n\t\t\tspirit.script.run(1, null, 'mytooltip');\n\t\t\texpect(hascss('myclass')).toBe(false);\n\t\t\texpect(hastip('mytooltip')).toBe(true);\n\t\t\tspirit.script.run(1, 'otherclass');\n\t\t\texpect(hascss('otherclass')).toBe(true);\n\t\t\tspirit.script.run(0);\n\t\t\texpect(hascss('otherclass')).toBe(false);\n\t\t\texpect(hastip('mytooltip')).toBe(false);\n\t\t});\n\t\tit('should synchronize root element callbacks', () => {\n\t\t\tconst spirit = Spirit.summon();\n\t\t\tconst action = () => (spirit.check = 'OK');\n\t\t\tspirit.script.load(root_updates);\n\t\t\tspirit.script.run(0).run(2, null, null, action);\n\t\t\tspirit.element.click();\n\t\t\texpect(spirit.check).toBe('OK');\n\t\t});\n\t\tit('should be able to import external scripts', () => {\n\t\t\tconst spirit = Spirit.summon();\n\t\t\tspirit.script.load(level1).run('OK');\n\t\t\texpect(spirit.dom.html()).toContain('OK');\n\t\t});\n\t});\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/test/src/gui/ScriptPlugin-2.web.spec.js": {
			"title": "ScriptPlugin-2.web.spec",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { Spirit, boot } from 'dataplastique';\nimport expect_equalnode from './edbml/expect-equalnode.edbml.js';\nfunction getscenarios(id) {\n\treturn [\n\t\t`<div guid=\"table\">\n\t\t\t<div guid=\"row0\">\n\t\t\t\t<div guid=\"A\"></div>\n\t\t\t\t<div guid=\"B\"></div>\n\t\t\t\t<div guid=\"C\"></div>\n\t\t\t\t<div guid=\"D\"></div>\n\t\t\t\t<div guid=\"E\"></div>\n\t\t\t\t<div guid=\"F\"></div>\n\t\t\t\t<div guid=\"G\"></div>\n\t\t\t</div>\n\t\t\t<div guid=\"row1\">\n\t\t\t\t<div guid=\"cell11\"></div>\n\t\t\t\t<div guid=\"cell12\"></div>\n\t\t\t\t<div guid=\"cell13\"></div>\n\t\t\t</div>\n\t\t\t<div guid=\"row2\">\n\t\t\t\t<div guid=\"cell21\"></div>\n\t\t\t\t<div guid=\"cell22\"></div>\n\t\t\t\t<div guid=\"cell23\"></div>\n\t\t\t</div>\n\t\t\t<div guid=\"row3\">\n\t\t\t\t<div guid=\"cell31\">Cell is here</div>\n\t\t\t\t<div guid=\"cell32\"></div>\n\t\t\t\t<div guid=\"cell33\"></div>\n\t\t\t</div>\n\t\t\t<div guid=\"row4\">\n\t\t\t\t<div guid=\"cell41\"></div>\n\t\t\t\t<div guid=\"cell42\"></div>\n\t\t\t\t<div guid=\"cell43\"></div>\n\t\t\t</div>\n\t\t\t<div guid=\"row5\">\n\t\t\t\t<div guid=\"cell51\"></div>\n\t\t\t\t<div guid=\"cell52\"></div>\n\t\t\t\t<div guid=\"cell53\"></div>\n\t\t\t</div>\n\t\t</div>`,\n\t\t`<section>Section was added</section>\n\t\t<div guid=\"table\" class=\"addedclassname\">\n\t\t\t<div guid=\"row0\">\n\t\t\t\t<div guid=\"A\"></div>\n\t\t\t\t<div guid=\"B\"></div>\n\t\t\t\t<div guid=\"C\"></div>\n\t\t\t\t<div guid=\"D\"></div>\n\t\t\t\t<div guid=\"E\"></div>\n\t\t\t\t<div guid=\"F\"></div>\n\t\t\t\t<div guid=\"G\"></div>\n\t\t\t</div>\n\t\t\t<div guid=\"row1\">\n\t\t\t\t<div guid=\"cell11\"></div>\n\t\t\t\t<div guid=\"cell12\">Text was added</div>\n\t\t\t\t<div guid=\"cell13\">Text was added</div>\n\t\t\t</div>\n\t\t\t<div guid=\"row2\">\n\t\t\t\t<div guid=\"cell21\"></div>\n\t\t\t\t<div guid=\"cell22\"></div>\n\t\t\t\t<div guid=\"cell23\">Text was added</div>\n\t\t\t</div>\n\t\t\t<div guid=\"row3\">\n\t\t\t\t<div guid=\"cell32\"></div>\n\t\t\t\t<div guid=\"cell31\">Cell was moved</div>\n\t\t\t\t<div guid=\"cell33\"></div>\n\t\t\t</div>\n\t\t\t<section>\n\t\t\t\t<div guid=\"row4\">\n\t\t\t\t\t<div guid=\"cell41\"></div>\n\t\t\t\t\t<div guid=\"cell42\"></div>\n\t\t\t\t\t<div guid=\"cell43\"></div>\n\t\t\t\t\t<div guid=\"cell44\">Cell was added</div>\n\t\t\t\t\t<div guid=\"cell45\">Cell was added</div>\n\t\t\t\t</div>\n\t\t\t\t<div guid=\"row5\">\n\t\t\t\t\t<div guid=\"cell51\"></div>\n\t\t\t\t\t<div guid=\"cell52\"></div>\n\t\t\t\t\t<div guid=\"cell53\"></div>\n\t\t\t\t</div>\n\t\t\t</section>\n\t\t</div>`,\n\t\t`<div guid=\"table\">\n\t\t\t<div guid=\"row1\">\n\t\t\t\t<div guid=\"cell11\"></div>\n\t\t\t\t<div guid=\"cell12\">Text was changed</div>\n\t\t\t\t<div guid=\"cell13\">\n\t\t\t\t\t<div guid=\"row5\">\n\t\t\t\t\t\t<section>\n\t\t\t\t\t\t\t<div guid=\"cell51\"></div>\n\t\t\t\t\t\t\t<div guid=\"cell52\"></div>\n\t\t\t\t\t\t\t<div guid=\"cell53\"></div>\n\t\t\t\t\t\t</section>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div guid=\"row2\">\n\t\t\t\t<div guid=\"cell21\">\n\t\t\t\t\t<div guid=\"cell23\">Text was changed and cell was moved</div>\n\t\t\t\t</div>\n\t\t\t\t<div guid=\"cell22\"></div>\n\t\t\t</div>\n\t\t\t<div guid=\"row3\">\n\t\t\t\t<div guid=\"cell31\">Cell was moved back</div>\n\t\t\t\t<div guid=\"cell32\"></div>\n\t\t\t\t<div guid=\"cell33\"></div>\n\t\t\t</div>\n\t\t\t<div guid=\"row4\">\n\t\t\t\t<div guid=\"cell41\"></div>\n\t\t\t\t<div guid=\"cell42\"></div>\n\t\t\t\t<div guid=\"cell43\"></div>\n\t\t\t</div>\n\t\t</div>`,\n\t\t`<div guid=\"table\" title=\"addedtitle\">\n\t\t\t<div guid=\"row2\">\n\t\t\t\t<div guid=\"cell21\">\n\t\t\t\t\t<div guid=\"cell23\">\n\t\t\t\t\t\t<div guid=\"row1\">\n\t\t\t\t\t\t\t<div guid=\"cell11\">Row was moved</div>\n\t\t\t\t\t\t\t<div guid=\"cell12\"></div>\n\t\t\t\t\t\t\t<div guid=\"cell13\">\n\t\t\t\t\t\t\t\t<div guid=\"row5\">\n\t\t\t\t\t\t\t\t\t<div guid=\"cell51\">\n\t\t\t\t\t\t\t\t\t\t<div guid=\"row3\">\n\t\t\t\t\t\t\t\t\t\t\t<div guid=\"cell31\">Row was moved</div>\n\t\t\t\t\t\t\t\t\t\t\t<section>\n\t\t\t\t\t\t\t\t\t\t\t\t<div guid=\"cell32\"></div>\n\t\t\t\t\t\t\t\t\t\t\t\t<div guid=\"cell33\"></div>\n\t\t\t\t\t\t\t\t\t\t\t</section>\n\t\t\t\t\t\t\t\t\t\t\t<section></section>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t<div guid=\"row4\">\n\t\t\t\t\t\t\t\t\t\t\t<div guid=\"cell41\"></div>\n\t\t\t\t\t\t\t\t\t\t\t<div guid=\"cell42\">\n\t\t\t\t\t\t\t\t\t\t\t\t<div guid=\"cell22\">Cell was moved</div>\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t<div guid=\"cell43\"></div>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t<div guid=\"cell52\"></div>\n\t\t\t\t\t\t\t\t\t<div guid=\"cell53\"></div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>`,\n\t\t`<div guid=\"row1\" class=\"addedclassname\">\n\t\t\t<div guid=\"row2\">\n\t\t\t\t<div guid=\"row3\">\n\t\t\t\t\t<div guid=\"row4\">\n\t\t\t\t\t\t<div guid=\"row5\">\n\t\t\t\t\t\t\t<div guid=\"table\">\n\t\t\t\t\t\t\t\t<div guid=\"cell11\">\n\t\t\t\t\t\t\t\t\t<div guid=\"cell51\"></div>\n\t\t\t\t\t\t\t\t\t<div guid=\"cell52\"></div>\n\t\t\t\t\t\t\t\t\t<div guid=\"cell53\"></div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<section>\n\t\t\t\t\t\t\t\t<div guid=\"cell12\"></div>\n\t\t\t\t\t\t\t\t<div guid=\"cell13\"></div>\n\t\t\t\t\t\t\t\t<div guid=\"cell21\"></div>\n\t\t\t\t\t\t\t\t<div guid=\"cell22\"></div>\n\t\t\t\t\t\t\t\t<div guid=\"cell23\"></div>\n\t\t\t\t\t\t\t\t<div guid=\"cell31\"></div>\n\t\t\t\t\t\t\t\t<div guid=\"cell32\"></div>\n\t\t\t\t\t\t\t\t<div guid=\"cell33\"></div>\n\t\t\t\t\t\t\t</section>\n\t\t\t\t\t\t</div>\t\n\t\t\t\t\t</div>\t\n\t\t\t\t</div>\t\n\t\t\t</div>\n\t\t</div>\n\t\t<div guid=\"cell41\"></div>\n\t\t<div guid=\"cell42\"></div>\n\t\t<div guid=\"cell43\"></div>`,\n\t\t`<article>\n\t\t\t<section class=\"head\">\n\t\t\t\t<div class=\"docs\">\n\t\t\t\t\t<h1><p>Collection</p></h1>\n\t\t\t\t</div>\n\t\t\t\t<pre class=\"code\"></pre>\n\t\t\t</section>\n\t\t\t<section data-line=\"0\" class=\"intro\" >\n\t\t\t\t<div class=\"docs\">\n\t\t\t\t\t<div class=\"desc\"></div>\n\t\t\t\t</div>\n\t\t\t\t<pre class=\"code\">\n\t\t\t\t</pre>\n\t\t\t</section>\n\t\t\t<section data-line=\"2\" >\n\t\t\t\t<div class=\"docs\">\n\t\t\t\t\t<div class=\"desc\">\n\t\t\t\t\t\t<p>Base collection.</p>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<pre class=\"code\">\n\t\t\t\t</pre>\n\t\t\t</section>\n\t\t</article>`,\n\t\t`<article>\n\t\t\t<section class=\"head\">\n\t\t\t\t<div class=\"docs\">\n\t\t\t\t\t<h1><p>Model</p></h1>\n\t\t\t\t</div>\n\t\t\t\t<pre class=\"code\"></pre>\n\t\t\t</section>\n\t\t\t<section data-line=\"0\" class=\"intro\" >\n\t\t\t\t<div class=\"docs\">\n\t\t\t\t\t<div class=\"desc\"></div>\n\t\t\t\t</div>\n\t\t\t\t<pre class=\"code\">\n\t\t\t\t</pre>\n\t\t\t</section>\n\t\t\t<section data-line=\"2\" >\n\t\t\t\t<div class=\"docs\">\n\t\t\t\t\t<div class=\"desc\">\n\t\t\t\t\t\t<p>Base model.</p>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<pre class=\"code\">\n\t\t\t\t</pre>\n\t\t\t</section>\n\t\t</article>`\n\t].map(html => {\n\t\tconst temp = document.createElement('template');\n\t\ttemp.innerHTML = html.replace(/guid=\"/g, `data-plastique-id=\"${id}-`);\n\t\treturn temp.content;\n\t});\n}\n"
						},
						{
							"line": 231,
							"tags": [
								{
									"name": "@param",
									"type": "{Node}",
									"desc": "node",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<Element>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Extract child elements. ",
							"code": "function elements(node) {\n\treturn [...node.childNodes].filter(n => n.nodeType === Node.ELEMENT_NODE);\n}\n"
						},
						{
							"line": 239,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Element}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Remove empty textnodes and sync class attribute before comparing DOM. ",
							"code": "function strip(elm) {\n\tconst empty = [];\n\t[...elm.childNodes].forEach(node => {\n\t\tswitch (node.nodeType) {\n\t\t\tcase Node.ELEMENT_NODE:\n\t\t\t\tstrip(node);\n\t\t\t\tbreak;\n\t\t\tcase Node.TEXT_NODE:\n\t\t\t\tif (node.data.trim() === '') {\n\t\t\t\t\tempty.push(node);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t});\n\tempty.forEach(node => node.remove());\n\tif (elm.className === '') {\n\t\telm.removeAttribute('class');\n\t}\n\treturn elm;\n}\n"
						},
						{
							"line": 264,
							"tags": [
								{
									"name": "@param",
									"type": "{Spirit}",
									"desc": "spirit",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<Element>}",
									"desc": "scenarios",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{number}",
									"desc": "key",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Confirm that the spirits DOM subtree matches the given scenario, ",
							"code": "function expectequalnodes(spirit, scenarios, key) {\n\tconst sources = elements(spirit.element).map(strip);\n\tconst targets = elements(scenarios[key]).map(strip);\n\tconst similar = sources.length === targets.length;\n\tif (!similar) {\n\t\tconsole.error(\n\t\t\t`Broken scenario ${key}: Unexpected elements count: `,\n\t\t\t`Expected ${targets.length}, found ${sources.length}`\n\t\t);\n\t}\n\texpect(similar).toBe(true);\n\tsources.forEach((source, index) => {\n\t\tconst target = targets[index];\n\t\tconst equals = source.isEqualNode(target);\n\t\tif (!equals) {\n\t\t\tconsole.error(`Broken scenario ${key}: Unexpected DOM structure\n\t\t\t\tExpected\\n${target.outerHTML},\n\t\t\t\tFound\\n${source.outerHTML}`);\n\t\t}\n\t\texpect(equals).toBe(true);\n\t});\n}\n"
						},
						{
							"line": 292,
							"tags": [
								{
									"name": "@param",
									"type": "{Spirit}",
									"desc": "spirit",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{number}",
									"desc": "key",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Confirm that all identified elements are the same as they used to be. ",
							"code": "function expectrecycleids(spirit, key) {\n\tconst olds = expectrecycleids.oldnodes;\n\tconst news = spirit.dom.guids();\n\texpectrecycleids.oldnodes = news;\n\tif (olds) {\n\t\tolds.forEach(elm => {\n\t\t\tconst guid = elm.getAttribute('data-plastique-id');\n\t\t\tif (spirit.dom.guid(guid)) {\n\t\t\t\tconst same = news.includes(elm);\n\t\t\t\tif (!same) {\n\t\t\t\t\tconsole.error(`Broken scenario ${key}: False identity in ${guid}`);\n\t\t\t\t}\n\t\t\t\texpect(same).toBe(true);\n\t\t\t}\n\t\t});\n\t}\n}\n"
						},
						{
							"line": 314,
							"tags": [],
							"tabs": "",
							"desc": "\n\n",
							"code": "export default function() {\n\tdescribe('gui.ScriptPlugin (part 2)', function likethis() {\n\t\tit('must boot before we begin', () => {\n\t\t\tboot();\n\t\t\texpect(true).toBe(true);\n\t\t});\n\t\tit('matches expected output', () => {\n\t\t\tconst spirit = Spirit.summon();\n\t\t\tconst scenes = getscenarios(spirit.$id);\n\t\t\tspirit.script.load(expect_equalnode);\n\t\t\t[...Array(scenes.length).keys()].forEach(key => {\n\t\t\t\tspirit.script.run(key);\n\t\t\t\texpectequalnodes(spirit, scenes, key);\n\t\t\t\texpectrecycleids(spirit, scenes, key);\n\t\t\t});\n\t\t});\n\t});\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/test/src/gui/ScriptPlugin-3.web.spec.js": {
			"title": "ScriptPlugin-3.web.spec",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { Spirit, channeling, boot } from 'dataplastique';\nimport io_simple from './edbml/io-simple.edbml.js';\nimport io_johnson from './edbml/io-johnson.edbml.js';\nimport io_flemming from './edbml/io-flemming.edbml.js';\nimport PersonModel from './models/PersonModel.js';\nimport PersonCollection from './models/PersonCollection.js';\nimport DonkeyModel from './models/DonkeyModel.js';\nimport NumberCollection from './models/NumberCollection.js';\nimport pass_props from './edbml/pass-props.edbml.js';\n"
						},
						{
							"line": 9,
							"tags": [
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "cb",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Execute somewhat later. The timing depends on two chained async schedules: \n- First, `Tick.nextFrame` runs in the Observers setup (to minimize callbacks) \n- Then, `Tick.nextFrame` runs in the ScriptPlugin (to minimize rendering) TODO: Global interface hook for exact post-render callback ",
							"code": "function later(cb) {\n\tsetTimeout(cb, 50); \n}\n"
						},
						{
							"line": 19,
							"tags": [
								{
									"name": "@param",
									"type": "{Spirit}",
									"desc": "spirit",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get spirit HTML. ",
							"code": "function html(spirit) {\n\treturn spirit.dom.html();\n}\n"
						},
						{
							"line": 27,
							"tags": [],
							"tabs": "\t",
							"desc": "TODO: Must this be defined before `boot()` or what? ",
							"code": "@channeling('my-configurable-spirit')\nclass ConfigurableSpirit extends Spirit {\n\tmodel = 23;\n\tfirstname = '';\n\tlastname = '';\n"
						},
						{
							"line": 35,
							"tags": [
								{
									"name": "@param",
									"type": "{Class<HTMLElement>}",
									"desc": "CustomElm",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "spirit",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Class<HTMLElement>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Experimental! ",
							"code": "\tstatic api(CustomElm, spirit) {\n\t\treturn class extends CustomElm {\n\t\t\tset usermodel(model) {\n\t\t\t\tspirit(this).model = model;\n\t\t\t}\n\t\t\tusername(first, last) {\n\t\t\t\tspirit(this).firstname = first;\n\t\t\t\tspirit(this).lastname = last;\n\t\t\t}\n\t\t};\n\t}\n}\n"
						},
						{
							"line": 53,
							"tags": [],
							"tabs": "",
							"desc": "\n\n",
							"code": "export default function() {\n\tdescribe('gui.ScriptPlugin (part 3)', function likethis() {\n\t\tit('must boot before we begin', () => {\n\t\t\tboot();\n\t\t\texpect(true).toBe(true);\n\t\t});\n\t\tit('should render (async) whenever model properties change', done => {\n\t\t\tconst spirit = Spirit.summon();\n\t\t\tconst person = new PersonModel({ name: 'Barack' });\n\t\t\tconst donkey = new DonkeyModel({ name: 'Donald' });\n\t\t\tspirit.script.load(io_simple).run(person, donkey);\n\t\t\tperson.name = 'Jim';\n\t\t\tdonkey.name = 'Bob';\n\t\t\tlater(() => {\n\t\t\t\texpect(html(spirit)).toContain('Jim');\n\t\t\t\texpect(html(spirit)).toContain('Bob');\n\t\t\t\tperson.pet = donkey;\n\t\t\t\tlater(() => {\n\t\t\t\t\texpect(html(spirit)).toContain('colleagues');\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t\tit('should also work with collections', done => {\n\t\t\tconst spirit = Spirit.summon();\n\t\t\tconst persons = new PersonCollection(\n\t\t\t\t{ name: 'Jim Starenko' },\n\t\t\t\t{ name: 'Bob Geldof' },\n\t\t\t\t{ name: 'Ole Ganondorf' }\n\t\t\t);\n\t\t\tspirit.script.load(io_johnson).run(persons);\n\t\t\t['Jim', 'Bob', 'Ole'].every(name => {\n\t\t\t\texpect(html(spirit)).toContain(name);\n\t\t\t});\n\t\t\tpersons.push({ name: 'John' });\n\t\t\tlater(() => {\n\t\t\t\texpect(html(spirit)).toContain('John');\n\t\t\t\tpersons.splice(0, 1, { name: 'Else' });\n\t\t\t\tlater(() => {\n\t\t\t\t\texpect(html(spirit)).toContain('Else');\n\t\t\t\t\texpect(html(spirit)).not.toContain('Jim');\n\t\t\t\t\tpersons[0].name = 'Ricardo';\n\t\t\t\t\tlater(() => {\n\t\t\t\t\t\texpect(html(spirit)).toContain('Ricardo');\n\t\t\t\t\t\texpect(html(spirit)).not.toContain('Else');\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t\tit('should work in the cornercase scenario', done => {\n\t\t\tconst spirit = Spirit.summon();\n\t\t\tconst numbers = new NumberCollection(0, 1, 2, 3);\n\t\t\tspirit.script.load(io_flemming).run(numbers);\n\t\t\texpect(html(spirit)).toBe('');\n\t\t\tnumbers[3] = Math.PI;\n\t\t\tlater(() => {\n\t\t\t\texpect(html(spirit)).toContain('OK');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t\tit('should support the `do:elm` interface to manipulate rendered element', () => {\n\t\t\tconst spirit = Spirit.summon();\n\t\t\tspirit.dom.appendTo(document.body);\n\t\t\tspirit.script.load(pass_props).run({\n\t\t\t\tfirstname: 'Jim Bob',\n\t\t\t\tlastname: 'Johnson'\n\t\t\t});\n\t\t\tconst elmprops = spirit.dom.guid('elm-props');\n\t\t\tconst elmcalls = spirit.dom.guid('elm-calls');\n\t\t\texpect(elmprops.title).toBe('Jim Bob Johnson');\n\t\t\texpect(elmcalls.title).toBe('Jim Bob Johnson');\n\t\t\tspirit.dom.remove();\n\t\t});\n\t});\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/test/src/gui/Spirit.web.spec.js": {
			"title": "Spirit.web.spec",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { Spirit, channeling, boot, get, attribute } from 'dataplastique';\nconst create = tag => document.createElement(tag);\nconst append = elm => document.body.appendChild(elm);\nconst remove = elm => document.body.removeChild(elm);\nexport default function() {\n\tdescribe('gui.Spirit', function likethis() {\n\t\tchanneling('my-named-spirit', function MySpiritWrapper({ css }) {\n\t\t\tcss.add('constructed'); \n\t\t\treturn {\n\t\t\t\tonready() {\n\t\t\t\t\tcss.add('ready');\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t\tchanneling('my-anonymous-spirit', ({ css }) => ({\n\t\t\tonconstruct: () => css.add('constructed'),\n\t\t\tonready: () => css.add('ready')\n\t\t}));\n\t\tchanneling('my-typed-spirit', function Johnson(spirit) {\n\t\t\tJohnson.spirit = () => ({\n\t\t\t\telement: Element,\n\t\t\t\tname: String,\n\t\t\t\tage: Number\n\t\t\t});\n\t\t\treturn {\n\t\t\t\tonready() {\n\t\t\t\t\tthis.name = 'John';\n\t\t\t\t\tthis.age = '49';\n\t\t\t\t\tthis.occupation = 'Actor';\n\t\t\t\t\talert(this.occupation);\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t\tit('must boot first', done => {\n\t\t\tboot().then(() => {\n\t\t\t\texpect(boot.done).toBe(true);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t\tit('can be declared with an arrow function', done => {\n\t\t\tget(append(create('my-anonymous-spirit')), spirit => {\n\t\t\t\texpect(spirit.constructor.name).toBe('Anonymous');\n\t\t\t\texpect(spirit.css.has('constructed')).toBe(true);\n\t\t\t\texpect(spirit.css.has('ready')).toBe(true);\n\t\t\t\tremove(spirit.element);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t\tit('can be declared with a named function', done => {\n\t\t\tget(append(create('my-named-spirit')), spirit => {\n\t\t\t\texpect(spirit.constructor.name).toBe('Anonymous');\n\t\t\t\texpect(spirit.css.has('constructed')).toBe(true);\n\t\t\t\texpect(spirit.css.has('ready')).toBe(true);\n\t\t\t\tremove(spirit.element);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t\t\n\t});\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/test/src/gui/edbml/attributes.edbml": {
			"title": "attributes",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "Testing the hacky @attribute syntax. ",
							"code": "export default function() {\n\tsingleAttributes();\n\tbulkAttributes();\n}\n\n"
						},
						{
							"line": 8,
							"tags": [],
							"tabs": "",
							"desc": "Single attributes. ",
							"code": "function singleAttributes() {\n\t@id = 'myid';\n\t@class = 'myclass';\n\t@href = null;\n\t@src = undefined;\n\t@data-number = 23;\n\t@data-boolean = true;\n\t<p @id @class @href @src @data-number @data-boolean></p>\n}\n\n"
						},
						{
							"line": 21,
							"tags": [],
							"tabs": "",
							"desc": "Multiple attributes. ",
							"code": "function bulkAttributes() {\n\t@tableprops = {\n\t\tsummary: 'Multiple @attributes can be declared with an object like this',\n\t\tcellspacing: 2,\n\t\tcellpadding: 2\n\t};\n\t<table @tableprops></table>\n}\n\n"
						}
					]
				}
			],
			"type": "text/edbml"
		},
		"packages/test/src/gui/edbml/expect-equalnode.edbml": {
			"title": "expect-equalnode",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "Resulting HTML output must be manually synchronized with the test! ",
							"code": "export default function(scenario) {\n\tswitch(scenario) {\n\t\tcase 0:\n\t\t\t<div guid=\"table\">\n\t\t\t\t<div guid=\"row0\">\n\t\t\t\t\t<div guid=\"A\"></div>\n\t\t\t\t\t<div guid=\"B\"></div>\n\t\t\t\t\t<div guid=\"C\"></div>\n\t\t\t\t\t<div guid=\"D\"></div>\n\t\t\t\t\t<div guid=\"E\"></div>\n\t\t\t\t\t<div guid=\"F\"></div>\n\t\t\t\t\t<div guid=\"G\"></div>\n\t\t\t\t</div>\n\t\t\t\t<div guid=\"row1\">\n\t\t\t\t\t<div guid=\"cell11\"></div>\n\t\t\t\t\t<div guid=\"cell12\"></div>\n\t\t\t\t\t<div guid=\"cell13\"></div>\n\t\t\t\t</div>\n\t\t\t\t<div guid=\"row2\">\n\t\t\t\t\t<div guid=\"cell21\"></div>\n\t\t\t\t\t<div guid=\"cell22\"></div>\n\t\t\t\t\t<div guid=\"cell23\"></div>\n\t\t\t\t</div>\n\t\t\t\t<div guid=\"row3\">\n\t\t\t\t\t<div guid=\"cell31\">Cell is here</div>\n\t\t\t\t\t<div guid=\"cell32\"></div>\n\t\t\t\t\t<div guid=\"cell33\"></div>\n\t\t\t\t</div>\n\t\t\t\t<div guid=\"row4\">\n\t\t\t\t\t<div guid=\"cell41\"></div>\n\t\t\t\t\t<div guid=\"cell42\"></div>\n\t\t\t\t\t<div guid=\"cell43\"></div>\n\t\t\t\t</div>\n\t\t\t\t<div guid=\"row5\">\n\t\t\t\t\t<div guid=\"cell51\"></div>\n\t\t\t\t\t<div guid=\"cell52\"></div>\n\t\t\t\t\t<div guid=\"cell53\"></div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t<section>Section was added</section>\n\t\t\t<div guid=\"table\" class=\"addedclassname\">\n\t\t\t\t<div guid=\"row0\">\n\t\t\t\t\t<div guid=\"A\"></div>\n\t\t\t\t\t<div guid=\"B\"></div>\n\t\t\t\t\t<div guid=\"C\"></div>\n\t\t\t\t\t<div guid=\"D\"></div>\n\t\t\t\t\t<div guid=\"E\"></div>\n\t\t\t\t\t<div guid=\"F\"></div>\n\t\t\t\t\t<div guid=\"G\"></div>\n\t\t\t\t</div>\n\t\t\t\t<div guid=\"row1\">\n\t\t\t\t\t<div guid=\"cell11\"></div>\n\t\t\t\t\t<div guid=\"cell12\">Text was added</div>\n\t\t\t\t\t<div guid=\"cell13\">Text was added</div>\n\t\t\t\t</div>\n\t\t\t\t<div guid=\"row2\">\n\t\t\t\t\t<div guid=\"cell21\"></div>\n\t\t\t\t\t<div guid=\"cell22\"></div>\n\t\t\t\t\t<div guid=\"cell23\">Text was added</div>\n\t\t\t\t</div>\n\t\t\t\t<div guid=\"row3\">\n\t\t\t\t\t<div guid=\"cell32\"></div>\n\t\t\t\t\t<div guid=\"cell31\">Cell was moved</div>\n\t\t\t\t\t<div guid=\"cell33\"></div>\n\t\t\t\t</div>\n\t\t\t\t<section>\n\t\t\t\t\t<div guid=\"row4\">\n\t\t\t\t\t\t<div guid=\"cell41\"></div>\n\t\t\t\t\t\t<div guid=\"cell42\"></div>\n\t\t\t\t\t\t<div guid=\"cell43\"></div>\n\t\t\t\t\t\t<div guid=\"cell44\">Cell was added</div>\n\t\t\t\t\t\t<div guid=\"cell45\">Cell was added</div>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div guid=\"row5\">\n\t\t\t\t\t\t<div guid=\"cell51\"></div>\n\t\t\t\t\t\t<div guid=\"cell52\"></div>\n\t\t\t\t\t\t<div guid=\"cell53\"></div>\n\t\t\t\t\t</div>\n\t\t\t\t</section>\n\t\t\t</div>\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tconsole.log('(scenario 2)');\n\t\t\t<div guid=\"table\">\n\t\t\t\t<div guid=\"row1\">\n\t\t\t\t\t<div guid=\"cell11\"></div>\n\t\t\t\t\t<div guid=\"cell12\">Text was changed</div>\n\t\t\t\t\t<div guid=\"cell13\">\n\t\t\t\t\t\t<div guid=\"row5\">\n\t\t\t\t\t\t\t<section>\n\t\t\t\t\t\t\t\t<div guid=\"cell51\"></div>\n\t\t\t\t\t\t\t\t<div guid=\"cell52\"></div>\n\t\t\t\t\t\t\t\t<div guid=\"cell53\"></div>\n\t\t\t\t\t\t\t</section>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<div guid=\"row2\">\n\t\t\t\t\t<div guid=\"cell21\">\n\t\t\t\t\t\t<div guid=\"cell23\">Text was changed and cell was moved</div>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div guid=\"cell22\"></div>\n\t\t\t\t</div>\n\t\t\t\t<div guid=\"row3\">\n\t\t\t\t\t<div guid=\"cell31\">Cell was moved back</div>\n\t\t\t\t\t<div guid=\"cell32\"></div>\n\t\t\t\t\t<div guid=\"cell33\"></div>\n\t\t\t\t</div>\n\t\t\t\t<div guid=\"row4\">\n\t\t\t\t\t<div guid=\"cell41\"></div>\n\t\t\t\t\t<div guid=\"cell42\"></div>\n\t\t\t\t\t<div guid=\"cell43\"></div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tconsole.log('(scenario 3)');\n\t\t\t<div guid=\"table\" title=\"addedtitle\">\n\t\t\t\t<div guid=\"row2\">\n\t\t\t\t\t<div guid=\"cell21\">\n\t\t\t\t\t\t<div guid=\"cell23\">\n\t\t\t\t\t\t\t<div guid=\"row1\">\n\t\t\t\t\t\t\t\t<div guid=\"cell11\">Row was moved</div>\n\t\t\t\t\t\t\t\t<div guid=\"cell12\"></div>\n\t\t\t\t\t\t\t\t<div guid=\"cell13\"\t>\n\t\t\t\t\t\t\t\t\t<div guid=\"row5\">\n\t\t\t\t\t\t\t\t\t\t<div guid=\"cell51\">\n\t\t\t\t\t\t\t\t\t\t\t<div guid=\"row3\">\n\t\t\t\t\t\t\t\t\t\t\t\t<div guid=\"cell31\">Row was moved</div>\n\t\t\t\t\t\t\t\t\t\t\t\t<section>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<div guid=\"cell32\"></div>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<div guid=\"cell33\"></div>\n\t\t\t\t\t\t\t\t\t\t\t\t</section>\n\t\t\t\t\t\t\t\t\t\t\t\t<section></section>\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t<div guid=\"row4\">\n\t\t\t\t\t\t\t\t\t\t\t\t<div guid=\"cell41\"></div>\n\t\t\t\t\t\t\t\t\t\t\t\t<div guid=\"cell42\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t<div guid=\"cell22\">Cell was moved</div>\n\t\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t\t<div guid=\"cell43\"></div>\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t<div guid=\"cell52\"></div>\n\t\t\t\t\t\t\t\t\t\t<div guid=\"cell53\"></div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\t<div guid=\"row1\" class=\"addedclassname\">\n\t\t\t\t<div guid=\"row2\">\n\t\t\t\t\t<div guid=\"row3\">\n\t\t\t\t\t\t<div guid=\"row4\">\n\t\t\t\t\t\t\t<div guid=\"row5\">\n\t\t\t\t\t\t\t\t<div guid=\"table\">\n\t\t\t\t\t\t\t\t\t<div guid=\"cell11\">\n\t\t\t\t\t\t\t\t\t\t<div guid=\"cell51\"></div>\n\t\t\t\t\t\t\t\t\t\t<div guid=\"cell52\"></div>\n\t\t\t\t\t\t\t\t\t\t<div guid=\"cell53\"></div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<section>\n\t\t\t\t\t\t\t\t\t<div guid=\"cell12\"></div>\n\t\t\t\t\t\t\t\t\t<div guid=\"cell13\"></div>\n\t\t\t\t\t\t\t\t\t<div guid=\"cell21\"></div>\n\t\t\t\t\t\t\t\t\t<div guid=\"cell22\"></div>\n\t\t\t\t\t\t\t\t\t<div guid=\"cell23\"></div>\n\t\t\t\t\t\t\t\t\t<div guid=\"cell31\"></div>\n\t\t\t\t\t\t\t\t\t<div guid=\"cell32\"></div>\n\t\t\t\t\t\t\t\t\t<div guid=\"cell33\"></div>\n\t\t\t\t\t\t\t\t</section>\n\t\t\t\t\t\t\t</div>\t\n\t\t\t\t\t\t</div>\t\n\t\t\t\t\t</div>\t\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div guid=\"cell41\"></div>\n\t\t\t<div guid=\"cell42\"></div>\n\t\t\t<div guid=\"cell43\"></div>\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\t<article>\n\t\t\t\t<section class=\"head\">\n\t\t\t\t\t<div class=\"docs\">\n\t\t\t\t\t\t<h1><p>Collection</p></h1>\n\t\t\t\t\t</div>\n\t\t\t\t\t<pre class=\"code\"></pre>\n\t\t\t\t</section>\n\t\t\t\t<section data-line=\"0\" class=\"intro\" >\n\t\t\t\t\t<div class=\"docs\">\n\t\t\t\t\t\t<div class=\"desc\"></div>\n\t\t\t\t\t</div>\n\t\t\t\t\t<pre class=\"code\">\n\t\t\t\t\t</pre>\n\t\t\t\t</section>\n\t\t\t\t<section data-line=\"2\" >\n\t\t\t\t\t<div class=\"docs\">\n\t\t\t\t\t\t<div class=\"desc\">\n\t\t\t\t\t\t\t<p>Base collection.</p>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t\t<pre class=\"code\">\n\t\t\t\t\t</pre>\n\t\t\t\t</section>\n\t\t\t</article>\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\t<article>\n\t\t\t\t<section class=\"head\">\n\t\t\t\t\t<div class=\"docs\">\n\t\t\t\t\t\t<h1><p>Model</p></h1>\n\t\t\t\t\t</div>\n\t\t\t\t\t<pre class=\"code\"></pre>\n\t\t\t\t</section>\n\t\t\t\t<section data-line=\"0\" class=\"intro\" >\n\t\t\t\t\t<div class=\"docs\">\n\t\t\t\t\t\t<div class=\"desc\"></div>\n\t\t\t\t\t</div>\n\t\t\t\t\t<pre class=\"code\">\n\t\t\t\t\t</pre>\n\t\t\t\t</section>\n\t\t\t\t<section data-line=\"2\" >\n\t\t\t\t\t<div class=\"docs\">\n\t\t\t\t\t\t<div class=\"desc\">\n\t\t\t\t\t\t\t<p>Base model.</p>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t\t<pre class=\"code\">\n\t\t\t\t\t</pre>\n\t\t\t\t</section>\n\t\t\t</article>\n\t\t\tbreak;\n\t}\n}\n\n"
						}
					]
				}
			],
			"type": "text/edbml"
		},
		"packages/test/src/gui/edbml/guid-recycle.edbml": {
			"title": "guid-recycle",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "export default function(scenario) {\n\tswitch(scenario) {\n\t\tcase 0:\n\t\t\t<ul>\n\t\t\t\t<li><div guid=\"A\"></div></li>\n\t\t\t\t<li><div guid=\"B\"></div></li>\n\t\t\t\t<li><div guid=\"C\"></div></li>\n\t\t\t\t<li><div guid=\"D\"></div></li>\n\t\t\t\t<li><div guid=\"E\"></div></li>\n\t\t\t\t<li><div guid=\"F\"></div></li>\n\t\t\t\t<li><div guid=\"G\"></div></li>\n\t\t\t</ul>\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t<menu>\n\t\t\t\t<div guid=\"A\"></div>\n\t\t\t\t<div guid=\"B\"></div>\n\t\t\t\t<div guid=\"C\"></div>\n\t\t\t</menu>\n\t\t\t<article>\n\t\t\t\t<div guid=\"D\"></div>\n\t\t\t\t<div guid=\"E\"></div>\n\t\t\t\t<section>\n\t\t\t\t\t<div guid=\"F\"></div>\n\t\t\t\t</section>\n\t\t\t</article>\n\t\t\t<div guid=\"G\"></div>\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t<article>\n\t\t\t\t<section>\n\t\t\t\t\t<div guid=\"G\"></div>\n\t\t\t\t</section>\n\t\t\t\t<menu>\n\t\t\t\t\t<div guid=\"C\"></div>\n\t\t\t\t\t<div guid=\"D\">\n\t\t\t\t\t\t<nav>\n\t\t\t\t\t\t\t<div guid=\"B\"></div>\n\t\t\t\t\t\t\t<div guid=\"E\">\n\t\t\t\t\t\t\t\t<div guid=\"F\"></div>\n\t\t\t\t\t\t\t\t<div guid=\"A\"></div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</nav>\n\t\t\t\t\t</div>\n\t\t\t\t</menu>\n\t\t\t</article>\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\t<div guid=\"D\">\n\t\t\t\t<div guid=\"G\">\n\t\t\t\t\t<table>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td><div guid=\"C\"></div></td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t</table>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div guid=\"B\"></div>\n\t\t\t<div guid=\"E\"></div>\n\t\t\t<div guid=\"A\">\n\t\t\t\t<div guid=\"F\"></div>\n\t\t\t</div>\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\t<div guid=\"A\">\n\t\t\t\t<div guid=\"B\">\n\t\t\t\t\t<div guid=\"C\">\n\t\t\t\t\t\t<div guid=\"D\">\n\t\t\t\t\t\t\t<div guid=\"E\">\n\t\t\t\t\t\t\t\t<div guid=\"F\">\n\t\t\t\t\t\t\t\t\t<div guid=\"G\"></div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\tbreak;\n\t}\n}\n\n"
						}
					]
				}
			],
			"type": "text/edbml"
		},
		"packages/test/src/gui/edbml/hello-world.edbml": {
			"title": "hello-world",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "The most basic test we can imagine. ",
							"code": "export default function(message) {\n\t<blockquote>${message}</blockquote>\n\tconfirmMultiline();\n}\n\n"
						},
						{
							"line": 8,
							"tags": [],
							"tabs": "",
							"desc": "Just testing that the EDBML compiler supports `+` both first and last. ",
							"code": "function confirmMultiline() {\n\t<ul>\t\t\n\t\t<li>The compiler supports ending plus +\n\t\t\tto continue HTML on the next line</li>\n\t\t<li>The compiler also supports leading plus\n\t\t\t+ to continue HTML on the next line</li>\n\t</ul>\n}\n\n"
						}
					]
				}
			],
			"type": "text/edbml"
		},
		"packages/test/src/gui/edbml/inline-callbacks.edbml": {
			"title": "inline-callbacks",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [
								{
									"name": "@param",
									"type": "{number}",
									"desc": "scenario",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{number}",
									"desc": "[value]",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export default function(scenario, value) {\n\tconst spirit = this;\n\tswitch(scenario) {\n\t\tcase 0:\n\t\t\t<button guid=\"button\" on:click=\"${spirit.check = value || 'OK'}\">Button</button>\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t<button guid=\"button\">Button</button>\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t<p>Gone!</p>\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\texternalized(scenario, spirit);\n\t\t\tbreak;\n\t}\n}\n\n"
						},
						{
							"line": 22,
							"tags": [
								{
									"name": "@param",
									"type": "{number}",
									"desc": "scenario",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Spirit}",
									"desc": "spirit",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Just to confirm that callbacks can be resolved outside the `export` function. ",
							"code": "function externalized(scenario, spirit) {\n\t<button guid=\"button\" +\n\t\ton:click=\"${spirit.check = 'still OK'}\" +\n\t\ton:focus=\"${spirit.check = 'okeydokey'}\">\n\t\t\t<span>Button</span>\n\t</button>\n}\n\n"
						}
					]
				}
			],
			"type": "text/edbml"
		},
		"packages/test/src/gui/edbml/io-flemming.edbml": {
			"title": "io-flemming",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [
								{
									"name": "@param",
									"type": "{NumberCollection}",
									"desc": "numbers",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export default function(numbers) {\n\tif (numbers[3] === Math.PI) {\n\t\t<h1>OK</h1>\n\t}\n}\n\n"
						}
					]
				}
			],
			"type": "text/edbml"
		},
		"packages/test/src/gui/edbml/io-johnson.edbml": {
			"title": "io-johnson",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [
								{
									"name": "@param",
									"type": "{PersonCollection}",
									"desc": "persons",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export default function(persons) {\n\t<ul>\n\t\tpersons.forEach(person => {\n\t\t\t<li>${person.name}</li>\n\t\t});\n\t</ul>\n}\n\n"
						}
					]
				}
			],
			"type": "text/edbml"
		},
		"packages/test/src/gui/edbml/io-simple.edbml": {
			"title": "io-simple",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [
								{
									"name": "@param",
									"type": "{PersonModel}",
									"desc": "person",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{DonkeyModel}",
									"desc": "donkey",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export default function(person, donkey) {\n\tconst relationship = person.pet === donkey ? 'colleagues' : 'friends';\n\t<h1>The adventures of ${person.name}</h1>\n\t<p>There once was a man called ${person.name}. He met a donkey +\n\tcalled ${donkey.name} and they soon became ${relationship}.</p>\n}\n\n"
						}
					]
				}
			],
			"type": "text/edbml"
		},
		"packages/test/src/gui/edbml/level1.edbml": {
			"title": "level1",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import level2 from './level2.edbml.js';\n\n"
						},
						{
							"line": 2,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "string",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Delegate to level two. ",
							"code": "export default function(string) {\n\tlevel2(string);\n}\n\n"
						}
					]
				}
			],
			"type": "text/edbml"
		},
		"packages/test/src/gui/edbml/level2.edbml": {
			"title": "level2",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import level3 from './level3.edbml.js';\n\n"
						},
						{
							"line": 2,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "string",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Delegate to level three. ",
							"code": "export default function(string) {\n\tlevel3(string);\n}\n\n"
						}
					]
				}
			],
			"type": "text/edbml"
		},
		"packages/test/src/gui/edbml/level3.edbml": {
			"title": "level3",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "string",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Finally output the string. ",
							"code": "export default function(string) {\n\t<h1>${string}</h1>\n}\n\n"
						}
					]
				}
			],
			"type": "text/edbml"
		},
		"packages/test/src/gui/edbml/nodes-and-spirits.edbml": {
			"title": "nodes-and-spirits",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [
								{
									"name": "@param",
									"type": "{Spirit}",
									"desc": "spi",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{DocumentFragment}",
									"desc": "frag",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: NodeList ",
							"code": "export default function(element, fragment) {\n\tconst simple = ['a', 'b', 'c'];\n\t<ul>\n\t\t<li>Simple ${simple[0]}</li>\n\t\t<li class=\"element\">Before ${element} after</li>\n\t\t<li>Simple ${simple[1]}</li>\n\t\t<li class=\"fragment\">Before ${fragment} after</li>\n\t\t<li>Simple ${simple[2]}</li>\n\t</ul>\n}\n\n"
						}
					]
				}
			],
			"type": "text/edbml"
		},
		"packages/test/src/gui/edbml/not_wellformed.edbml": {
			"title": "not_wellformed",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "export default function() {\n\t<p>Well-formed</p>\n\t<p>Well-formed</p>\n\t<p>Well-formed</p>\n\t<p>Well-formed</p>\n\t<p>Well-formed</p>\n\t<p>Well-formed</p>\n\t<p>Well-formed</p>\n\t<footer>Not well-formed :(</header>\n}\n\n"
						}
					]
				}
			],
			"type": "text/edbml"
		},
		"packages/test/src/gui/edbml/pass-props.edbml": {
			"title": "pass-props",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "const fullname = model => `${model.firstname} ${model.lastname}`;\n\nexport default function pass(model) {\n\telmprops(model);\n\telmcalls(model);\n\tspiprops(model); // TODO: support\n\tspicalls(model); // TODO: support\n}\n\nfunction elmprops(model) {\n\t<div guid=\"elm-props\" do:elm=\"${elm.title = fullname(model)}\"></div>\n}\n\nfunction elmcalls(model) {\n\t<div guid=\"elm-calls\" do:elm=\"${elm.setAttribute('title', fullname(model))}\"></div>\n}\n\nfunction spiprops(model) {\n\t<my-configurable-spirit guid=\"spi-props\" do:gui=\"${gui.usermodel = model}\">\t\n\t</my-configurable-spirit>\n}\n\nfunction spicalls(model) {\n\tconst update = gui => gui.username(model.firstname, model.lastname);\n\t<my-configurable-spirit guid=\"spi-calls\" do:gui=\"${update(gui)}\">\n\t</my-configurable-spirit>\n}\n\n"
						}
					]
				}
			],
			"type": "text/edbml"
		},
		"packages/test/src/gui/edbml/problem.edbml": {
			"title": "problem",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [
								{
									"name": "@param",
									"type": "{number}",
									"desc": "scenario",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<string>}",
									"desc": "list",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export default function(list, list2) {\n\tconst last = list.length - 1;\n\t<ul guid=\"list\">\n\t\tlist.forEach((id, i) => {\n\t\t\t<li guid=\"${id}\">\n\t\t\t\t<span>OUTER-${id}</span>\n\t\t\t\tif (list2 && i === last) {\n\t\t\t\t\t<ul guid=\"sublist\">\n\t\t\t\t\t\tlist2.forEach(id => {\n\t\t\t\t\t\t\t<li guid=\"${id}\">\n\t\t\t\t\t\t\t\t<span>INNER-${id}</span>\n\t\t\t\t\t\t\t</li>\n\t\t\t\t\t\t});\n\t\t\t\t\t</ul>\n\t\t\t\t}\n\t\t\t</li>\n\t\t});\n\t</ul>\n}\n\n"
						}
					]
				}
			],
			"type": "text/edbml"
		},
		"packages/test/src/gui/edbml/root-updates.edbml": {
			"title": "root-updates",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [
								{
									"name": "@param",
									"type": "{number}",
									"desc": "scenario",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "classname",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "tooltip",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "action",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "The `&lt;this&gt;` tag is be used to assign attributes and callbacks  to the spirts own (root) element from within the EDBML script. ",
							"code": "export default function(scenario, classname, tooltip, action) {\n\tswitch(scenario) {\n\t\tcase 0:\n\t\t\t<p>No root element!</p>\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t@class = classname || null;\n\t\t\t@title = tooltip || null;\n\t\t\t<this @class @title></this>\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t<this guid=\"hansen\" on:click=\"${action()}\"></this>\n\t\t\tbreak;\n\t}\n}\n\n"
						}
					]
				}
			],
			"type": "text/edbml"
		},
		"packages/test/src/gui/edbml/xxsfilters.edbml": {
			"title": "xxsfilters",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "text",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "attr",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "href",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "src",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export default function(text, attr, href, src) {\n\t<a href=\"${href}\" title=\"${attr}\">\n\t\t<img src=\"${src}\"/>\n\t\t<span>Hello ${text} and hello again ${text} so there.</span>\n\t</a>\n}\n\n"
						}
					]
				}
			],
			"type": "text/edbml"
		},
		"packages/test/src/gui/models/DonkeyModel.js": {
			"title": "DonkeyModel",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { Model } from 'dataplastique';\n"
						},
						{
							"line": 1,
							"tags": [],
							"tabs": "",
							"desc": "Donkey model. ",
							"code": "export default class DonkeyModel extends Model {\n\tstatic model() {\n\t\treturn {\n\t\t\tname: String\n\t\t};\n\t}\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/test/src/gui/models/NumberCollection.js": {
			"title": "NumberCollection",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { Collection } from 'dataplastique';\n"
						},
						{
							"line": 1,
							"tags": [],
							"tabs": "",
							"desc": "Number collection. ",
							"code": "export default class NumberCollection extends Collection {\n\tstatic collection() {\n\t\treturn Number;\n\t}\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/test/src/gui/models/PersonCollection.js": {
			"title": "PersonCollection",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { Collection } from 'dataplastique';\nimport PersonModel from './DonkeyModel';\n"
						},
						{
							"line": 2,
							"tags": [],
							"tabs": "",
							"desc": "Person collection. ",
							"code": "export default class PersonCollection extends Collection {\n\tstatic collection() {\n\t\treturn PersonModel;\n\t}\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/test/src/gui/models/PersonModel.js": {
			"title": "PersonModel",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { Model } from 'dataplastique';\nimport DonkeyModel from './DonkeyModel';\n"
						},
						{
							"line": 2,
							"tags": [],
							"tabs": "",
							"desc": "Person model. ",
							"code": "export default class PersonModel extends Model {\n\tstatic model(map) {\n\t\treturn {\n\t\t\tname: String,\n\t\t\tage: Number,\n\t\t\tmarried: Boolean,\n\t\t\tpet: DonkeyModel\n\t\t};\n\t}\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/test/src/iso.js": {
			"title": "iso",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import key from './util/Key.iso.spec';\nimport mapping from './util/Mapping.iso.spec';\nimport imapping from './util/IMapping.iso.spec';\nimport tick from './util/Tick.iso.spec';\nimport type from './util/Type.iso.spec';\nimport model from './edb/Model.iso.spec';\nimport model_proxy from './edb/Model.proxy.iso.spec';\nimport model_pipes from './edb/Model.pipes.iso.spec';\nimport model_output from './edb/Model.output.iso.spec';\nimport model_observers from './edb/Model.observers.iso.spec';\nimport collection from './edb/Collection.iso.spec';\nimport plugin from './edb/Plugin.iso.spec';\nimport tree from './edb/Tree.iso.spec';\n[\n\tkey,\n\tmapping,\n\timapping,\n\ttick,\n\ttype,\n\tmodel,\n\tmodel_proxy,\n\tmodel_pipes,\n\tmodel_output,\n\tmodel_observers,\n\tcollection,\n\tplugin,\n\ttree\n].forEach(test => test());\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/test/src/util/IMapping.iso.spec.js": {
			"title": "IMapping.iso.spec",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { IMapping } from '@dataplastique/util';\nexport default function() {\n\tdescribe('util.IMapping', function likethis() {\n\t\tconst fun1 = () => {};\n\t\tconst fun2 = () => {};\n\t\tconst fun3 = () => {};\n\t\tfunction add(map, key, ...handlers) {\n\t\t\thandlers.forEach(handler => map.add(key, handler));\n\t\t}\n\t\tfunction del(map, key, ...handlers) {\n\t\t\thandlers.forEach(handler => map.del(key, handler));\n\t\t}\n\t\tit('can add handlers for pattern', () => {\n\t\t\tconst map = new IMapping();\n\t\t\tconst key = Symbol('key');\n\t\t\tadd(map, key, fun1, fun2, fun3);\n\t\t\t[fun1, fun2, fun3].forEach(n => {\n\t\t\t\texpect(map.get(key).has(n)).toBe(true);\n\t\t\t});\n\t\t\tdel(map, key, fun3);\n\t\t\texpect(map.get(key).size).toBe(2);\n\t\t});\n\t\tit('can remove handlers for pattern', () => {\n\t\t\tconst map = new IMapping();\n\t\t\tconst key = Symbol('key');\n\t\t\tadd(map, key, fun1, fun2, fun3);\n\t\t\tdel(map, key, fun3);\n\t\t\texpect(map.get(key).size).toBe(2);\n\t\t});\n\t\tit('should never add the \"same\" pattern twice', () => {\n\t\t\tconst map = new IMapping();\n\t\t\tconst key = ['a', 'b', { nested: 'c' }, ['array']];\n\t\t\tadd(map, key, fun1, fun2, fun3);\n\t\t\texpect(map.toMap().size).toBe(1);\n\t\t});\n\t\tit('should dispose the set when empty', () => {\n\t\t\tconst map = new IMapping();\n\t\t\tconst key = Symbol('key');\n\t\t\tadd(map, key, fun1, fun2, fun3);\n\t\t\texpect(map.get(key).size).toBe(3);\n\t\t\tdel(map, key, fun1, fun2, fun3);\n\t\t\texpect(map.has(key)).toBe(false);\n\t\t});\n\t});\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/test/src/util/Key.iso.spec.js": {
			"title": "Key.iso.spec",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { Key } from '@dataplastique/util';\nexport default function() {\n\tdescribe('util.Key', function likethis() {\n\t\tit('should generate a default key', () => {\n\t\t\tlet key = Key.generate();\n\t\t\texpect(key.indexOf('key')).toBe(0);\n\t\t});\n\t\tit('should generate a named key', () => {\n\t\t\tlet key = Key.generate('name');\n\t\t\texpect(key.indexOf('name')).toBe(0);\n\t\t});\n\t\tit('should identify a default key', () => {\n\t\t\tlet key = Key.generate();\n\t\t\texpect(Key.isKey(key)).toBe(true);\n\t\t});\n\t\tit('should identify a named key', () => {\n\t\t\tlet key = Key.generate('name');\n\t\t\texpect(Key.isKey(key, 'name')).toBe(true);\n\t\t});\n\t\tit('should identify a bogus key', () => {\n\t\t\texpect(Key.isKey('Quick brown fox')).toBe(false);\n\t\t});\n\t\tit('should extract multiple keys', () => {\n\t\t\tlet keys = new Array(23 + 1).join(Key.generate());\n\t\t\texpect(Key.extractKeys(keys).length).toBe(23);\n\t\t});\n\t});\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/test/src/util/Mapping.iso.spec.js": {
			"title": "Mapping.iso.spec",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { Mapping } from '@dataplastique/util';\nexport default function() {\n\tdescribe('util.Mapping', function likethis() {\n\t\tconst KEY1 = 'key1';\n\t\tconst KEY2 = 'key2';\n\t\tit('should push values to a set indexed by key', () => {\n\t\t\tlet mapset = new Mapping()\n\t\t\t\t.add(KEY1, 1)\n\t\t\t\t.add(KEY1, 2)\n\t\t\t\t.add(KEY2, 3);\n\t\t\tlet set1 = mapset.get(KEY1);\n\t\t\tlet set2 = mapset.get(KEY2);\n\t\t\texpect(set1).toEqual(jasmine.any(Set));\n\t\t\texpect(Array.from(set1)).toEqual([1, 2]);\n\t\t\texpect(Array.from(set2)).toEqual([3]);\n\t\t});\n\t\tit('should know when a set contains the given key', () => {\n\t\t\tlet mapset = new Mapping().add(KEY1, 1).add(KEY1, 2);\n\t\t\texpect(mapset.has(KEY1, 2)).toBe(true);\n\t\t});\n\t\tit('should completely remove the set when empty', () => {\n\t\t\tlet mapset = new Mapping().add(KEY1, 1).del(KEY1, 1);\n\t\t\texpect(mapset.get(KEY1)).toBe(undefined);\n\t\t});\n\t});\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/test/src/util/Tick.iso.spec.js": {
			"title": "Tick.iso.spec",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { Tick } from '@dataplastique/util';\nexport default function() {\n\tdescribe('util.Tick', function likethis() {\n\t\tlet TYPE = 'tick-tock';\n\t\tit('should trigger on tick', done => {\n\t\t\tTick.add(TYPE, {\n\t\t\t\tontick: tick => {\n\t\t\t\t\texpect(tick.type).toBe(TYPE);\n\t\t\t\t\tTick.remove(TYPE, this);\n\t\t\t\t\tdone();\n\t\t\t\t}\n\t\t\t}).dispatch(TYPE);\n\t\t});\n\t\tit('should trigger on time', done => {\n\t\t\tTick.add(TYPE, {\n\t\t\t\tontick: tick => {\n\t\t\t\t\texpect(tick.type).toBe(TYPE);\n\t\t\t\t\tTick.remove(TYPE, this);\n\t\t\t\t\tdone();\n\t\t\t\t}\n\t\t\t}).dispatch(TYPE, 100);\n\t\t});\n\t\tit('should trigger once', done => {\n\t\t\tlet counter = 0;\n\t\t\tTick.one(TYPE, {\n\t\t\t\tontick: tick => {\n\t\t\t\t\tif (++counter < 3) {\n\t\t\t\t\t\tTick.dispatch(TYPE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}).dispatch(TYPE);\n\t\t\tsetTimeout(() => {\n\t\t\t\texpect(counter).toBe(1);\n\t\t\t\tdone();\n\t\t\t}, 200);\n\t\t});\n\t\tit('should also remove', done => {\n\t\t\tlet success = true,\n\t\t\t\thandler = {\n\t\t\t\t\tontick: () => {\n\t\t\t\t\t\tsuccess = false;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\tTick.add(TYPE, handler)\n\t\t\t\t.remove(TYPE, handler)\n\t\t\t\t.dispatch(TYPE);\n\t\t\tsetTimeout(() => {\n\t\t\t\texpect(success).toBe(true);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t\tit('should invoke on timeout', done => {\n\t\t\tTick.time(function() {\n\t\t\t\texpect(true).toBe(true);\n\t\t\t\tdone();\n\t\t\t}, 5);\n\t\t});\n\t\tit('should start and stop', done => {\n\t\t\tlet counter = 0;\n\t\t\tTick.add(TYPE, {\n\t\t\t\tontick: tick => {\n\t\t\t\t\tif (++counter === 3) {\n\t\t\t\t\t\tTick.stop(TYPE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}).start(TYPE, 5);\n\t\t\tsetTimeout(() => {\n\t\t\t\texpect(counter).toBe(3);\n\t\t\t\tdone();\n\t\t\t}, 200);\n\t\t});\n\t});\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/test/src/util/Tick.web.spec.js": {
			"title": "Tick.web.spec",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { Tick } from '@dataplastique/util';\nexport default function() {\n\tdescribe('util.Tick', function likethis() {\n\t\tit('should trigger on frame', done => {\n\t\t\tTick.nextFrame(timestamp => {\n\t\t\t\texpect(timestamp).toEqual(jasmine.any(Number));\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/test/src/util/Type.iso.spec.js": {
			"title": "Type.iso.spec",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "\t\t\t",
							"desc": "",
							"code": "import { isFunction, isClass } from '@dataplastique/util';\nexport default function() {\n\tdescribe('util.Type', function likethis() {\n\t\tdescribe('Discern between function types', () => {\n"
						}
					]
				},
				{
					"title": "Preparation ",
					"tabs": "\t\t\t",
					"sections": [
						{
							"line": 4,
							"tags": [],
							"tabs": "\t\t\t",
							"desc": "",
							"code": "\t\t\t\t\t\tfunction func() {}\n\t\t\tfunction Cons() {}\n\t\t\tCons.prototype = {\n\t\t\t\tmethod() {}\n\t\t\t};\n\t\t\tclass Con1 {}\n\t\t\tclass Con2 {\n\t\t\t\tmethod() {}\n\t\t\t}\n\t\t\tlet object = {\n\t\t\t\tmethod() {}\n\t\t\t};\n\t\t\tclass Cla1 {\n\t\t\t\tmethod() {}\n\t\t\t}\n\t\t\tclass Cla2 extends Cla1 {}\n\t\t\tlet cla3 = class {};\n"
						}
					]
				},
				{
					"title": "Expectations ",
					"tabs": "\t\t\t",
					"sections": [
						{
							"line": 22,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "\t\t\t\t\t\tit('should be a function', () => {\n\t\t\t\texpect(isFunction(func)).toBe(true);\n\t\t\t\texpect(isFunction(Cons)).toBe(true);\n\t\t\t\texpect(isFunction(Con2)).toBe(true);\n\t\t\t\texpect(isFunction(new Cons().method)).toBe(true);\n\t\t\t\texpect(isFunction(new Con2().method)).toBe(true);\n\t\t\t});\n\t\t\t\n\t\t\t\n\t\t\tit('should be a class (constructor)', () => {\n\t\t\t\texpect(isClass(Cla1)).toBe(true);\n\t\t\t\texpect(isClass(Cla2)).toBe(true);\n\t\t\t\texpect(isClass(cla3)).toBe(true);\n\t\t\t});\n\t\t});\n\t});\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/test/src/util/arrayutils.iso.spec.js": {
			"title": "arrayutils.iso.spec",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "\t",
							"desc": "",
							"code": "export default function() {\n"
						},
						{
							"line": 1,
							"tags": [],
							"tabs": "",
							"desc": "TODO: Bring these functions back! ",
							"code": "\tdescribe('util.arrayutils', function likethis() {\n\t});\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/test/src/web.js": {
			"title": "web",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import spirit from './gui/Spirit.web.spec';\nimport tick from './util/Tick.web.spec';\nimport att from './gui/AttPlugin.web.spec';\nimport css from './gui/CSSPlugin.web.spec';\nimport io from './gui/IOPlugin.web.spec';\nimport script0 from './gui/ScriptPlugin-0.web.spec';\nimport script1 from './gui/ScriptPlugin-1.web.spec';\nimport script2 from './gui/ScriptPlugin-2.web.spec';\nimport script3 from './gui/ScriptPlugin-3.web.spec';\nimport devtools from './edb/DevTools.web.spec.js';\n[\n\tspirit,\n\ttick,\n\tatt,\n\tcss,\n\tio,\n\tscript0,\n\tscript1,\n\tscript2,\n\tscript3,\n\tdevtools\n].forEach(test => test());\n\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/util/src/Class.js": {
			"title": "Class",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "\t",
							"desc": "Working with classes. ",
							"code": "export default class Class {\n"
						},
						{
							"line": 4,
							"tags": [
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "Child",
									"text": "(constructor)"
								},
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "Parent",
									"text": "(constructor)"
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Child class inherits from (or is equal to) Parent class? ",
							"code": "\tstatic inherits(Child, Parent) {\n\t\tlet does = false;\n\t\twhile (Child && Child.name !== 'Empty' && !does) {\n\t\t\tif (Child === Parent) {\n\t\t\t\tdoes = true;\n\t\t\t} else {\n\t\t\t\tChild = Object.getPrototypeOf(Child);\n\t\t\t}\n\t\t}\n\t\treturn does;\n\t}\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/util/src/Environment.js": {
			"title": "Environment",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "const global = typeof self !== 'undefined' ? self : Function('return this')();\nconst isprocess = !!global.process;\nconst isbrowser = !!global.document;\n"
						},
						{
							"line": 3,
							"tags": [],
							"tabs": "\t",
							"desc": "Awkward `window is not defined` workaround for Node process. TODO: WebWorkerGlobalScope ",
							"code": "export default class Environment {\n"
						},
						{
							"line": 8,
							"tags": [
								{
									"name": "@type",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Appears to be a node script? ",
							"code": "\tstatic get node() {\n\t\treturn isprocess;\n\t}\n"
						},
						{
							"line": 15,
							"tags": [
								{
									"name": "@type",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Appears to run in a browser? ",
							"code": "\tstatic get browser() {\n\t\treturn isbrowser;\n\t}\n"
						},
						{
							"line": 22,
							"tags": [
								{
									"name": "@type",
									"type": "{Window}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Get the window. ",
							"code": "\tstatic get window() {\n\t\treturn isbrowser ? global : null;\n\t}\n"
						},
						{
							"line": 29,
							"tags": [
								{
									"name": "@type",
									"type": "{Document}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get the document. ",
							"code": "\tstatic get document() {\n\t\treturn isbrowser ? global.document : null;\n\t}\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/util/src/Immutable.js": {
			"title": "Immutable",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "export {\n\tfromJS as immutable,\n\tisImmutable,\n\tMap as IMap,\n\tList as IList,\n\tSet as ISet,\n\tSeq as ISeq\n} from './deps/immutable/immutable.es.js';\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/util/src/Key.js": {
			"title": "Key",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { isString } from './Type';\n"
						},
						{
							"line": 1,
							"tags": [
								{
									"name": "@type",
									"type": "{Set<string>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Seriously tracking keys to avoid duplicates. ",
							"code": "const keys = new Set();\n"
						},
						{
							"line": 6,
							"tags": [],
							"tabs": "\t",
							"desc": "Generating keys for unique key purposes. ",
							"code": "export default class Key {\n"
						},
						{
							"line": 10,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "[fix]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Generate random key. ",
							"code": "\tstatic generate(fix = 'key') {\n\t\tconst ran = String(Math.random());\n\t\tconst key = fix + ran.slice(2, 11);\n\t\treturn keys.has(key)\n\t\t\t? this.generate()\n\t\t\t: do {\n\t\t\t\t\tkeys.add(key);\n\t\t\t\t\tkey;\n\t\t\t  };\n\t}\n"
						},
						{
							"line": 25,
							"tags": [
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Generate some unified resource name with random identifier. Takes an array for strings (for domain and type and so on). ",
							"code": "\tstatic generateURN(...args) {\n\t\treturn `urn:${args.join(':')}:${this.generate('')}`;\n\t}\n"
						},
						{
							"line": 33,
							"tags": [
								{
									"name": "@see",
									"type": "http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript",
									"desc": "",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Generate GUID. TODO: Verify integrity of this by mounting result in Java or something. ",
							"code": "\tstatic generateGUID() {\n\t\treturn 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'\n\t\t\t.replace(/[xy]/g, function(c) {\n\t\t\t\tlet r = (Math.random() * 16) | 0;\n\t\t\t\tlet v = c === 'x' ? r : (r & 0x3) | 0x8;\n\t\t\t\treturn v.toString(16);\n\t\t\t})\n\t\t\t.toLowerCase();\n\t}\n"
						},
						{
							"line": 48,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "string",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "[fix]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "String appears to be a generated key? We don't look it up in the key cache, so this method can be used to check a key that was generated in old session. ",
							"code": "\tstatic isKey(string, fix = 'key') {\n\t\tlet hit = null;\n\t\tlet looks = false;\n\t\tif (isString(string)) {\n\t\t\thit = this.extractKeys(string, fix);\n\t\t\tlooks = hit.length === 1 && hit[0].length === string.length;\n\t\t}\n\t\treturn looks;\n\t}\n"
						},
						{
							"line": 64,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "string",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "[fix]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<string>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Extract keys from string. This always returns a (potentially empty) array. TODO: Rename (since it doesn't remove)! ",
							"code": "\tstatic extractKeys(string, fix = 'key') {\n\t\tlet next;\n\t\tlet keys = [];\n\t\tlet regex = getfix(fix);\n\t\twhile ((next = regex.exec(string))) {\n\t\t\tkeys.push(next[0]);\n\t\t}\n\t\treturn keys;\n\t}\n"
						},
						{
							"line": 81,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "string",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "[fix]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Remove keys from string to compare non-keyed content. TODO: TEST THIS! ",
							"code": "\tstatic removeKeys(string, fix = 'key') {\n\t\treturn string.replace(fixs.get(fix), '');\n\t}\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 93,
							"tags": [
								{
									"name": "@type",
									"type": "{Map<string,RegExp>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Collecting regular expressions. ",
							"code": "const fixs = new Map();\n"
						},
						{
							"line": 98,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "fix",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{RegExp}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get regexp for fix. ",
							"code": "function getfix(fix = 'key') {\n\treturn fixs.has(fix)\n\t\t? fixs.get(fix)\n\t\t: do {\n\t\t\t\tconst exp = new RegExp(fix + '\\\\d{9}', 'g');\n\t\t\t\tfixs.set(fix, exp);\n\t\t\t\texp;\n\t\t  };\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/util/src/Tick.js": {
			"title": "Tick",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import Mapping from './data/Mapping';\nimport Environment from './Environment';\nimport { isString } from './Type';\nimport { chained } from './decorators';\nimport { asarray } from './func/arrayutils';\n"
						},
						{
							"line": 5,
							"tags": [
								{
									"name": "@typedef",
									"type": "{Object}",
									"desc": "",
									"text": ""
								},
								{
									"name": "@property",
									"type": "{Function}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Handler implements `onclick`. ",
							"code": ""
						},
						{
							"line": 10,
							"tags": [
								{
									"name": "@type",
									"type": "{Map<string,Tick>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Create each type only once. ",
							"code": "const pool = new Map();\n"
						},
						{
							"line": 15,
							"tags": [
								{
									"name": "@type",
									"type": "{Map<string,number>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Mapping `setInterval` coroutines. ",
							"code": "const intervals = new Map();\n"
						},
						{
							"line": 20,
							"tags": [
								{
									"name": "@type",
									"type": "{Set<string>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Tracking ticks types ready to fire. ",
							"code": "const scheduled = new Set();\n"
						},
						{
							"line": 25,
							"tags": [
								{
									"name": "@type",
									"type": "{Mapping}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Mapping tick types to handlers for tick. ",
							"code": "const allhandlers = new Mapping();\n"
						},
						{
							"line": 30,
							"tags": [
								{
									"name": "@type",
									"type": "{Mapping}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Mapping handlers that should auto-unregister upon tick. ",
							"code": "const onehandlers = new Mapping();\n"
						},
						{
							"line": 35,
							"tags": [
								{
									"name": "@type",
									"type": "{Function}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Create function to execute something async with low latency (in browsers). TODO: Make this cancellable! ",
							"code": "const fixImmediate = (() => {\n\tlet index = -1;\n\tif (Environment.browser) {\n\t\tlet runs = false;\n\t\tconst list = [];\n\t\tconst node = document.createElement('div');\n\t\tnew MutationObserver(() => {\n\t\t\truns = false;\n\t\t\twhile (list.length) {\n\t\t\t\tlist.shift()();\n\t\t\t}\n\t\t}).observe(node, {\n\t\t\tattributes: true\n\t\t});\n\t\treturn action => {\n\t\t\tconst id = ++index;\n\t\t\tlist.push(action);\n\t\t\tif (!runs) {\n\t\t\t\tnode.classList.toggle('trigger');\n\t\t\t}\n\t\t\treturn id;\n\t\t};\n\t}\n})();\n"
						},
						{
							"line": 65,
							"tags": [],
							"tabs": "\t",
							"desc": "Scheduling and timing of things. ",
							"code": "export default class Tick {\n"
						},
						{
							"line": 69,
							"tags": [
								{
									"name": "@type",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Tick identifier. ",
							"code": "\ttype;\n"
						},
						{
							"line": 74,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "type",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\tconstructor(type) {\n\t\tif (isString(type)) {\n\t\t\tthis.type = type;\n\t\t\tObject.seal(this);\n\t\t} else {\n\t\t\tthrow new TypeError('Tick needs a type');\n\t\t}\n\t}\n"
						}
					]
				},
				{
					"title": "Static ",
					"tabs": "\t",
					"sections": [
						{
							"line": 86,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Array<string>}",
									"desc": "type",
									"text": "- String or array of strings"
								},
								{
									"name": "@param",
									"type": "{TickHandler}",
									"desc": "handler",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{this}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Add handler for tick. ",
							"code": "\t@chained\n\tstatic add(type, handler) {\n\t\taddhandler(type, handler);\n\t}\n"
						},
						{
							"line": 96,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Array<string>}",
									"desc": "type",
									"text": "- String or array of strings"
								},
								{
									"name": "@param",
									"type": "{TickHandler}",
									"desc": "handler",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Constructor}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Remove handler for tick. ",
							"code": "\t@chained\n\tstatic remove(type, handler) {\n\t\tdelhandler(type, handler);\n\t}\n"
						},
						{
							"line": 106,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "type",
									"text": "String or array of strings"
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "handler",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Constructor}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Add auto-removing handler for tick. ",
							"code": "\t@chained\n\tstatic one(type, handler) {\n\t\taddhandler(type, handler, true);\n\t}\n"
						},
						{
							"line": 116,
							"tags": [
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "action",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{number}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\t@chained\n\tstatic next(action) {\n\t\treturn nexttick(action);\n\t}\n"
						},
						{
							"line": 124,
							"tags": [
								{
									"name": "@param",
									"type": "{number}",
									"desc": "n",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "TODO! ",
							"code": "\tstatic cancelNext(n) {\n\t\tconsole.error('TODO!');\n\t}\n"
						},
						{
							"line": 131,
							"tags": [
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "action",
									"text": "Called back with a timestamp"
								}
							],
							"tabs": "\t",
							"desc": "Schedule action for next animation frame. returns {number} ",
							"code": "\t@chained\n\tstatic nextFrame(action) {\n\t\treturn requestAnimationFrame(action);\n\t}\n"
						},
						{
							"line": 140,
							"tags": [
								{
									"name": "@param",
									"type": "{number}",
									"desc": "n",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Cancel animation frame by index. ",
							"code": "\t@chained\n\tstatic cancelFrame(n) {\n\t\tcancelAnimationFrame(n);\n\t}\n"
						},
						{
							"line": 148,
							"tags": [
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "action",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{number}",
									"desc": "[time]",
									"text": "Default to something like 4ms"
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "[thisp]",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Set a timeout. returns {number} ",
							"code": "\t@chained\n\tstatic time(action, time) {\n\t\treturn setTimeout(action, time || 0);\n\t}\n"
						},
						{
							"line": 159,
							"tags": [
								{
									"name": "@param",
									"type": "{number}",
									"desc": "n",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Cancel timeout by index. ",
							"code": "\t@chained\n\tstatic cancelTime(n) {\n\t\tclearTimeout(n);\n\t}\n"
						},
						{
							"line": 167,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "type",
									"text": "Tick type"
								},
								{
									"name": "@param",
									"type": "{number}",
									"desc": "time",
									"text": "In milliseconds"
								},
								{
									"name": "@returns",
									"type": "{Function}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Start repeated tick of given type. Once a tick is started, subsequent calls will be ignored. ",
							"code": "\t@chained\n\tstatic start(type, time) {\n\t\tif (!intervals.has(type)) {\n\t\t\tintervals.set(\n\t\t\t\ttype,\n\t\t\t\tsetInterval(() => {\n\t\t\t\t\tdispatch(type);\n\t\t\t\t}, time)\n\t\t\t);\n\t\t}\n\t}\n"
						},
						{
							"line": 185,
							"tags": [
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "cb",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{number}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Schedule callback async via `requestAnimationFrame` \n(in the browser) or via `setTimeout` (in the Node where process.next cannot be cancelled, or can it?) ",
							"code": "\tstatic schedule(cb) {\n\t\treturn Environment.browser ? this.nextFrame(cb) : this.time(cb);\n\t}\n"
						},
						{
							"line": 195,
							"tags": [
								{
									"name": "@param",
									"type": "{number}",
									"desc": "id",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Cancel scheduled callback. ",
							"code": "\t@chained\n\tstatic cancelSchedule(id) {\n\t\tEnvironment.browser ? this.cancelFrame(id) : this.cancelTime(id);\n\t}\n"
						},
						{
							"line": 203,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "type",
									"text": "Tick type"
								},
								{
									"name": "@returns",
									"type": "{Function}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Stop repeated tick of given type. ",
							"code": "\t@chained\n\tstatic stop(type) {\n\t\tif (intervals.has(type)) {\n\t\t\tclearTimeout(intervals.get(type));\n\t\t}\n\t}\n"
						},
						{
							"line": 214,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{number}",
									"desc": "[time]",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Dispatch tick now or in specified time. No return value because `process.nextTick` can't be cancelled anyways. ",
							"code": "\t@chained\n\tstatic dispatch(type, time) {\n\t\tdispatch(type, time);\n\t}\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 226,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Tick}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get tick for type. ",
							"code": "function get(type) {\n\tif (!pool.has(type)) {\n\t\tpool.set(type, new Tick(type));\n\t}\n\treturn pool.get(type);\n}\n"
						},
						{
							"line": 237,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Array<string>}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{TickHandler}",
									"desc": "handler",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{boolean}",
									"desc": "[one]",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function addhandler(type, handler, one) {\n\tasarray(type, t => {\n\t\tallhandlers.add(t, handler);\n\t\tif (one) {\n\t\t\tonehandlers.add(t, handler);\n\t\t}\n\t});\n}\n"
						},
						{
							"line": 250,
							"tags": [
								{
									"name": "@param",
									"type": "{string|Array<string>}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{TickHandler}",
									"desc": "handler",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function delhandler(type, handler) {\n\tasarray(type, t => {\n\t\tallhandlers.del(type, handler);\n\t\tonehandlers.del(type, handler);\n\t});\n}\n"
						},
						{
							"line": 260,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "type",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{number}",
									"desc": "[time]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{number}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Dispatch tick sooner or later. ",
							"code": "function dispatch(type, time) {\n\tconst now = arguments.length === 1;\n\tconst set = scheduled;\n\tif (!set.has(type)) {\n\t\tset.add(type);\n\t\tconst doit = () => {\n\t\t\tset.delete(type);\n\t\t\thandlers(get(type));\n\t\t};\n\t\treturn now ? nexttick(doit) : setTimeout(doit, time);\n\t}\n}\n"
						},
						{
							"line": 278,
							"tags": [
								{
									"name": "@param",
									"type": "{Tick}",
									"desc": "tick",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function handlers(tick) {\n\tconst type = tick.type;\n\tconst all = allhandlers;\n\tconst one = onehandlers;\n\tall\n\t\t.toArray(type)\n\t\t.filter(handler => {\n\t\t\thandler.ontick(tick);\n\t\t\treturn one.has(type, handler);\n\t\t})\n\t\t.forEach(handler => {\n\t\t\tall.del(type, handler);\n\t\t\tone.del(type, handler);\n\t\t});\n}\n"
						},
						{
							"line": 296,
							"tags": [
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "action",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{number}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "function nexttick(action) {\n\treturn Environment.browser\n\t\t? fixImmediate(action)\n\t\t: Environment.node\n\t\t\t? setImmediate(action)\n\t\t\t: todo('WebWorkers unite');\n}\n"
						},
						{
							"line": 307,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "[message]",
									"text": ""
								},
								{
									"name": "@throws",
									"type": "{Error}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "A gentle reminder. ",
							"code": "function todo(message = 'fix') {\n\tthrow new Error('TODO: ' + message);\n}\n"
						},
						{
							"line": 315,
							"tags": [
								{
									"name": "@param",
									"type": "{number}",
									"desc": "n",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO! ",
							"code": "function cancelnex(n) {\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/util/src/Type.js": {
			"title": "Type",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "const TYPE = /\\s([a-zA-Z]+)/; \n"
						},
						{
							"line": 1,
							"tags": [
								{
									"name": "@type",
									"type": "{Function}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Make sure not to use any strange `toString` method. ",
							"code": "const stringify = Object.prototype.toString;\nconst something = any => typeof any === 'object';\n"
						},
						{
							"line": 7,
							"tags": [],
							"tabs": "",
							"desc": "Regexp `class.toString` according to the specification, according to how it transpiles in Babel and according to our own custom syntax that says `[class MyClass]`. ",
							"code": "const [CLASS_SPEC, CLASS_BABEL, CLASS_CUSTOM] = [\n\t/^\\s*class\\s+/, \n\t/_class\\S+/i, \n\t/^\\[class / \n];\n"
						},
						{
							"line": 17,
							"tags": [],
							"tabs": "",
							"desc": "Type checking studio. ",
							"code": ""
						},
						{
							"line": 20,
							"tags": [
								{
									"name": "@see",
									"type": "http://javascriptweblog.wordpress.com/2011/08/08/fixing-the-javascript-typeof-operator",
									"desc": "",
									"text": ""
								},
								{
									"name": "@see",
									"type": "http://stackoverflow.com/questions/332422/how-do-i-get-the-name-of-an-objects-type-in-javascript",
									"desc": "",
									"text": ""
								},
								{
									"name": "@see",
									"type": "http://stackoverflow.com/questions/12018759/how-to-check-the-class-of-an-instance-in-javascript",
									"desc": "",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{*}",
									"desc": "any",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get type of argument. Note that response may differ between user agents. ",
							"code": "export function typeOf(any) {\n\treturn stringify\n\t\t.call(any)\n\t\t.match(TYPE)[1]\n\t\t.toLowerCase();\n}\n"
						},
						{
							"line": 34,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "any",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Is object defined? TODO: unlimited arguments support TODO: See note on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString ",
							"code": "export function isDefined(any) {\n\treturn any !== undefined;\n}\n"
						},
						{
							"line": 44,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "any",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Is complex type? ",
							"code": "export function isComplex(any) {\n\tswitch (any) {\n\t\tcase undefined:\n\t\tcase null:\n\t\tcase true:\n\t\tcase false:\n\t\t\treturn false;\n\t}\n\tswitch (typeof any) {\n\t\tcase 'string':\n\t\tcase 'symbol':\n\t\tcase 'number':\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n"
						},
						{
							"line": 65,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "any",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export function isArray(any) {\n\treturn Array.isArray(any);\n}\n"
						},
						{
							"line": 72,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "any",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Note: This no longer works for classes in Chrome because `of` now returns something like `[object [class MyClass]]`, this could however be just a passing phase, so let's panic later. ",
							"code": "export function isFunction(any) {\n\treturn !!(typeof any === 'function' && any.call && any.apply);\n}\n"
						},
						{
							"line": 82,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "any",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Is object and *not* and array? ",
							"code": "export function isObject(any) {\n\treturn typeof any === 'object' && !Array.isArray(any);\n}\n"
						},
						{
							"line": 90,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "any",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export function isString(any) {\n\treturn typeof any === 'string';\n}\n"
						},
						{
							"line": 97,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "any",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export function isNumber(any) {\n\treturn typeof any === 'number';\n}\n"
						},
						{
							"line": 104,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "any",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export function isBoolean(any) {\n\treturn any === true || any === false;\n}\n"
						},
						{
							"line": 111,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "any",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export function isDate(any) {\n\treturn something(any) && any instanceof Date;\n}\n"
						},
						{
							"line": 118,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "any",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: See note on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString ",
							"code": "export function isNull(any) {\n\treturn any === null;\n}\n"
						},
						{
							"line": 126,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "any",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export function isArguments(any) {\n\treturn typeOf(any) === 'arguments';\n}\n"
						},
						{
							"line": 133,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "any",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export function isSymbol(any) {\n\treturn typeof any === 'symbol';\n}\n"
						},
						{
							"line": 140,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "any",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export function isFile(any) {\n\treturn typeOf(any) === 'file';\n}\n"
						},
						{
							"line": 147,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "any",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Is Window object? ",
							"code": "export function isWindow(any) {\n\treturn !!(\n\t\tany &&\n\t\tany.document &&\n\t\tany.location &&\n\t\tany.alert &&\n\t\tany.setInterval\n\t);\n}\n"
						},
						{
							"line": 161,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "any",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Is Event object? ",
							"code": "export function isEvent(any) {\n\treturn !!(typeOf(any).endsWith('event') && any.type);\n}\n"
						},
						{
							"line": 169,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "any",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Is node? ",
							"code": "export function isNode(any) {\n\treturn !!(\n\t\tany &&\n\t\ttypeof any === 'object' &&\n\t\tany.nodeType &&\n\t\tany.compareDocumentPosition\n\t);\n}\n"
						},
						{
							"line": 182,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "any",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Is DOM element? ",
							"code": "export function isElement(any) {\n\treturn isNode(any) && any.nodeType === Node.ELEMENT_NODE;\n}\n"
						},
						{
							"line": 190,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "any",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Is DocumentFragment? ",
							"code": "export function isDocumentFragment(any) {\n\treturn isNode(any) && any.nodeType === Node.DOCUMENT_FRAGMENT_NODE;\n}\n"
						},
						{
							"line": 198,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "any",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Is Document? ",
							"code": "export function isDocument(any) {\n\treturn isNode(any) && any.nodeType === Node.DOCUMENT_NODE;\n}\n"
						},
						{
							"line": 206,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "any",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: This does not seem performant, can we fix that????? Idea: Scope this method to *only* check {Proto} classes? Test if something is a class (and not just a constructor). ",
							"code": "export function isClass(any) {\n\tif (any && typeof any === 'function') {\n\t\tconst string = any.toString();\n\t\tconst regexs = [CLASS_SPEC, CLASS_BABEL, CLASS_CUSTOM];\n\t\treturn regexs.some(regexp => regexp.test(string));\n\t}\n\treturn false;\n}\n"
						},
						{
							"line": 221,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "any",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Something appears to be something array-like? ",
							"code": "export function isArrayLike(any) {\n\treturn any && '0' in any && !isArray(any);\n}\n"
						},
						{
							"line": 229,
							"tags": [
								{
									"name": "@param",
									"type": "{String}",
									"desc": "string",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Autocast string to an inferred type. '123' will return a number, `false` will return a boolean. ",
							"code": "export function cast(string) {\n\tconst s = String(string).trim();\n\tswitch (s) {\n\t\tcase 'null':\n\t\t\treturn null;\n\t\tcase 'undefined':\n\t\t\treturn undefined;\n\t\tcase 'true':\n\t\tcase 'false':\n\t\t\treturn s === 'true';\n\t\tdefault:\n\t\t\treturn String(parseInt(s, 10)) === s\n\t\t\t\t? parseInt(s, 10)\n\t\t\t\t: String(parseFloat(s)) === s\n\t\t\t\t\t? parseFloat(s)\n\t\t\t\t\t: String(string);\n\t}\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/util/src/data/IMapping.js": {
			"title": "IMapping",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { immutable, IMap, ISet, IList } from '../Immutable';\nimport { chained } from '../decorators';\n"
						},
						{
							"line": 2,
							"tags": [],
							"tabs": "\t",
							"desc": "\n\n",
							"code": "export default class IMapping {\n"
						},
						{
							"line": 6,
							"tags": [
								{
									"name": "@type",
									"type": "{IMap<IList<*>,ISet<Function|Object>>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Mapping patterns to set of function callbacks and/or object handlers. ",
							"code": "\tmap = new IMap();\n"
						},
						{
							"line": 11,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "pattern",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Function|Object}",
									"desc": "handler",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{this}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Add handler for pattern. ",
							"code": "\t@chained\n\tadd(pattern, handler) {\n\t\tthis.map = addhandler(this.map, immutable(pattern), handler);\n\t}\n"
						},
						{
							"line": 21,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "pattern",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Function|Object}",
									"desc": "handler",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{this}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Remove handler for pattern. ",
							"code": "\t@chained\n\tdel(pattern, handler) {\n\t\tthis.map = delhandler(this.map, immutable(pattern), handler);\n\t}\n"
						},
						{
							"line": 31,
							"tags": [
								{
									"name": "@param",
									"type": "{Array|IList}",
									"desc": "pattern",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Function|Object}",
									"desc": "[handler]",
									"text": "- Omit to confirm \"any handlers\""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Has any handlers for pattern (or one specific handler for pattern)? ",
							"code": "\thas(pattern, handler) {\n\t\treturn hashandler(this.map, immutable(pattern), handler);\n\t}\n"
						},
						{
							"line": 40,
							"tags": [
								{
									"name": "@param",
									"type": "{Array|IList}",
									"desc": "pattern",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{ISet<Function|Object>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Get handlers for pattern. ",
							"code": "\tget(pattern) {\n\t\treturn this.map.get(immutable(pattern));\n\t}\n"
						},
						{
							"line": 48,
							"tags": [],
							"tabs": "\t",
							"desc": "Clear the map. ",
							"code": "\t@chained\n\tclear() {\n\t\tthis.map.clear();\n\t}\n"
						},
						{
							"line": 55,
							"tags": [
								{
									"name": "@parity",
									"type": "{Mapping}",
									"desc": "",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{IMap<IList<*>,ISet<Function|Object>>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Get the map. ",
							"code": "\ttoMap() {\n\t\treturn this.map;\n\t}\n"
						},
						{
							"line": 63,
							"tags": [
								{
									"name": "@param",
									"type": "{Array|IList}",
									"desc": "pattern",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{ISet<Function|Object>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Get set indexed by key. Always returns an ISet. ",
							"code": "\ttoSet(pattern) {\n\t\treturn this.has(pattern) ? this.get(pattern) : new ISet();\n\t}\n"
						},
						{
							"line": 71,
							"tags": [
								{
									"name": "@param",
									"type": "{Array|IList}",
									"desc": "pattern",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<Function|Object>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get set indexed by key as array. Always returns an array. ",
							"code": "\ttoArray(pattern) {\n\t\treturn this.toSet((pattern = immutable(pattern))).toArray();\n\t}\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 81,
							"tags": [
								{
									"name": "@param",
									"type": "{IMap}",
									"desc": "map",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{IList}",
									"desc": "pattern",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Function|Object}",
									"desc": "handler",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{IMap}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Add handler for pattern. ",
							"code": "function addhandler(map, pattern, handler) {\n\treturn map.set(pattern, gethandler(map, pattern).add(handler));\n}\n"
						},
						{
							"line": 91,
							"tags": [
								{
									"name": "@param",
									"type": "{IMap}",
									"desc": "map",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{IList}",
									"desc": "pattern",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Function|Object}",
									"desc": "handler",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{IMap}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Remove handler for pattern. ",
							"code": "function delhandler(map, pattern, handler) {\n\tconst set = gethandler(map, pattern).delete(handler);\n\treturn set.size ? map.set(pattern, set) : map.delete(pattern);\n}\n"
						},
						{
							"line": 102,
							"tags": [
								{
									"name": "@param",
									"type": "{IMap}",
									"desc": "map",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{IList}",
									"desc": "pattern",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{ISet<Function|Object>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get handlers for pattern (or create a new set to store them). ",
							"code": "function gethandler(map, pattern) {\n\treturn map.has(pattern) ? map.get(pattern) : new ISet();\n}\n"
						},
						{
							"line": 111,
							"tags": [
								{
									"name": "@param",
									"type": "{IMap}",
									"desc": "map",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{IList}",
									"desc": "pattern",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Function|Object}",
									"desc": "[handler]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Has any handlers for pattern (or one specific handler for pattern)? ",
							"code": "function hashandler(map, pattern, handler) {\n\treturn map.has(pattern) && (handler ? map.get(pattern).has(handler) : true);\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/util/src/data/Mapping.js": {
			"title": "Mapping",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { chained } from '../decorators';\n"
						},
						{
							"line": 1,
							"tags": [
								{
									"name": "@type",
									"type": "{String}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "TODO: Why would Symbol not work nowadays????????????????????????????????????? Babel7 says \"Class \"Map\" cannot be referenced in computed property keys\" ???? See also https://github.com/facebook/flow/issues/252 ",
							"code": "const _map = Symbol('map');\n"
						},
						{
							"line": 8,
							"tags": [],
							"tabs": "\t",
							"desc": "\n\n",
							"code": "export default class Mapping {\n\t_map = new Map();\n"
						},
						{
							"line": 13,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "key",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{*}",
									"desc": "value",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{this}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Push entry to set indexed by key. TODO: Validate that `key` is a string ",
							"code": "\t@chained\n\tadd(key, value) {\n\t\tconst map = this._map;\n\t\tif (!map.has(key)) {\n\t\t\tmap.set(key, new Set());\n\t\t}\n\t\tconst set = map.get(key);\n\t\tif (!set.has(value)) {\n\t\t\tset.add(value);\n\t\t}\n\t}\n"
						},
						{
							"line": 31,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "key",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{*}",
									"desc": "value",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{this}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Remove entry from set indexed by key. TODO: Rename `delete` TODO: Validate that `key` is a string TODO: Validate that `value` is provided ",
							"code": "\t@chained\n\tdel(key, value) {\n\t\tlet map = this._map;\n\t\tlet set = map.get(key);\n\t\tif (set && set.has(value)) {\n\t\t\tset.delete(value);\n\t\t\tif (set.size === 0) {\n\t\t\t\tmap.delete(key);\n\t\t\t}\n\t\t}\n\t}\n"
						},
						{
							"line": 51,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "key",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{*}",
									"desc": "value",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "",
							"code": "\thas(key, value) {\n\t\tconst map = this._map;\n\t\tconst one = arguments.length === 1;\n\t\treturn map.has(key) && (one || map.get(key).has(value));\n\t}\n"
						},
						{
							"line": 61,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "key",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Set<*>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Get set indexed by key. Returns a copy. May return null. ",
							"code": "\tget(key) {\n\t\treturn this.has(key) ? new Set(this._map.get(key)) : undefined;\n\t}\n"
						},
						{
							"line": 69,
							"tags": [
								{
									"name": "@returns",
									"type": "{this}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Clear the map. ",
							"code": "\t@chained\n\tclear() {\n\t\tthis._map.clear();\n\t}\n"
						},
						{
							"line": 77,
							"tags": [
								{
									"name": "@returns",
									"type": "{Map<string,Set<*>>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Get the map. Returns a copy. ",
							"code": "\ttoMap() {\n\t\treturn new Map(this._map);\n\t}\n"
						},
						{
							"line": 84,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "key",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Set<*>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "\t",
							"desc": "Get the set indexed by key. Returns a copy. Always returns a Set. ",
							"code": "\ttoSet(key) {\n\t\treturn this.has(key) ? new Set(this._map.get(key)) : new Set();\n\t}\n"
						},
						{
							"line": 92,
							"tags": [
								{
									"name": "@param",
									"type": "{string}",
									"desc": "key",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Get the set indexed by key as array. Always returns an array. ",
							"code": "\ttoArray(key) {\n\t\treturn [...this.toSet(key)];\n\t}\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/util/src/decorators.js": {
			"title": "decorators",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "target",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "descriptor",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Object}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Make a method return `this` if otherwise it would return `undefined`. ",
							"code": "export function chained(target, name, descriptor) {\n\tlet unchained = descriptor.value;\n\tdescriptor.value = function() {\n\t\tlet result = unchained.apply(this, arguments);\n\t\treturn result === undefined ? this : result;\n\t};\n\treturn descriptor;\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/util/src/deps/immutable/README.md": {
			"title": "README",
			"markup": "###TODO",
			"type": "text/markdown"
		},
		"packages/util/src/deps/immutable/immutable.es.js": {
			"title": "immutable.es",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "Copyright (c) 2014-present, Facebook, Inc. \n\nThis source code is licensed under the MIT license found in the LICENSE file in the LOCAL!!! directory of this source tree. ",
							"code": "var DELETE = 'delete';\nvar SHIFT = 5; \nvar SIZE = 1 << SHIFT;\nvar MASK = SIZE - 1;\nvar NOT_SET = {};\nvar CHANGE_LENGTH = { value: false };\nvar DID_ALTER = { value: false };\nfunction MakeRef(ref) {\n\tref.value = false;\n\treturn ref;\n}\nfunction SetRef(ref) {\n\tref && (ref.value = true);\n}\nfunction OwnerID() {}\nfunction ensureSize(iter) {\n\tif (iter.size === undefined) {\n\t\titer.size = iter.__iterate(returnTrue);\n\t}\n\treturn iter.size;\n}\nfunction wrapIndex(iter, index) {\n\tif (typeof index !== 'number') {\n\t\tvar uint32Index = index >>> 0; \n\t\tif ('' + uint32Index !== index || uint32Index === 4294967295) {\n\t\t\treturn NaN;\n\t\t}\n\t\tindex = uint32Index;\n\t}\n\treturn index < 0 ? ensureSize(iter) + index : index;\n}\nfunction returnTrue() {\n\treturn true;\n}\nfunction wholeSlice(begin, end, size) {\n\treturn (\n\t\t((begin === 0 && !isNeg(begin)) ||\n\t\t\t(size !== undefined && begin <= -size)) &&\n\t\t(end === undefined || (size !== undefined && end >= size))\n\t);\n}\nfunction resolveBegin(begin, size) {\n\treturn resolveIndex(begin, size, 0);\n}\nfunction resolveEnd(end, size) {\n\treturn resolveIndex(end, size, size);\n}\nfunction resolveIndex(index, size, defaultIndex) {\n\treturn index === undefined\n\t\t? defaultIndex\n\t\t: isNeg(index)\n\t\t\t? size === Infinity\n\t\t\t\t? size\n\t\t\t\t: Math.max(0, size + index) | 0\n\t\t\t: size === undefined || size === index\n\t\t\t\t? index\n\t\t\t\t: Math.min(size, index) | 0;\n}\nfunction isNeg(value) {\n\treturn value < 0 || (value === 0 && 1 / value === -Infinity);\n}\nfunction isImmutable(maybeImmutable) {\n\treturn isCollection(maybeImmutable) || isRecord(maybeImmutable);\n}\nfunction isCollection(maybeCollection) {\n\treturn !!(maybeCollection && maybeCollection[IS_ITERABLE_SENTINEL]);\n}\nfunction isKeyed(maybeKeyed) {\n\treturn !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);\n}\nfunction isIndexed(maybeIndexed) {\n\treturn !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);\n}\nfunction isAssociative(maybeAssociative) {\n\treturn isKeyed(maybeAssociative) || isIndexed(maybeAssociative);\n}\nfunction isOrdered(maybeOrdered) {\n\treturn !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);\n}\nfunction isRecord(maybeRecord) {\n\treturn !!(maybeRecord && maybeRecord[IS_RECORD_SENTINEL]);\n}\nfunction isValueObject(maybeValue) {\n\treturn !!(\n\t\tmaybeValue &&\n\t\ttypeof maybeValue.equals === 'function' &&\n\t\ttypeof maybeValue.hashCode === 'function'\n\t);\n}\nvar IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\nvar IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\nvar IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\nvar IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\nvar IS_RECORD_SENTINEL = '@@__IMMUTABLE_RECORD__@@';\nvar Collection = function Collection(value) {\n\treturn isCollection(value) ? value : Seq(value);\n};\nvar KeyedCollection = (function(Collection) {\n\tfunction KeyedCollection(value) {\n\t\treturn isKeyed(value) ? value : KeyedSeq(value);\n\t}\n\tif (Collection) KeyedCollection.__proto__ = Collection;\n\tKeyedCollection.prototype = Object.create(Collection && Collection.prototype);\n\tKeyedCollection.prototype.constructor = KeyedCollection;\n\treturn KeyedCollection;\n})(Collection);\nvar IndexedCollection = (function(Collection) {\n\tfunction IndexedCollection(value) {\n\t\treturn isIndexed(value) ? value : IndexedSeq(value);\n\t}\n\tif (Collection) IndexedCollection.__proto__ = Collection;\n\tIndexedCollection.prototype = Object.create(\n\t\tCollection && Collection.prototype\n\t);\n\tIndexedCollection.prototype.constructor = IndexedCollection;\n\treturn IndexedCollection;\n})(Collection);\nvar SetCollection = (function(Collection) {\n\tfunction SetCollection(value) {\n\t\treturn isCollection(value) && !isAssociative(value) ? value : SetSeq(value);\n\t}\n\tif (Collection) SetCollection.__proto__ = Collection;\n\tSetCollection.prototype = Object.create(Collection && Collection.prototype);\n\tSetCollection.prototype.constructor = SetCollection;\n\treturn SetCollection;\n})(Collection);\nCollection.Keyed = KeyedCollection;\nCollection.Indexed = IndexedCollection;\nCollection.Set = SetCollection;\nvar ITERATE_KEYS = 0;\nvar ITERATE_VALUES = 1;\nvar ITERATE_ENTRIES = 2;\nvar REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nvar ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;\nvar Iterator = function Iterator(next) {\n\tthis.next = next;\n};\nIterator.prototype.toString = function toString() {\n\treturn '[Iterator]';\n};\nIterator.KEYS = ITERATE_KEYS;\nIterator.VALUES = ITERATE_VALUES;\nIterator.ENTRIES = ITERATE_ENTRIES;\nIterator.prototype.inspect = Iterator.prototype.toSource = function() {\n\treturn this.toString();\n};\nIterator.prototype[ITERATOR_SYMBOL] = function() {\n\treturn this;\n};\nfunction iteratorValue(type, k, v, iteratorResult) {\n\tvar value = type === 0 ? k : type === 1 ? v : [k, v];\n\titeratorResult\n\t\t? (iteratorResult.value = value)\n\t\t: (iteratorResult = {\n\t\t\t\tvalue: value,\n\t\t\t\tdone: false\n\t\t  });\n\treturn iteratorResult;\n}\nfunction iteratorDone() {\n\treturn { value: undefined, done: true };\n}\nfunction hasIterator(maybeIterable) {\n\treturn !!getIteratorFn(maybeIterable);\n}\nfunction isIterator(maybeIterator) {\n\treturn maybeIterator && typeof maybeIterator.next === 'function';\n}\nfunction getIterator(iterable) {\n\tvar iteratorFn = getIteratorFn(iterable);\n\treturn iteratorFn && iteratorFn.call(iterable);\n}\nfunction getIteratorFn(iterable) {\n\tvar iteratorFn =\n\t\titerable &&\n\t\t((REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||\n\t\t\titerable[FAUX_ITERATOR_SYMBOL]);\n\tif (typeof iteratorFn === 'function') {\n\t\treturn iteratorFn;\n\t}\n}\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction isArrayLike(value) {\n\treturn value && typeof value.length === 'number';\n}\nvar Seq = (function(Collection$$1) {\n\tfunction Seq(value) {\n\t\treturn value === null || value === undefined\n\t\t\t? emptySequence()\n\t\t\t: isImmutable(value)\n\t\t\t\t? value.toSeq()\n\t\t\t\t: seqFromValue(value);\n\t}\n\tif (Collection$$1) Seq.__proto__ = Collection$$1;\n\tSeq.prototype = Object.create(Collection$$1 && Collection$$1.prototype);\n\tSeq.prototype.constructor = Seq;\n\tSeq.prototype.toSeq = function toSeq() {\n\t\treturn this;\n\t};\n\tSeq.prototype.toString = function toString() {\n\t\treturn this.__toString('Seq {', '}');\n\t};\n\tSeq.prototype.cacheResult = function cacheResult() {\n\t\tif (!this._cache && this.__iterateUncached) {\n\t\t\tthis._cache = this.entrySeq().toArray();\n\t\t\tthis.size = this._cache.length;\n\t\t}\n\t\treturn this;\n\t};\n\t\n\tSeq.prototype.__iterate = function __iterate(fn, reverse) {\n\t\tvar this$1 = this;\n\t\tvar cache = this._cache;\n\t\tif (cache) {\n\t\t\tvar size = cache.length;\n\t\t\tvar i = 0;\n\t\t\twhile (i !== size) {\n\t\t\t\tvar entry = cache[reverse ? size - ++i : i++];\n\t\t\t\tif (fn(entry[1], entry[0], this$1) === false) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn i;\n\t\t}\n\t\treturn this.__iterateUncached(fn, reverse);\n\t};\n\t\n\tSeq.prototype.__iterator = function __iterator(type, reverse) {\n\t\tvar cache = this._cache;\n\t\tif (cache) {\n\t\t\tvar size = cache.length;\n\t\t\tvar i = 0;\n\t\t\treturn new Iterator(function() {\n\t\t\t\tif (i === size) {\n\t\t\t\t\treturn iteratorDone();\n\t\t\t\t}\n\t\t\t\tvar entry = cache[reverse ? size - ++i : i++];\n\t\t\t\treturn iteratorValue(type, entry[0], entry[1]);\n\t\t\t});\n\t\t}\n\t\treturn this.__iteratorUncached(type, reverse);\n\t};\n\treturn Seq;\n})(Collection);\nvar KeyedSeq = (function(Seq) {\n\tfunction KeyedSeq(value) {\n\t\treturn value === null || value === undefined\n\t\t\t? emptySequence().toKeyedSeq()\n\t\t\t: isCollection(value)\n\t\t\t\t? isKeyed(value)\n\t\t\t\t\t? value.toSeq()\n\t\t\t\t\t: value.fromEntrySeq()\n\t\t\t\t: isRecord(value)\n\t\t\t\t\t? value.toSeq()\n\t\t\t\t\t: keyedSeqFromValue(value);\n\t}\n\tif (Seq) KeyedSeq.__proto__ = Seq;\n\tKeyedSeq.prototype = Object.create(Seq && Seq.prototype);\n\tKeyedSeq.prototype.constructor = KeyedSeq;\n\tKeyedSeq.prototype.toKeyedSeq = function toKeyedSeq() {\n\t\treturn this;\n\t};\n\treturn KeyedSeq;\n})(Seq);\nvar IndexedSeq = (function(Seq) {\n\tfunction IndexedSeq(value) {\n\t\treturn value === null || value === undefined\n\t\t\t? emptySequence()\n\t\t\t: isCollection(value)\n\t\t\t\t? isKeyed(value)\n\t\t\t\t\t? value.entrySeq()\n\t\t\t\t\t: value.toIndexedSeq()\n\t\t\t\t: isRecord(value)\n\t\t\t\t\t? value.toSeq().entrySeq()\n\t\t\t\t\t: indexedSeqFromValue(value);\n\t}\n\tif (Seq) IndexedSeq.__proto__ = Seq;\n\tIndexedSeq.prototype = Object.create(Seq && Seq.prototype);\n\tIndexedSeq.prototype.constructor = IndexedSeq;\n\tIndexedSeq.of = function of() {\n\t\treturn IndexedSeq(arguments);\n\t};\n\tIndexedSeq.prototype.toIndexedSeq = function toIndexedSeq() {\n\t\treturn this;\n\t};\n\tIndexedSeq.prototype.toString = function toString() {\n\t\treturn this.__toString('Seq [', ']');\n\t};\n\treturn IndexedSeq;\n})(Seq);\nvar SetSeq = (function(Seq) {\n\tfunction SetSeq(value) {\n\t\treturn (isCollection(value) && !isAssociative(value)\n\t\t\t? value\n\t\t\t: IndexedSeq(value)\n\t\t).toSetSeq();\n\t}\n\tif (Seq) SetSeq.__proto__ = Seq;\n\tSetSeq.prototype = Object.create(Seq && Seq.prototype);\n\tSetSeq.prototype.constructor = SetSeq;\n\tSetSeq.of = function of() {\n\t\treturn SetSeq(arguments);\n\t};\n\tSetSeq.prototype.toSetSeq = function toSetSeq() {\n\t\treturn this;\n\t};\n\treturn SetSeq;\n})(Seq);\nSeq.isSeq = isSeq;\nSeq.Keyed = KeyedSeq;\nSeq.Set = SetSeq;\nSeq.Indexed = IndexedSeq;\nvar IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';\nSeq.prototype[IS_SEQ_SENTINEL] = true;\n\nvar ArraySeq = (function(IndexedSeq) {\n\tfunction ArraySeq(array) {\n\t\tthis._array = array;\n\t\tthis.size = array.length;\n\t}\n\tif (IndexedSeq) ArraySeq.__proto__ = IndexedSeq;\n\tArraySeq.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);\n\tArraySeq.prototype.constructor = ArraySeq;\n\tArraySeq.prototype.get = function get(index, notSetValue) {\n\t\treturn this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;\n\t};\n\tArraySeq.prototype.__iterate = function __iterate(fn, reverse) {\n\t\tvar this$1 = this;\n\t\tvar array = this._array;\n\t\tvar size = array.length;\n\t\tvar i = 0;\n\t\twhile (i !== size) {\n\t\t\tvar ii = reverse ? size - ++i : i++;\n\t\t\tif (fn(array[ii], ii, this$1) === false) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn i;\n\t};\n\tArraySeq.prototype.__iterator = function __iterator(type, reverse) {\n\t\tvar array = this._array;\n\t\tvar size = array.length;\n\t\tvar i = 0;\n\t\treturn new Iterator(function() {\n\t\t\tif (i === size) {\n\t\t\t\treturn iteratorDone();\n\t\t\t}\n\t\t\tvar ii = reverse ? size - ++i : i++;\n\t\t\treturn iteratorValue(type, ii, array[ii]);\n\t\t});\n\t};\n\treturn ArraySeq;\n})(IndexedSeq);\nvar ObjectSeq = (function(KeyedSeq) {\n\tfunction ObjectSeq(object) {\n\t\tvar keys = Object.keys(object);\n\t\tthis._object = object;\n\t\tthis._keys = keys;\n\t\tthis.size = keys.length;\n\t}\n\tif (KeyedSeq) ObjectSeq.__proto__ = KeyedSeq;\n\tObjectSeq.prototype = Object.create(KeyedSeq && KeyedSeq.prototype);\n\tObjectSeq.prototype.constructor = ObjectSeq;\n\tObjectSeq.prototype.get = function get(key, notSetValue) {\n\t\tif (notSetValue !== undefined && !this.has(key)) {\n\t\t\treturn notSetValue;\n\t\t}\n\t\treturn this._object[key];\n\t};\n\tObjectSeq.prototype.has = function has(key) {\n\t\treturn hasOwnProperty.call(this._object, key);\n\t};\n\tObjectSeq.prototype.__iterate = function __iterate(fn, reverse) {\n\t\tvar this$1 = this;\n\t\tvar object = this._object;\n\t\tvar keys = this._keys;\n\t\tvar size = keys.length;\n\t\tvar i = 0;\n\t\twhile (i !== size) {\n\t\t\tvar key = keys[reverse ? size - ++i : i++];\n\t\t\tif (fn(object[key], key, this$1) === false) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn i;\n\t};\n\tObjectSeq.prototype.__iterator = function __iterator(type, reverse) {\n\t\tvar object = this._object;\n\t\tvar keys = this._keys;\n\t\tvar size = keys.length;\n\t\tvar i = 0;\n\t\treturn new Iterator(function() {\n\t\t\tif (i === size) {\n\t\t\t\treturn iteratorDone();\n\t\t\t}\n\t\t\tvar key = keys[reverse ? size - ++i : i++];\n\t\t\treturn iteratorValue(type, key, object[key]);\n\t\t});\n\t};\n\treturn ObjectSeq;\n})(KeyedSeq);\nObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;\nvar CollectionSeq = (function(IndexedSeq) {\n\tfunction CollectionSeq(collection) {\n\t\tthis._collection = collection;\n\t\tthis.size = collection.length || collection.size;\n\t}\n\tif (IndexedSeq) CollectionSeq.__proto__ = IndexedSeq;\n\tCollectionSeq.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);\n\tCollectionSeq.prototype.constructor = CollectionSeq;\n\tCollectionSeq.prototype.__iterateUncached = function __iterateUncached(\n\t\tfn,\n\t\treverse\n\t) {\n\t\tvar this$1 = this;\n\t\tif (reverse) {\n\t\t\treturn this.cacheResult().__iterate(fn, reverse);\n\t\t}\n\t\tvar collection = this._collection;\n\t\tvar iterator = getIterator(collection);\n\t\tvar iterations = 0;\n\t\tif (isIterator(iterator)) {\n\t\t\tvar step;\n\t\t\twhile (!(step = iterator.next()).done) {\n\t\t\t\tif (fn(step.value, iterations++, this$1) === false) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn iterations;\n\t};\n\tCollectionSeq.prototype.__iteratorUncached = function __iteratorUncached(\n\t\ttype,\n\t\treverse\n\t) {\n\t\tif (reverse) {\n\t\t\treturn this.cacheResult().__iterator(type, reverse);\n\t\t}\n\t\tvar collection = this._collection;\n\t\tvar iterator = getIterator(collection);\n\t\tif (!isIterator(iterator)) {\n\t\t\treturn new Iterator(iteratorDone);\n\t\t}\n\t\tvar iterations = 0;\n\t\treturn new Iterator(function() {\n\t\t\tvar step = iterator.next();\n\t\t\treturn step.done ? step : iteratorValue(type, iterations++, step.value);\n\t\t});\n\t};\n\treturn CollectionSeq;\n})(IndexedSeq);\nvar IteratorSeq = (function(IndexedSeq) {\n\tfunction IteratorSeq(iterator) {\n\t\tthis._iterator = iterator;\n\t\tthis._iteratorCache = [];\n\t}\n\tif (IndexedSeq) IteratorSeq.__proto__ = IndexedSeq;\n\tIteratorSeq.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);\n\tIteratorSeq.prototype.constructor = IteratorSeq;\n\tIteratorSeq.prototype.__iterateUncached = function __iterateUncached(\n\t\tfn,\n\t\treverse\n\t) {\n\t\tvar this$1 = this;\n\t\tif (reverse) {\n\t\t\treturn this.cacheResult().__iterate(fn, reverse);\n\t\t}\n\t\tvar iterator = this._iterator;\n\t\tvar cache = this._iteratorCache;\n\t\tvar iterations = 0;\n\t\twhile (iterations < cache.length) {\n\t\t\tif (fn(cache[iterations], iterations++, this$1) === false) {\n\t\t\t\treturn iterations;\n\t\t\t}\n\t\t}\n\t\tvar step;\n\t\twhile (!(step = iterator.next()).done) {\n\t\t\tvar val = step.value;\n\t\t\tcache[iterations] = val;\n\t\t\tif (fn(val, iterations++, this$1) === false) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn iterations;\n\t};\n\tIteratorSeq.prototype.__iteratorUncached = function __iteratorUncached(\n\t\ttype,\n\t\treverse\n\t) {\n\t\tif (reverse) {\n\t\t\treturn this.cacheResult().__iterator(type, reverse);\n\t\t}\n\t\tvar iterator = this._iterator;\n\t\tvar cache = this._iteratorCache;\n\t\tvar iterations = 0;\n\t\treturn new Iterator(function() {\n\t\t\tif (iterations >= cache.length) {\n\t\t\t\tvar step = iterator.next();\n\t\t\t\tif (step.done) {\n\t\t\t\t\treturn step;\n\t\t\t\t}\n\t\t\t\tcache[iterations] = step.value;\n\t\t\t}\n\t\t\treturn iteratorValue(type, iterations, cache[iterations++]);\n\t\t});\n\t};\n\treturn IteratorSeq;\n})(IndexedSeq);\n\nfunction isSeq(maybeSeq) {\n\treturn !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);\n}\nvar EMPTY_SEQ;\nfunction emptySequence() {\n\treturn EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));\n}\nfunction keyedSeqFromValue(value) {\n\tvar seq = Array.isArray(value)\n\t\t? new ArraySeq(value)\n\t\t: isIterator(value)\n\t\t\t? new IteratorSeq(value)\n\t\t\t: hasIterator(value)\n\t\t\t\t? new CollectionSeq(value)\n\t\t\t\t: undefined;\n\tif (seq) {\n\t\treturn seq.fromEntrySeq();\n\t}\n\tif (typeof value === 'object') {\n\t\treturn new ObjectSeq(value);\n\t}\n\tthrow new TypeError(\n\t\t'Expected Array or collection object of [k, v] entries, or keyed object: ' +\n\t\t\tvalue\n\t);\n}\nfunction indexedSeqFromValue(value) {\n\tvar seq = maybeIndexedSeqFromValue(value);\n\tif (seq) {\n\t\treturn seq;\n\t}\n\tthrow new TypeError(\n\t\t'Expected Array or collection object of values: ' + value\n\t);\n}\nfunction seqFromValue(value) {\n\tvar seq = maybeIndexedSeqFromValue(value);\n\tif (seq) {\n\t\treturn seq;\n\t}\n\tif (typeof value === 'object') {\n\t\treturn new ObjectSeq(value);\n\t}\n\tthrow new TypeError(\n\t\t'Expected Array or collection object of values, or keyed object: ' + value\n\t);\n}\nfunction maybeIndexedSeqFromValue(value) {\n\treturn isArrayLike(value)\n\t\t? new ArraySeq(value)\n\t\t: isIterator(value)\n\t\t\t? new IteratorSeq(value)\n\t\t\t: hasIterator(value)\n\t\t\t\t? new CollectionSeq(value)\n\t\t\t\t: undefined;\n}\n"
						},
						{
							"line": 572,
							"tags": [],
							"tabs": "",
							"desc": "An extension of the \"same-value\" algorithm as [described for use by ES6 Map and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality) \n\nNaN is considered the same as NaN, however -0 and 0 are considered the same value, which is different from the algorithm described by \n[`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is). \n\nThis is extended further to allow Objects to describe the values they represent, by way of `valueOf` or `equals` (and `hashCode`). \n\nNote: because of this extension, the key equality of Immutable.Map and the value equality of Immutable.Set will differ from ES6 Map and Set. \n\n\n### Defining custom values\n\n\n\nThe easiest way to describe the value an object represents is by implementing \n`valueOf`. For example, `Date` represents a value by returning a unix timestamp for `valueOf`: \n\nvar date1 = new Date(1234567890000); // Fri Feb 13 2009 ... var date2 = new Date(1234567890000); date1.valueOf(); // 1234567890000 assert( date1 !== date2 ); assert( Immutable.is( date1, date2 ) ); \n\nNote: overriding `valueOf` may have other implications if you use this object where JavaScript expects a primitive, such as implicit string coercion. \n\nFor more complex types, especially collections, implementing `valueOf` may not be performant. An alternative is to implement `equals` and `hashCode`. \n\n\n`equals` takes another object, presumably of similar type, and returns true if it is equal. Equality is symmetrical, so the same result should be returned if this and the argument are flipped. \n\nassert( a.equals(b) === b.equals(a) ); \n\n\n`hashCode` returns a 32bit integer number representing the object which will be used to determine how to store the value object in a Map or Set. You must provide both or neither methods, one must not exist without the other. \n\nAlso, an important relationship between these methods must be upheld: if two values are equal, they *must* return the same hashCode. If the values are not equal, they might have the same hashCode; this is called a hash collision, and while undesirable for performance reasons, it is acceptable. \n\nif (a.equals(b)) { assert( a.hashCode() === b.hashCode() ); \n} \n\nAll Immutable collections are Value Objects: they implement `equals()` and `hashCode()`. ",
							"code": "function is(valueA, valueB) {\n\tif (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n\t\treturn true;\n\t}\n\tif (!valueA || !valueB) {\n\t\treturn false;\n\t}\n\tif (\n\t\ttypeof valueA.valueOf === 'function' &&\n\t\ttypeof valueB.valueOf === 'function'\n\t) {\n\t\tvalueA = valueA.valueOf();\n\t\tvalueB = valueB.valueOf();\n\t\tif (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!valueA || !valueB) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn !!(\n\t\tisValueObject(valueA) &&\n\t\tisValueObject(valueB) &&\n\t\tvalueA.equals(valueB)\n\t);\n}\nvar imul =\n\ttypeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2\n\t\t? Math.imul\n\t\t: function imul(a, b) {\n\t\t\t\ta |= 0; \n\t\t\t\tb |= 0; \n\t\t\t\tvar c = a & 0xffff;\n\t\t\t\tvar d = b & 0xffff;\n\t\t\t\treturn (c * d + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0)) | 0; \n\t\t  };\nfunction smi(i32) {\n\treturn ((i32 >>> 1) & 0x40000000) | (i32 & 0xbfffffff);\n}\nfunction hash(o) {\n\tif (o === false || o === null || o === undefined) {\n\t\treturn 0;\n\t}\n\tif (typeof o.valueOf === 'function') {\n\t\to = o.valueOf();\n\t\tif (o === false || o === null || o === undefined) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (o === true) {\n\t\treturn 1;\n\t}\n\tvar type = typeof o;\n\tif (type === 'number') {\n\t\tif (o !== o || o === Infinity) {\n\t\t\treturn 0;\n\t\t}\n\t\tvar h = o | 0;\n\t\tif (h !== o) {\n\t\t\th ^= o * 0xffffffff;\n\t\t}\n\t\twhile (o > 0xffffffff) {\n\t\t\to /= 0xffffffff;\n\t\t\th ^= o;\n\t\t}\n\t\treturn smi(h);\n\t}\n\tif (type === 'string') {\n\t\treturn o.length > STRING_HASH_CACHE_MIN_STRLEN\n\t\t\t? cachedHashString(o)\n\t\t\t: hashString(o);\n\t}\n\tif (typeof o.hashCode === 'function') {\n\t\treturn smi(o.hashCode());\n\t}\n\tif (type === 'object') {\n\t\treturn hashJSObj(o);\n\t}\n\tif (typeof o.toString === 'function') {\n\t\treturn hashString(o.toString());\n\t}\n\tthrow new Error('Value type ' + type + ' cannot be hashed.');\n}\nfunction cachedHashString(string) {\n\tvar hashed = stringHashCache[string];\n\tif (hashed === undefined) {\n\t\thashed = hashString(string);\n\t\tif (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {\n\t\t\tSTRING_HASH_CACHE_SIZE = 0;\n\t\t\tstringHashCache = {};\n\t\t}\n\t\tSTRING_HASH_CACHE_SIZE++;\n\t\tstringHashCache[string] = hashed;\n\t}\n\treturn hashed;\n}\nfunction hashString(string) {\n\tvar hashed = 0;\n\tfor (var ii = 0; ii < string.length; ii++) {\n\t\thashed = (31 * hashed + string.charCodeAt(ii)) | 0;\n\t}\n\treturn smi(hashed);\n}\nfunction hashJSObj(obj) {\n\tvar hashed;\n\tif (usingWeakMap) {\n\t\thashed = weakMap.get(obj);\n\t\tif (hashed !== undefined) {\n\t\t\treturn hashed;\n\t\t}\n\t}\n\thashed = obj[UID_HASH_KEY];\n\tif (hashed !== undefined) {\n\t\treturn hashed;\n\t}\n\tif (!canDefineProperty) {\n\t\thashed = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];\n\t\tif (hashed !== undefined) {\n\t\t\treturn hashed;\n\t\t}\n\t\thashed = getIENodeHash(obj);\n\t\tif (hashed !== undefined) {\n\t\t\treturn hashed;\n\t\t}\n\t}\n\thashed = ++objHashUID;\n\tif (objHashUID & 0x40000000) {\n\t\tobjHashUID = 0;\n\t}\n\tif (usingWeakMap) {\n\t\tweakMap.set(obj, hashed);\n\t} else if (isExtensible !== undefined && isExtensible(obj) === false) {\n\t\tthrow new Error('Non-extensible objects are not allowed as keys.');\n\t} else if (canDefineProperty) {\n\t\tObject.defineProperty(obj, UID_HASH_KEY, {\n\t\t\tenumerable: false,\n\t\t\tconfigurable: false,\n\t\t\twritable: false,\n\t\t\tvalue: hashed\n\t\t});\n\t} else if (\n\t\tobj.propertyIsEnumerable !== undefined &&\n\t\tobj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable\n\t) {\n\t\tobj.propertyIsEnumerable = function() {\n\t\t\treturn this.constructor.prototype.propertyIsEnumerable.apply(\n\t\t\t\tthis,\n\t\t\t\targuments\n\t\t\t);\n\t\t};\n\t\tobj.propertyIsEnumerable[UID_HASH_KEY] = hashed;\n\t} else if (obj.nodeType !== undefined) {\n\t\tobj[UID_HASH_KEY] = hashed;\n\t} else {\n\t\tthrow new Error('Unable to set a non-enumerable property on object.');\n\t}\n\treturn hashed;\n}\nvar isExtensible = Object.isExtensible;\nvar canDefineProperty = (function() {\n\ttry {\n\t\tObject.defineProperty({}, '@', {});\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n})();\nfunction getIENodeHash(node) {\n\tif (node && node.nodeType > 0) {\n\t\tswitch (node.nodeType) {\n\t\t\tcase 1: \n\t\t\t\treturn node.uniqueID;\n\t\t\tcase 9: \n\t\t\t\treturn node.documentElement && node.documentElement.uniqueID;\n\t\t}\n\t}\n}\nvar usingWeakMap = typeof WeakMap === 'function';\nvar weakMap;\nif (usingWeakMap) {\n\tweakMap = new WeakMap();\n}\nvar objHashUID = 0;\nvar UID_HASH_KEY = '__immutablehash__';\nif (typeof Symbol === 'function') {\n\tUID_HASH_KEY = Symbol(UID_HASH_KEY);\n}\nvar STRING_HASH_CACHE_MIN_STRLEN = 16;\nvar STRING_HASH_CACHE_MAX_SIZE = 255;\nvar STRING_HASH_CACHE_SIZE = 0;\nvar stringHashCache = {};\nvar ToKeyedSequence = (function(KeyedSeq$$1) {\n\tfunction ToKeyedSequence(indexed, useKeys) {\n\t\tthis._iter = indexed;\n\t\tthis._useKeys = useKeys;\n\t\tthis.size = indexed.size;\n\t}\n\tif (KeyedSeq$$1) ToKeyedSequence.__proto__ = KeyedSeq$$1;\n\tToKeyedSequence.prototype = Object.create(\n\t\tKeyedSeq$$1 && KeyedSeq$$1.prototype\n\t);\n\tToKeyedSequence.prototype.constructor = ToKeyedSequence;\n\tToKeyedSequence.prototype.get = function get(key, notSetValue) {\n\t\treturn this._iter.get(key, notSetValue);\n\t};\n\tToKeyedSequence.prototype.has = function has(key) {\n\t\treturn this._iter.has(key);\n\t};\n\tToKeyedSequence.prototype.valueSeq = function valueSeq() {\n\t\treturn this._iter.valueSeq();\n\t};\n\tToKeyedSequence.prototype.reverse = function reverse() {\n\t\tvar this$1 = this;\n\t\tvar reversedSequence = reverseFactory(this, true);\n\t\tif (!this._useKeys) {\n\t\t\treversedSequence.valueSeq = function() {\n\t\t\t\treturn this$1._iter.toSeq().reverse();\n\t\t\t};\n\t\t}\n\t\treturn reversedSequence;\n\t};\n\tToKeyedSequence.prototype.map = function map(mapper, context) {\n\t\tvar this$1 = this;\n\t\tvar mappedSequence = mapFactory(this, mapper, context);\n\t\tif (!this._useKeys) {\n\t\t\tmappedSequence.valueSeq = function() {\n\t\t\t\treturn this$1._iter.toSeq().map(mapper, context);\n\t\t\t};\n\t\t}\n\t\treturn mappedSequence;\n\t};\n\tToKeyedSequence.prototype.__iterate = function __iterate(fn, reverse) {\n\t\tvar this$1 = this;\n\t\treturn this._iter.__iterate(function(v, k) {\n\t\t\treturn fn(v, k, this$1);\n\t\t}, reverse);\n\t};\n\tToKeyedSequence.prototype.__iterator = function __iterator(type, reverse) {\n\t\treturn this._iter.__iterator(type, reverse);\n\t};\n\treturn ToKeyedSequence;\n})(KeyedSeq);\nToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;\nvar ToIndexedSequence = (function(IndexedSeq$$1) {\n\tfunction ToIndexedSequence(iter) {\n\t\tthis._iter = iter;\n\t\tthis.size = iter.size;\n\t}\n\tif (IndexedSeq$$1) ToIndexedSequence.__proto__ = IndexedSeq$$1;\n\tToIndexedSequence.prototype = Object.create(\n\t\tIndexedSeq$$1 && IndexedSeq$$1.prototype\n\t);\n\tToIndexedSequence.prototype.constructor = ToIndexedSequence;\n\tToIndexedSequence.prototype.includes = function includes(value) {\n\t\treturn this._iter.includes(value);\n\t};\n\tToIndexedSequence.prototype.__iterate = function __iterate(fn, reverse) {\n\t\tvar this$1 = this;\n\t\tvar i = 0;\n\t\treverse && ensureSize(this);\n\t\treturn this._iter.__iterate(function(v) {\n\t\t\treturn fn(v, reverse ? this$1.size - ++i : i++, this$1);\n\t\t}, reverse);\n\t};\n\tToIndexedSequence.prototype.__iterator = function __iterator(type, reverse) {\n\t\tvar this$1 = this;\n\t\tvar iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n\t\tvar i = 0;\n\t\treverse && ensureSize(this);\n\t\treturn new Iterator(function() {\n\t\t\tvar step = iterator.next();\n\t\t\treturn step.done\n\t\t\t\t? step\n\t\t\t\t: iteratorValue(\n\t\t\t\t\t\ttype,\n\t\t\t\t\t\treverse ? this$1.size - ++i : i++,\n\t\t\t\t\t\tstep.value,\n\t\t\t\t\t\tstep\n\t\t\t\t  );\n\t\t});\n\t};\n\treturn ToIndexedSequence;\n})(IndexedSeq);\nvar ToSetSequence = (function(SetSeq$$1) {\n\tfunction ToSetSequence(iter) {\n\t\tthis._iter = iter;\n\t\tthis.size = iter.size;\n\t}\n\tif (SetSeq$$1) ToSetSequence.__proto__ = SetSeq$$1;\n\tToSetSequence.prototype = Object.create(SetSeq$$1 && SetSeq$$1.prototype);\n\tToSetSequence.prototype.constructor = ToSetSequence;\n\tToSetSequence.prototype.has = function has(key) {\n\t\treturn this._iter.includes(key);\n\t};\n\tToSetSequence.prototype.__iterate = function __iterate(fn, reverse) {\n\t\tvar this$1 = this;\n\t\treturn this._iter.__iterate(function(v) {\n\t\t\treturn fn(v, v, this$1);\n\t\t}, reverse);\n\t};\n\tToSetSequence.prototype.__iterator = function __iterator(type, reverse) {\n\t\tvar iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n\t\treturn new Iterator(function() {\n\t\t\tvar step = iterator.next();\n\t\t\treturn step.done\n\t\t\t\t? step\n\t\t\t\t: iteratorValue(type, step.value, step.value, step);\n\t\t});\n\t};\n\treturn ToSetSequence;\n})(SetSeq);\nvar FromEntriesSequence = (function(KeyedSeq$$1) {\n\tfunction FromEntriesSequence(entries) {\n\t\tthis._iter = entries;\n\t\tthis.size = entries.size;\n\t}\n\tif (KeyedSeq$$1) FromEntriesSequence.__proto__ = KeyedSeq$$1;\n\tFromEntriesSequence.prototype = Object.create(\n\t\tKeyedSeq$$1 && KeyedSeq$$1.prototype\n\t);\n\tFromEntriesSequence.prototype.constructor = FromEntriesSequence;\n\tFromEntriesSequence.prototype.entrySeq = function entrySeq() {\n\t\treturn this._iter.toSeq();\n\t};\n\tFromEntriesSequence.prototype.__iterate = function __iterate(fn, reverse) {\n\t\tvar this$1 = this;\n\t\treturn this._iter.__iterate(function(entry) {\n\t\t\tif (entry) {\n\t\t\t\tvalidateEntry(entry);\n\t\t\t\tvar indexedCollection = isCollection(entry);\n\t\t\t\treturn fn(\n\t\t\t\t\tindexedCollection ? entry.get(1) : entry[1],\n\t\t\t\t\tindexedCollection ? entry.get(0) : entry[0],\n\t\t\t\t\tthis$1\n\t\t\t\t);\n\t\t\t}\n\t\t}, reverse);\n\t};\n\tFromEntriesSequence.prototype.__iterator = function __iterator(\n\t\ttype,\n\t\treverse\n\t) {\n\t\tvar iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n\t\treturn new Iterator(function() {\n\t\t\twhile (true) {\n\t\t\t\tvar step = iterator.next();\n\t\t\t\tif (step.done) {\n\t\t\t\t\treturn step;\n\t\t\t\t}\n\t\t\t\tvar entry = step.value;\n\t\t\t\tif (entry) {\n\t\t\t\t\tvalidateEntry(entry);\n\t\t\t\t\tvar indexedCollection = isCollection(entry);\n\t\t\t\t\treturn iteratorValue(\n\t\t\t\t\t\ttype,\n\t\t\t\t\t\tindexedCollection ? entry.get(0) : entry[0],\n\t\t\t\t\t\tindexedCollection ? entry.get(1) : entry[1],\n\t\t\t\t\t\tstep\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\treturn FromEntriesSequence;\n})(KeyedSeq);\nToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;\nfunction flipFactory(collection) {\n\tvar flipSequence = makeSequence(collection);\n\tflipSequence._iter = collection;\n\tflipSequence.size = collection.size;\n\tflipSequence.flip = function() {\n\t\treturn collection;\n\t};\n\tflipSequence.reverse = function() {\n\t\tvar reversedSequence = collection.reverse.apply(this); \n\t\treversedSequence.flip = function() {\n\t\t\treturn collection.reverse();\n\t\t};\n\t\treturn reversedSequence;\n\t};\n\tflipSequence.has = function(key) {\n\t\treturn collection.includes(key);\n\t};\n\tflipSequence.includes = function(key) {\n\t\treturn collection.has(key);\n\t};\n\tflipSequence.cacheResult = cacheResultThrough;\n\tflipSequence.__iterateUncached = function(fn, reverse) {\n\t\tvar this$1 = this;\n\t\treturn collection.__iterate(function(v, k) {\n\t\t\treturn fn(k, v, this$1) !== false;\n\t\t}, reverse);\n\t};\n\tflipSequence.__iteratorUncached = function(type, reverse) {\n\t\tif (type === ITERATE_ENTRIES) {\n\t\t\tvar iterator = collection.__iterator(type, reverse);\n\t\t\treturn new Iterator(function() {\n\t\t\t\tvar step = iterator.next();\n\t\t\t\tif (!step.done) {\n\t\t\t\t\tvar k = step.value[0];\n\t\t\t\t\tstep.value[0] = step.value[1];\n\t\t\t\t\tstep.value[1] = k;\n\t\t\t\t}\n\t\t\t\treturn step;\n\t\t\t});\n\t\t}\n\t\treturn collection.__iterator(\n\t\t\ttype === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,\n\t\t\treverse\n\t\t);\n\t};\n\treturn flipSequence;\n}\nfunction mapFactory(collection, mapper, context) {\n\tvar mappedSequence = makeSequence(collection);\n\tmappedSequence.size = collection.size;\n\tmappedSequence.has = function(key) {\n\t\treturn collection.has(key);\n\t};\n\tmappedSequence.get = function(key, notSetValue) {\n\t\tvar v = collection.get(key, NOT_SET);\n\t\treturn v === NOT_SET\n\t\t\t? notSetValue\n\t\t\t: mapper.call(context, v, key, collection);\n\t};\n\tmappedSequence.__iterateUncached = function(fn, reverse) {\n\t\tvar this$1 = this;\n\t\treturn collection.__iterate(function(v, k, c) {\n\t\t\treturn fn(mapper.call(context, v, k, c), k, this$1) !== false;\n\t\t}, reverse);\n\t};\n\tmappedSequence.__iteratorUncached = function(type, reverse) {\n\t\tvar iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n\t\treturn new Iterator(function() {\n\t\t\tvar step = iterator.next();\n\t\t\tif (step.done) {\n\t\t\t\treturn step;\n\t\t\t}\n\t\t\tvar entry = step.value;\n\t\t\tvar key = entry[0];\n\t\t\treturn iteratorValue(\n\t\t\t\ttype,\n\t\t\t\tkey,\n\t\t\t\tmapper.call(context, entry[1], key, collection),\n\t\t\t\tstep\n\t\t\t);\n\t\t});\n\t};\n\treturn mappedSequence;\n}\nfunction reverseFactory(collection, useKeys) {\n\tvar this$1 = this;\n\tvar reversedSequence = makeSequence(collection);\n\treversedSequence._iter = collection;\n\treversedSequence.size = collection.size;\n\treversedSequence.reverse = function() {\n\t\treturn collection;\n\t};\n\tif (collection.flip) {\n\t\treversedSequence.flip = function() {\n\t\t\tvar flipSequence = flipFactory(collection);\n\t\t\tflipSequence.reverse = function() {\n\t\t\t\treturn collection.flip();\n\t\t\t};\n\t\t\treturn flipSequence;\n\t\t};\n\t}\n\treversedSequence.get = function(key, notSetValue) {\n\t\treturn collection.get(useKeys ? key : -1 - key, notSetValue);\n\t};\n\treversedSequence.has = function(key) {\n\t\treturn collection.has(useKeys ? key : -1 - key);\n\t};\n\treversedSequence.includes = function(value) {\n\t\treturn collection.includes(value);\n\t};\n\treversedSequence.cacheResult = cacheResultThrough;\n\treversedSequence.__iterate = function(fn, reverse) {\n\t\tvar this$1 = this;\n\t\tvar i = 0;\n\t\treverse && ensureSize(collection);\n\t\treturn collection.__iterate(function(v, k) {\n\t\t\treturn fn(v, useKeys ? k : reverse ? this$1.size - ++i : i++, this$1);\n\t\t}, !reverse);\n\t};\n\treversedSequence.__iterator = function(type, reverse) {\n\t\tvar i = 0;\n\t\treverse && ensureSize(collection);\n\t\tvar iterator = collection.__iterator(ITERATE_ENTRIES, !reverse);\n\t\treturn new Iterator(function() {\n\t\t\tvar step = iterator.next();\n\t\t\tif (step.done) {\n\t\t\t\treturn step;\n\t\t\t}\n\t\t\tvar entry = step.value;\n\t\t\treturn iteratorValue(\n\t\t\t\ttype,\n\t\t\t\tuseKeys ? entry[0] : reverse ? this$1.size - ++i : i++,\n\t\t\t\tentry[1],\n\t\t\t\tstep\n\t\t\t);\n\t\t});\n\t};\n\treturn reversedSequence;\n}\nfunction filterFactory(collection, predicate, context, useKeys) {\n\tvar filterSequence = makeSequence(collection);\n\tif (useKeys) {\n\t\tfilterSequence.has = function(key) {\n\t\t\tvar v = collection.get(key, NOT_SET);\n\t\t\treturn v !== NOT_SET && !!predicate.call(context, v, key, collection);\n\t\t};\n\t\tfilterSequence.get = function(key, notSetValue) {\n\t\t\tvar v = collection.get(key, NOT_SET);\n\t\t\treturn v !== NOT_SET && predicate.call(context, v, key, collection)\n\t\t\t\t? v\n\t\t\t\t: notSetValue;\n\t\t};\n\t}\n\tfilterSequence.__iterateUncached = function(fn, reverse) {\n\t\tvar this$1 = this;\n\t\tvar iterations = 0;\n\t\tcollection.__iterate(function(v, k, c) {\n\t\t\tif (predicate.call(context, v, k, c)) {\n\t\t\t\titerations++;\n\t\t\t\treturn fn(v, useKeys ? k : iterations - 1, this$1);\n\t\t\t}\n\t\t}, reverse);\n\t\treturn iterations;\n\t};\n\tfilterSequence.__iteratorUncached = function(type, reverse) {\n\t\tvar iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n\t\tvar iterations = 0;\n\t\treturn new Iterator(function() {\n\t\t\twhile (true) {\n\t\t\t\tvar step = iterator.next();\n\t\t\t\tif (step.done) {\n\t\t\t\t\treturn step;\n\t\t\t\t}\n\t\t\t\tvar entry = step.value;\n\t\t\t\tvar key = entry[0];\n\t\t\t\tvar value = entry[1];\n\t\t\t\tif (predicate.call(context, value, key, collection)) {\n\t\t\t\t\treturn iteratorValue(type, useKeys ? key : iterations++, value, step);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\treturn filterSequence;\n}\nfunction countByFactory(collection, grouper, context) {\n\tvar groups = Map().asMutable();\n\tcollection.__iterate(function(v, k) {\n\t\tgroups.update(grouper.call(context, v, k, collection), 0, function(a) {\n\t\t\treturn a + 1;\n\t\t});\n\t});\n\treturn groups.asImmutable();\n}\nfunction groupByFactory(collection, grouper, context) {\n\tvar isKeyedIter = isKeyed(collection);\n\tvar groups = (isOrdered(collection) ? OrderedMap() : Map()).asMutable();\n\tcollection.__iterate(function(v, k) {\n\t\tgroups.update(grouper.call(context, v, k, collection), function(a) {\n\t\t\treturn (a = a || []), a.push(isKeyedIter ? [k, v] : v), a;\n\t\t});\n\t});\n\tvar coerce = collectionClass(collection);\n\treturn groups.map(function(arr) {\n\t\treturn reify(collection, coerce(arr));\n\t});\n}\nfunction sliceFactory(collection, begin, end, useKeys) {\n\tvar originalSize = collection.size;\n\tif (wholeSlice(begin, end, originalSize)) {\n\t\treturn collection;\n\t}\n\tvar resolvedBegin = resolveBegin(begin, originalSize);\n\tvar resolvedEnd = resolveEnd(end, originalSize);\n\tif (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {\n\t\treturn sliceFactory(collection.toSeq().cacheResult(), begin, end, useKeys);\n\t}\n\tvar resolvedSize = resolvedEnd - resolvedBegin;\n\tvar sliceSize;\n\tif (resolvedSize === resolvedSize) {\n\t\tsliceSize = resolvedSize < 0 ? 0 : resolvedSize;\n\t}\n\tvar sliceSeq = makeSequence(collection);\n\tsliceSeq.size =\n\t\tsliceSize === 0 ? sliceSize : (collection.size && sliceSize) || undefined;\n\tif (!useKeys && isSeq(collection) && sliceSize >= 0) {\n\t\tsliceSeq.get = function(index, notSetValue) {\n\t\t\tindex = wrapIndex(this, index);\n\t\t\treturn index >= 0 && index < sliceSize\n\t\t\t\t? collection.get(index + resolvedBegin, notSetValue)\n\t\t\t\t: notSetValue;\n\t\t};\n\t}\n\tsliceSeq.__iterateUncached = function(fn, reverse) {\n\t\tvar this$1 = this;\n\t\tif (sliceSize === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (reverse) {\n\t\t\treturn this.cacheResult().__iterate(fn, reverse);\n\t\t}\n\t\tvar skipped = 0;\n\t\tvar isSkipping = true;\n\t\tvar iterations = 0;\n\t\tcollection.__iterate(function(v, k) {\n\t\t\tif (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {\n\t\t\t\titerations++;\n\t\t\t\treturn (\n\t\t\t\t\tfn(v, useKeys ? k : iterations - 1, this$1) !== false &&\n\t\t\t\t\titerations !== sliceSize\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\t\treturn iterations;\n\t};\n\tsliceSeq.__iteratorUncached = function(type, reverse) {\n\t\tif (sliceSize !== 0 && reverse) {\n\t\t\treturn this.cacheResult().__iterator(type, reverse);\n\t\t}\n\t\tif (sliceSize === 0) {\n\t\t\treturn new Iterator(iteratorDone);\n\t\t}\n\t\tvar iterator = collection.__iterator(type, reverse);\n\t\tvar skipped = 0;\n\t\tvar iterations = 0;\n\t\treturn new Iterator(function() {\n\t\t\twhile (skipped++ < resolvedBegin) {\n\t\t\t\titerator.next();\n\t\t\t}\n\t\t\tif (++iterations > sliceSize) {\n\t\t\t\treturn iteratorDone();\n\t\t\t}\n\t\t\tvar step = iterator.next();\n\t\t\tif (useKeys || type === ITERATE_VALUES || step.done) {\n\t\t\t\treturn step;\n\t\t\t}\n\t\t\tif (type === ITERATE_KEYS) {\n\t\t\t\treturn iteratorValue(type, iterations - 1, undefined, step);\n\t\t\t}\n\t\t\treturn iteratorValue(type, iterations - 1, step.value[1], step);\n\t\t});\n\t};\n\treturn sliceSeq;\n}\nfunction takeWhileFactory(collection, predicate, context) {\n\tvar takeSequence = makeSequence(collection);\n\ttakeSequence.__iterateUncached = function(fn, reverse) {\n\t\tvar this$1 = this;\n\t\tif (reverse) {\n\t\t\treturn this.cacheResult().__iterate(fn, reverse);\n\t\t}\n\t\tvar iterations = 0;\n\t\tcollection.__iterate(function(v, k, c) {\n\t\t\treturn (\n\t\t\t\tpredicate.call(context, v, k, c) && ++iterations && fn(v, k, this$1)\n\t\t\t);\n\t\t});\n\t\treturn iterations;\n\t};\n\ttakeSequence.__iteratorUncached = function(type, reverse) {\n\t\tvar this$1 = this;\n\t\tif (reverse) {\n\t\t\treturn this.cacheResult().__iterator(type, reverse);\n\t\t}\n\t\tvar iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n\t\tvar iterating = true;\n\t\treturn new Iterator(function() {\n\t\t\tif (!iterating) {\n\t\t\t\treturn iteratorDone();\n\t\t\t}\n\t\t\tvar step = iterator.next();\n\t\t\tif (step.done) {\n\t\t\t\treturn step;\n\t\t\t}\n\t\t\tvar entry = step.value;\n\t\t\tvar k = entry[0];\n\t\t\tvar v = entry[1];\n\t\t\tif (!predicate.call(context, v, k, this$1)) {\n\t\t\t\titerating = false;\n\t\t\t\treturn iteratorDone();\n\t\t\t}\n\t\t\treturn type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);\n\t\t});\n\t};\n\treturn takeSequence;\n}\nfunction skipWhileFactory(collection, predicate, context, useKeys) {\n\tvar skipSequence = makeSequence(collection);\n\tskipSequence.__iterateUncached = function(fn, reverse) {\n\t\tvar this$1 = this;\n\t\tif (reverse) {\n\t\t\treturn this.cacheResult().__iterate(fn, reverse);\n\t\t}\n\t\tvar isSkipping = true;\n\t\tvar iterations = 0;\n\t\tcollection.__iterate(function(v, k, c) {\n\t\t\tif (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {\n\t\t\t\titerations++;\n\t\t\t\treturn fn(v, useKeys ? k : iterations - 1, this$1);\n\t\t\t}\n\t\t});\n\t\treturn iterations;\n\t};\n\tskipSequence.__iteratorUncached = function(type, reverse) {\n\t\tvar this$1 = this;\n\t\tif (reverse) {\n\t\t\treturn this.cacheResult().__iterator(type, reverse);\n\t\t}\n\t\tvar iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n\t\tvar skipping = true;\n\t\tvar iterations = 0;\n\t\treturn new Iterator(function() {\n\t\t\tvar step;\n\t\t\tvar k;\n\t\t\tvar v;\n\t\t\tdo {\n\t\t\t\tstep = iterator.next();\n\t\t\t\tif (step.done) {\n\t\t\t\t\tif (useKeys || type === ITERATE_VALUES) {\n\t\t\t\t\t\treturn step;\n\t\t\t\t\t}\n\t\t\t\t\tif (type === ITERATE_KEYS) {\n\t\t\t\t\t\treturn iteratorValue(type, iterations++, undefined, step);\n\t\t\t\t\t}\n\t\t\t\t\treturn iteratorValue(type, iterations++, step.value[1], step);\n\t\t\t\t}\n\t\t\t\tvar entry = step.value;\n\t\t\t\tk = entry[0];\n\t\t\t\tv = entry[1];\n\t\t\t\tskipping && (skipping = predicate.call(context, v, k, this$1));\n\t\t\t} while (skipping);\n\t\t\treturn type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);\n\t\t});\n\t};\n\treturn skipSequence;\n}\nfunction concatFactory(collection, values) {\n\tvar isKeyedCollection = isKeyed(collection);\n\tvar iters = [collection]\n\t\t.concat(values)\n\t\t.map(function(v) {\n\t\t\tif (!isCollection(v)) {\n\t\t\t\tv = isKeyedCollection\n\t\t\t\t\t? keyedSeqFromValue(v)\n\t\t\t\t\t: indexedSeqFromValue(Array.isArray(v) ? v : [v]);\n\t\t\t} else if (isKeyedCollection) {\n\t\t\t\tv = KeyedCollection(v);\n\t\t\t}\n\t\t\treturn v;\n\t\t})\n\t\t.filter(function(v) {\n\t\t\treturn v.size !== 0;\n\t\t});\n\tif (iters.length === 0) {\n\t\treturn collection;\n\t}\n\tif (iters.length === 1) {\n\t\tvar singleton = iters[0];\n\t\tif (\n\t\t\tsingleton === collection ||\n\t\t\t(isKeyedCollection && isKeyed(singleton)) ||\n\t\t\t(isIndexed(collection) && isIndexed(singleton))\n\t\t) {\n\t\t\treturn singleton;\n\t\t}\n\t}\n\tvar concatSeq = new ArraySeq(iters);\n\tif (isKeyedCollection) {\n\t\tconcatSeq = concatSeq.toKeyedSeq();\n\t} else if (!isIndexed(collection)) {\n\t\tconcatSeq = concatSeq.toSetSeq();\n\t}\n\tconcatSeq = concatSeq.flatten(true);\n\tconcatSeq.size = iters.reduce(function(sum, seq) {\n\t\tif (sum !== undefined) {\n\t\t\tvar size = seq.size;\n\t\t\tif (size !== undefined) {\n\t\t\t\treturn sum + size;\n\t\t\t}\n\t\t}\n\t}, 0);\n\treturn concatSeq;\n}\nfunction flattenFactory(collection, depth, useKeys) {\n\tvar flatSequence = makeSequence(collection);\n\tflatSequence.__iterateUncached = function(fn, reverse) {\n\t\tif (reverse) {\n\t\t\treturn this.cacheResult().__iterate(fn, reverse);\n\t\t}\n\t\tvar iterations = 0;\n\t\tvar stopped = false;\n\t\tfunction flatDeep(iter, currentDepth) {\n\t\t\titer.__iterate(function(v, k) {\n\t\t\t\tif ((!depth || currentDepth < depth) && isCollection(v)) {\n\t\t\t\t\tflatDeep(v, currentDepth + 1);\n\t\t\t\t} else {\n\t\t\t\t\titerations++;\n\t\t\t\t\tif (fn(v, useKeys ? k : iterations - 1, flatSequence) === false) {\n\t\t\t\t\t\tstopped = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn !stopped;\n\t\t\t}, reverse);\n\t\t}\n\t\tflatDeep(collection, 0);\n\t\treturn iterations;\n\t};\n\tflatSequence.__iteratorUncached = function(type, reverse) {\n\t\tif (reverse) {\n\t\t\treturn this.cacheResult().__iterator(type, reverse);\n\t\t}\n\t\tvar iterator = collection.__iterator(type, reverse);\n\t\tvar stack = [];\n\t\tvar iterations = 0;\n\t\treturn new Iterator(function() {\n\t\t\twhile (iterator) {\n\t\t\t\tvar step = iterator.next();\n\t\t\t\tif (step.done !== false) {\n\t\t\t\t\titerator = stack.pop();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvar v = step.value;\n\t\t\t\tif (type === ITERATE_ENTRIES) {\n\t\t\t\t\tv = v[1];\n\t\t\t\t}\n\t\t\t\tif ((!depth || stack.length < depth) && isCollection(v)) {\n\t\t\t\t\tstack.push(iterator);\n\t\t\t\t\titerator = v.__iterator(type, reverse);\n\t\t\t\t} else {\n\t\t\t\t\treturn useKeys ? step : iteratorValue(type, iterations++, v, step);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn iteratorDone();\n\t\t});\n\t};\n\treturn flatSequence;\n}\nfunction flatMapFactory(collection, mapper, context) {\n\tvar coerce = collectionClass(collection);\n\treturn collection\n\t\t.toSeq()\n\t\t.map(function(v, k) {\n\t\t\treturn coerce(mapper.call(context, v, k, collection));\n\t\t})\n\t\t.flatten(true);\n}\nfunction interposeFactory(collection, separator) {\n\tvar interposedSequence = makeSequence(collection);\n\tinterposedSequence.size = collection.size && collection.size * 2 - 1;\n\tinterposedSequence.__iterateUncached = function(fn, reverse) {\n\t\tvar this$1 = this;\n\t\tvar iterations = 0;\n\t\tcollection.__iterate(function(v) {\n\t\t\treturn (\n\t\t\t\t(!iterations || fn(separator, iterations++, this$1) !== false) &&\n\t\t\t\tfn(v, iterations++, this$1) !== false\n\t\t\t);\n\t\t}, reverse);\n\t\treturn iterations;\n\t};\n\tinterposedSequence.__iteratorUncached = function(type, reverse) {\n\t\tvar iterator = collection.__iterator(ITERATE_VALUES, reverse);\n\t\tvar iterations = 0;\n\t\tvar step;\n\t\treturn new Iterator(function() {\n\t\t\tif (!step || iterations % 2) {\n\t\t\t\tstep = iterator.next();\n\t\t\t\tif (step.done) {\n\t\t\t\t\treturn step;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn iterations % 2\n\t\t\t\t? iteratorValue(type, iterations++, separator)\n\t\t\t\t: iteratorValue(type, iterations++, step.value, step);\n\t\t});\n\t};\n\treturn interposedSequence;\n}\nfunction sortFactory(collection, comparator, mapper) {\n\tif (!comparator) {\n\t\tcomparator = defaultComparator;\n\t}\n\tvar isKeyedCollection = isKeyed(collection);\n\tvar index = 0;\n\tvar entries = collection\n\t\t.toSeq()\n\t\t.map(function(v, k) {\n\t\t\treturn [k, v, index++, mapper ? mapper(v, k, collection) : v];\n\t\t})\n\t\t.valueSeq()\n\t\t.toArray();\n\tentries\n\t\t.sort(function(a, b) {\n\t\t\treturn comparator(a[3], b[3]) || a[2] - b[2];\n\t\t})\n\t\t.forEach(\n\t\t\tisKeyedCollection\n\t\t\t\t? function(v, i) {\n\t\t\t\t\t\tentries[i].length = 2;\n\t\t\t\t  }\n\t\t\t\t: function(v, i) {\n\t\t\t\t\t\tentries[i] = v[1];\n\t\t\t\t  }\n\t\t);\n\treturn isKeyedCollection\n\t\t? KeyedSeq(entries)\n\t\t: isIndexed(collection)\n\t\t\t? IndexedSeq(entries)\n\t\t\t: SetSeq(entries);\n}\nfunction maxFactory(collection, comparator, mapper) {\n\tif (!comparator) {\n\t\tcomparator = defaultComparator;\n\t}\n\tif (mapper) {\n\t\tvar entry = collection\n\t\t\t.toSeq()\n\t\t\t.map(function(v, k) {\n\t\t\t\treturn [v, mapper(v, k, collection)];\n\t\t\t})\n\t\t\t.reduce(function(a, b) {\n\t\t\t\treturn maxCompare(comparator, a[1], b[1]) ? b : a;\n\t\t\t});\n\t\treturn entry && entry[0];\n\t}\n\treturn collection.reduce(function(a, b) {\n\t\treturn maxCompare(comparator, a, b) ? b : a;\n\t});\n}\nfunction maxCompare(comparator, a, b) {\n\tvar comp = comparator(b, a);\n\treturn (\n\t\t(comp === 0 && b !== a && (b === undefined || b === null || b !== b)) ||\n\t\tcomp > 0\n\t);\n}\nfunction zipWithFactory(keyIter, zipper, iters, zipAll) {\n\tvar zipSequence = makeSequence(keyIter);\n\tvar sizes = new ArraySeq(iters).map(function(i) {\n\t\treturn i.size;\n\t});\n\tzipSequence.size = zipAll ? sizes.max() : sizes.min();\n\tzipSequence.__iterate = function(fn, reverse) {\n\t\tvar this$1 = this;\n\t\tvar iterator = this.__iterator(ITERATE_VALUES, reverse);\n\t\tvar step;\n\t\tvar iterations = 0;\n\t\twhile (!(step = iterator.next()).done) {\n\t\t\tif (fn(step.value, iterations++, this$1) === false) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn iterations;\n\t};\n\tzipSequence.__iteratorUncached = function(type, reverse) {\n\t\tvar iterators = iters.map(function(i) {\n\t\t\treturn (i = Collection(i)), getIterator(reverse ? i.reverse() : i);\n\t\t});\n\t\tvar iterations = 0;\n\t\tvar isDone = false;\n\t\treturn new Iterator(function() {\n\t\t\tvar steps;\n\t\t\tif (!isDone) {\n\t\t\t\tsteps = iterators.map(function(i) {\n\t\t\t\t\treturn i.next();\n\t\t\t\t});\n\t\t\t\tisDone = zipAll\n\t\t\t\t\t? steps.every(function(s) {\n\t\t\t\t\t\t\treturn s.done;\n\t\t\t\t\t  })\n\t\t\t\t\t: steps.some(function(s) {\n\t\t\t\t\t\t\treturn s.done;\n\t\t\t\t\t  });\n\t\t\t}\n\t\t\tif (isDone) {\n\t\t\t\treturn iteratorDone();\n\t\t\t}\n\t\t\treturn iteratorValue(\n\t\t\t\ttype,\n\t\t\t\titerations++,\n\t\t\t\tzipper.apply(\n\t\t\t\t\tnull,\n\t\t\t\t\tsteps.map(function(s) {\n\t\t\t\t\t\treturn s.value;\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t);\n\t\t});\n\t};\n\treturn zipSequence;\n}\n\nfunction reify(iter, seq) {\n\treturn iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);\n}\nfunction validateEntry(entry) {\n\tif (entry !== Object(entry)) {\n\t\tthrow new TypeError('Expected [K, V] tuple: ' + entry);\n\t}\n}\nfunction collectionClass(collection) {\n\treturn isKeyed(collection)\n\t\t? KeyedCollection\n\t\t: isIndexed(collection)\n\t\t\t? IndexedCollection\n\t\t\t: SetCollection;\n}\nfunction makeSequence(collection) {\n\treturn Object.create(\n\t\t(isKeyed(collection)\n\t\t\t? KeyedSeq\n\t\t\t: isIndexed(collection)\n\t\t\t\t? IndexedSeq\n\t\t\t\t: SetSeq\n\t\t).prototype\n\t);\n}\nfunction cacheResultThrough() {\n\tif (this._iter.cacheResult) {\n\t\tthis._iter.cacheResult();\n\t\tthis.size = this._iter.size;\n\t\treturn this;\n\t}\n\treturn Seq.prototype.cacheResult.call(this);\n}\nfunction defaultComparator(a, b) {\n\tif (a === undefined && b === undefined) {\n\t\treturn 0;\n\t}\n\tif (a === undefined) {\n\t\treturn 1;\n\t}\n\tif (b === undefined) {\n\t\treturn -1;\n\t}\n\treturn a > b ? 1 : a < b ? -1 : 0;\n}\nfunction arrCopy(arr, offset) {\n\toffset = offset || 0;\n\tvar len = Math.max(0, arr.length - offset);\n\tvar newArr = new Array(len);\n\tfor (var ii = 0; ii < len; ii++) {\n\t\tnewArr[ii] = arr[ii + offset];\n\t}\n\treturn newArr;\n}\nfunction invariant(condition, error) {\n\tif (!condition) {\n\t\tthrow new Error(error);\n\t}\n}\nfunction assertNotInfinite(size) {\n\tinvariant(\n\t\tsize !== Infinity,\n\t\t'Cannot perform this action with an infinite size.'\n\t);\n}\nfunction coerceKeyPath(keyPath) {\n\tif (isArrayLike(keyPath) && typeof keyPath !== 'string') {\n\t\treturn keyPath;\n\t}\n\tif (isOrdered(keyPath)) {\n\t\treturn keyPath.toArray();\n\t}\n\tthrow new TypeError(\n\t\t'Invalid keyPath: expected Ordered Collection or Array: ' + keyPath\n\t);\n}\nfunction isPlainObj(value) {\n\treturn (\n\t\tvalue && (value.constructor === Object || value.constructor === undefined)\n\t);\n}\n"
						},
						{
							"line": 1704,
							"tags": [],
							"tabs": "",
							"desc": "Returns true if the value is a potentially-persistent data structure, either provided by Immutable.js or a plain Array or Object. ",
							"code": "function isDataStructure(value) {\n\treturn isImmutable(value) || Array.isArray(value) || isPlainObj(value);\n}\n"
						},
						{
							"line": 1711,
							"tags": [],
							"tabs": "",
							"desc": "Converts a value to a string, adding quotes if a string was provided. ",
							"code": "function quoteString(value) {\n\ttry {\n\t\treturn typeof value === 'string' ? JSON.stringify(value) : String(value);\n\t} catch (_ignoreError) {\n\t\treturn JSON.stringify(value);\n\t}\n}\nfunction has(collection, key) {\n\treturn isImmutable(collection)\n\t\t? collection.has(key)\n\t\t: isDataStructure(collection) && hasOwnProperty.call(collection, key);\n}\nfunction get(collection, key, notSetValue) {\n\treturn isImmutable(collection)\n\t\t? collection.get(key, notSetValue)\n\t\t: !has(collection, key)\n\t\t\t? notSetValue\n\t\t\t: typeof collection.get === 'function'\n\t\t\t\t? collection.get(key)\n\t\t\t\t: collection[key];\n}\nfunction shallowCopy(from) {\n\tif (Array.isArray(from)) {\n\t\treturn arrCopy(from);\n\t}\n\tvar to = {};\n\tfor (var key in from) {\n\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\tto[key] = from[key];\n\t\t}\n\t}\n\treturn to;\n}\nfunction remove(collection, key) {\n\tif (!isDataStructure(collection)) {\n\t\tthrow new TypeError(\n\t\t\t'Cannot update non-data-structure value: ' + collection\n\t\t);\n\t}\n\tif (isImmutable(collection)) {\n\t\tif (!collection.remove) {\n\t\t\tthrow new TypeError(\n\t\t\t\t'Cannot update immutable value without .remove() method: ' + collection\n\t\t\t);\n\t\t}\n\t\treturn collection.remove(key);\n\t}\n\tif (!hasOwnProperty.call(collection, key)) {\n\t\treturn collection;\n\t}\n\tvar collectionCopy = shallowCopy(collection);\n\tif (Array.isArray(collectionCopy)) {\n\t\tcollectionCopy.splice(key, 1);\n\t} else {\n\t\tdelete collectionCopy[key];\n\t}\n\treturn collectionCopy;\n}\nfunction set(collection, key, value) {\n\tif (!isDataStructure(collection)) {\n\t\tthrow new TypeError(\n\t\t\t'Cannot update non-data-structure value: ' + collection\n\t\t);\n\t}\n\tif (isImmutable(collection)) {\n\t\tif (!collection.set) {\n\t\t\tthrow new TypeError(\n\t\t\t\t'Cannot update immutable value without .set() method: ' + collection\n\t\t\t);\n\t\t}\n\t\treturn collection.set(key, value);\n\t}\n\tif (hasOwnProperty.call(collection, key) && value === collection[key]) {\n\t\treturn collection;\n\t}\n\tvar collectionCopy = shallowCopy(collection);\n\tcollectionCopy[key] = value;\n\treturn collectionCopy;\n}\nfunction updateIn(collection, keyPath, notSetValue, updater) {\n\tif (!updater) {\n\t\tupdater = notSetValue;\n\t\tnotSetValue = undefined;\n\t}\n\tvar updatedValue = updateInDeeply(\n\t\tisImmutable(collection),\n\t\tcollection,\n\t\tcoerceKeyPath(keyPath),\n\t\t0,\n\t\tnotSetValue,\n\t\tupdater\n\t);\n\treturn updatedValue === NOT_SET ? notSetValue : updatedValue;\n}\nfunction updateInDeeply(\n\tinImmutable,\n\texisting,\n\tkeyPath,\n\ti,\n\tnotSetValue,\n\tupdater\n) {\n\tvar wasNotSet = existing === NOT_SET;\n\tif (i === keyPath.length) {\n\t\tvar existingValue = wasNotSet ? notSetValue : existing;\n\t\tvar newValue = updater(existingValue);\n\t\treturn newValue === existingValue ? existing : newValue;\n\t}\n\tif (!wasNotSet && !isDataStructure(existing)) {\n\t\tthrow new TypeError(\n\t\t\t'Cannot update within non-data-structure value in path [' +\n\t\t\t\tkeyPath.slice(0, i).map(quoteString) +\n\t\t\t\t']: ' +\n\t\t\t\texisting\n\t\t);\n\t}\n\tvar key = keyPath[i];\n\tvar nextExisting = wasNotSet ? NOT_SET : get(existing, key, NOT_SET);\n\tvar nextUpdated = updateInDeeply(\n\t\tnextExisting === NOT_SET ? inImmutable : isImmutable(nextExisting),\n\t\tnextExisting,\n\t\tkeyPath,\n\t\ti + 1,\n\t\tnotSetValue,\n\t\tupdater\n\t);\n\treturn nextUpdated === nextExisting\n\t\t? existing\n\t\t: nextUpdated === NOT_SET\n\t\t\t? remove(existing, key)\n\t\t\t: set(\n\t\t\t\t\twasNotSet ? (inImmutable ? emptyMap() : {}) : existing,\n\t\t\t\t\tkey,\n\t\t\t\t\tnextUpdated\n\t\t\t  );\n}\nfunction setIn$1(collection, keyPath, value) {\n\treturn updateIn(collection, keyPath, NOT_SET, function() {\n\t\treturn value;\n\t});\n}\nfunction setIn$$1(keyPath, v) {\n\treturn setIn$1(this, keyPath, v);\n}\nfunction removeIn(collection, keyPath) {\n\treturn updateIn(collection, keyPath, function() {\n\t\treturn NOT_SET;\n\t});\n}\nfunction deleteIn(keyPath) {\n\treturn removeIn(this, keyPath);\n}\nfunction update$1(collection, key, notSetValue, updater) {\n\treturn updateIn(collection, [key], notSetValue, updater);\n}\nfunction update$$1(key, notSetValue, updater) {\n\treturn arguments.length === 1\n\t\t? key(this)\n\t\t: update$1(this, key, notSetValue, updater);\n}\nfunction updateIn$1(keyPath, notSetValue, updater) {\n\treturn updateIn(this, keyPath, notSetValue, updater);\n}\nfunction merge() {\n\tvar iters = [],\n\t\tlen = arguments.length;\n\twhile (len--) iters[len] = arguments[len];\n\treturn mergeIntoKeyedWith(this, iters);\n}\nfunction mergeWith(merger) {\n\tvar iters = [],\n\t\tlen = arguments.length - 1;\n\twhile (len-- > 0) iters[len] = arguments[len + 1];\n\treturn mergeIntoKeyedWith(this, iters, merger);\n}\nfunction mergeIntoKeyedWith(collection, collections, merger) {\n\tvar iters = [];\n\tfor (var ii = 0; ii < collections.length; ii++) {\n\t\tvar collection$1 = KeyedCollection(collections[ii]);\n\t\tif (collection$1.size !== 0) {\n\t\t\titers.push(collection$1);\n\t\t}\n\t}\n\tif (iters.length === 0) {\n\t\treturn collection;\n\t}\n\tif (collection.size === 0 && !collection.__ownerID && iters.length === 1) {\n\t\treturn collection.constructor(iters[0]);\n\t}\n\treturn collection.withMutations(function(collection) {\n\t\tvar mergeIntoCollection = merger\n\t\t\t? function(value, key) {\n\t\t\t\t\tupdate$1(collection, key, NOT_SET, function(oldVal) {\n\t\t\t\t\t\treturn oldVal === NOT_SET ? value : merger(oldVal, value, key);\n\t\t\t\t\t});\n\t\t\t  }\n\t\t\t: function(value, key) {\n\t\t\t\t\tcollection.set(key, value);\n\t\t\t  };\n\t\tfor (var ii = 0; ii < iters.length; ii++) {\n\t\t\titers[ii].forEach(mergeIntoCollection);\n\t\t}\n\t});\n}\nfunction merge$1(collection) {\n\tvar sources = [],\n\t\tlen = arguments.length - 1;\n\twhile (len-- > 0) sources[len] = arguments[len + 1];\n\treturn mergeWithSources(collection, sources);\n}\nfunction mergeWith$1(merger, collection) {\n\tvar sources = [],\n\t\tlen = arguments.length - 2;\n\twhile (len-- > 0) sources[len] = arguments[len + 2];\n\treturn mergeWithSources(collection, sources, merger);\n}\nfunction mergeDeep$1(collection) {\n\tvar sources = [],\n\t\tlen = arguments.length - 1;\n\twhile (len-- > 0) sources[len] = arguments[len + 1];\n\treturn mergeDeepWithSources(collection, sources);\n}\nfunction mergeDeepWith$1(merger, collection) {\n\tvar sources = [],\n\t\tlen = arguments.length - 2;\n\twhile (len-- > 0) sources[len] = arguments[len + 2];\n\treturn mergeDeepWithSources(collection, sources, merger);\n}\nfunction mergeDeepWithSources(collection, sources, merger) {\n\treturn mergeWithSources(collection, sources, deepMergerWith(merger));\n}\nfunction mergeWithSources(collection, sources, merger) {\n\tif (!isDataStructure(collection)) {\n\t\tthrow new TypeError(\n\t\t\t'Cannot merge into non-data-structure value: ' + collection\n\t\t);\n\t}\n\tif (isImmutable(collection)) {\n\t\treturn collection.mergeWith\n\t\t\t? collection.mergeWith.apply(collection, [merger].concat(sources))\n\t\t\t: collection.concat.apply(collection, sources);\n\t}\n\tvar isArray = Array.isArray(collection);\n\tvar merged = collection;\n\tvar Collection$$1 = isArray ? IndexedCollection : KeyedCollection;\n\tvar mergeItem = isArray\n\t\t? function(value) {\n\t\t\t\tif (merged === collection) {\n\t\t\t\t\tmerged = shallowCopy(merged);\n\t\t\t\t}\n\t\t\t\tmerged.push(value);\n\t\t  }\n\t\t: function(value, key) {\n\t\t\t\tvar hasVal = hasOwnProperty.call(merged, key);\n\t\t\t\tvar nextVal =\n\t\t\t\t\thasVal && merger ? merger(merged[key], value, key) : value;\n\t\t\t\tif (!hasVal || nextVal !== merged[key]) {\n\t\t\t\t\tif (merged === collection) {\n\t\t\t\t\t\tmerged = shallowCopy(merged);\n\t\t\t\t\t}\n\t\t\t\t\tmerged[key] = nextVal;\n\t\t\t\t}\n\t\t  };\n\tfor (var i = 0; i < sources.length; i++) {\n\t\tCollection$$1(sources[i]).forEach(mergeItem);\n\t}\n\treturn merged;\n}\nfunction deepMergerWith(merger) {\n\tfunction deepMerger(oldValue, newValue, key) {\n\t\treturn isDataStructure(oldValue) && isDataStructure(newValue)\n\t\t\t? mergeWithSources(oldValue, [newValue], deepMerger)\n\t\t\t: merger\n\t\t\t\t? merger(oldValue, newValue, key)\n\t\t\t\t: newValue;\n\t}\n\treturn deepMerger;\n}\nfunction mergeDeep() {\n\tvar iters = [],\n\t\tlen = arguments.length;\n\twhile (len--) iters[len] = arguments[len];\n\treturn mergeDeepWithSources(this, iters);\n}\nfunction mergeDeepWith(merger) {\n\tvar iters = [],\n\t\tlen = arguments.length - 1;\n\twhile (len-- > 0) iters[len] = arguments[len + 1];\n\treturn mergeDeepWithSources(this, iters, merger);\n}\nfunction mergeIn(keyPath) {\n\tvar iters = [],\n\t\tlen = arguments.length - 1;\n\twhile (len-- > 0) iters[len] = arguments[len + 1];\n\treturn updateIn(this, keyPath, emptyMap(), function(m) {\n\t\treturn mergeWithSources(m, iters);\n\t});\n}\nfunction mergeDeepIn(keyPath) {\n\tvar iters = [],\n\t\tlen = arguments.length - 1;\n\twhile (len-- > 0) iters[len] = arguments[len + 1];\n\treturn updateIn(this, keyPath, emptyMap(), function(m) {\n\t\treturn mergeDeepWithSources(m, iters);\n\t});\n}\nfunction withMutations(fn) {\n\tvar mutable = this.asMutable();\n\tfn(mutable);\n\treturn mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;\n}\nfunction asMutable() {\n\treturn this.__ownerID ? this : this.__ensureOwner(new OwnerID());\n}\nfunction asImmutable() {\n\treturn this.__ensureOwner();\n}\nfunction wasAltered() {\n\treturn this.__altered;\n}\nvar Map = (function(KeyedCollection$$1) {\n\tfunction Map(value) {\n\t\treturn value === null || value === undefined\n\t\t\t? emptyMap()\n\t\t\t: isMap(value) && !isOrdered(value)\n\t\t\t\t? value\n\t\t\t\t: emptyMap().withMutations(function(map) {\n\t\t\t\t\t\tvar iter = KeyedCollection$$1(value);\n\t\t\t\t\t\tassertNotInfinite(iter.size);\n\t\t\t\t\t\titer.forEach(function(v, k) {\n\t\t\t\t\t\t\treturn map.set(k, v);\n\t\t\t\t\t\t});\n\t\t\t\t  });\n\t}\n\tif (KeyedCollection$$1) Map.__proto__ = KeyedCollection$$1;\n\tMap.prototype = Object.create(\n\t\tKeyedCollection$$1 && KeyedCollection$$1.prototype\n\t);\n\tMap.prototype.constructor = Map;\n\tMap.of = function of() {\n\t\tvar keyValues = [],\n\t\t\tlen = arguments.length;\n\t\twhile (len--) keyValues[len] = arguments[len];\n\t\treturn emptyMap().withMutations(function(map) {\n\t\t\tfor (var i = 0; i < keyValues.length; i += 2) {\n\t\t\t\tif (i + 1 >= keyValues.length) {\n\t\t\t\t\tthrow new Error('Missing value for key: ' + keyValues[i]);\n\t\t\t\t}\n\t\t\t\tmap.set(keyValues[i], keyValues[i + 1]);\n\t\t\t}\n\t\t});\n\t};\n\tMap.prototype.toString = function toString() {\n\t\treturn this.__toString('Map {', '}');\n\t};\n\t\n\tMap.prototype.get = function get(k, notSetValue) {\n\t\treturn this._root\n\t\t\t? this._root.get(0, undefined, k, notSetValue)\n\t\t\t: notSetValue;\n\t};\n\t\n\tMap.prototype.set = function set(k, v) {\n\t\treturn updateMap(this, k, v);\n\t};\n\tMap.prototype.remove = function remove(k) {\n\t\treturn updateMap(this, k, NOT_SET);\n\t};\n\tMap.prototype.deleteAll = function deleteAll(keys) {\n\t\tvar collection = Collection(keys);\n\t\tif (collection.size === 0) {\n\t\t\treturn this;\n\t\t}\n\t\treturn this.withMutations(function(map) {\n\t\t\tcollection.forEach(function(key) {\n\t\t\t\treturn map.remove(key);\n\t\t\t});\n\t\t});\n\t};\n\tMap.prototype.clear = function clear() {\n\t\tif (this.size === 0) {\n\t\t\treturn this;\n\t\t}\n\t\tif (this.__ownerID) {\n\t\t\tthis.size = 0;\n\t\t\tthis._root = null;\n\t\t\tthis.__hash = undefined;\n\t\t\tthis.__altered = true;\n\t\t\treturn this;\n\t\t}\n\t\treturn emptyMap();\n\t};\n\t\n\tMap.prototype.sort = function sort(comparator) {\n\t\treturn OrderedMap(sortFactory(this, comparator));\n\t};\n\tMap.prototype.sortBy = function sortBy(mapper, comparator) {\n\t\treturn OrderedMap(sortFactory(this, comparator, mapper));\n\t};\n\t\n\tMap.prototype.__iterator = function __iterator(type, reverse) {\n\t\treturn new MapIterator(this, type, reverse);\n\t};\n\tMap.prototype.__iterate = function __iterate(fn, reverse) {\n\t\tvar this$1 = this;\n\t\tvar iterations = 0;\n\t\tthis._root &&\n\t\t\tthis._root.iterate(function(entry) {\n\t\t\t\titerations++;\n\t\t\t\treturn fn(entry[1], entry[0], this$1);\n\t\t\t}, reverse);\n\t\treturn iterations;\n\t};\n\tMap.prototype.__ensureOwner = function __ensureOwner(ownerID) {\n\t\tif (ownerID === this.__ownerID) {\n\t\t\treturn this;\n\t\t}\n\t\tif (!ownerID) {\n\t\t\tif (this.size === 0) {\n\t\t\t\treturn emptyMap();\n\t\t\t}\n\t\t\tthis.__ownerID = ownerID;\n\t\t\tthis.__altered = false;\n\t\t\treturn this;\n\t\t}\n\t\treturn makeMap(this.size, this._root, ownerID, this.__hash);\n\t};\n\treturn Map;\n})(KeyedCollection);\nfunction isMap(maybeMap) {\n\treturn !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);\n}\nMap.isMap = isMap;\nvar IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';\nvar MapPrototype = Map.prototype;\nMapPrototype[IS_MAP_SENTINEL] = true;\nMapPrototype[DELETE] = MapPrototype.remove;\nMapPrototype.removeAll = MapPrototype.deleteAll;\nMapPrototype.concat = MapPrototype.merge;\nMapPrototype.setIn = setIn$$1;\nMapPrototype.removeIn = MapPrototype.deleteIn = deleteIn;\nMapPrototype.update = update$$1;\nMapPrototype.updateIn = updateIn$1;\nMapPrototype.merge = merge;\nMapPrototype.mergeWith = mergeWith;\nMapPrototype.mergeDeep = mergeDeep;\nMapPrototype.mergeDeepWith = mergeDeepWith;\nMapPrototype.mergeIn = mergeIn;\nMapPrototype.mergeDeepIn = mergeDeepIn;\nMapPrototype.withMutations = withMutations;\nMapPrototype.wasAltered = wasAltered;\nMapPrototype.asImmutable = asImmutable;\nMapPrototype['@@transducer/init'] = MapPrototype.asMutable = asMutable;\nMapPrototype['@@transducer/step'] = function(result, arr) {\n\treturn result.set(arr[0], arr[1]);\n};\nMapPrototype['@@transducer/result'] = function(obj) {\n\treturn obj.asImmutable();\n};\n\nvar ArrayMapNode = function ArrayMapNode(ownerID, entries) {\n\tthis.ownerID = ownerID;\n\tthis.entries = entries;\n};\nArrayMapNode.prototype.get = function get(shift, keyHash, key, notSetValue) {\n\tvar entries = this.entries;\n\tfor (var ii = 0, len = entries.length; ii < len; ii++) {\n\t\tif (is(key, entries[ii][0])) {\n\t\t\treturn entries[ii][1];\n\t\t}\n\t}\n\treturn notSetValue;\n};\nArrayMapNode.prototype.update = function update$$1(\n\townerID,\n\tshift,\n\tkeyHash,\n\tkey,\n\tvalue,\n\tdidChangeSize,\n\tdidAlter\n) {\n\tvar removed = value === NOT_SET;\n\tvar entries = this.entries;\n\tvar idx = 0;\n\tvar len = entries.length;\n\tfor (; idx < len; idx++) {\n\t\tif (is(key, entries[idx][0])) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tvar exists = idx < len;\n\tif (exists ? entries[idx][1] === value : removed) {\n\t\treturn this;\n\t}\n\tSetRef(didAlter);\n\t(removed || !exists) && SetRef(didChangeSize);\n\tif (removed && entries.length === 1) {\n\t\treturn; \n\t}\n\tif (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n\t\treturn createNodes(ownerID, entries, key, value);\n\t}\n\tvar isEditable = ownerID && ownerID === this.ownerID;\n\tvar newEntries = isEditable ? entries : arrCopy(entries);\n\tif (exists) {\n\t\tif (removed) {\n\t\t\tidx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n\t\t} else {\n\t\t\tnewEntries[idx] = [key, value];\n\t\t}\n\t} else {\n\t\tnewEntries.push([key, value]);\n\t}\n\tif (isEditable) {\n\t\tthis.entries = newEntries;\n\t\treturn this;\n\t}\n\treturn new ArrayMapNode(ownerID, newEntries);\n};\nvar BitmapIndexedNode = function BitmapIndexedNode(ownerID, bitmap, nodes) {\n\tthis.ownerID = ownerID;\n\tthis.bitmap = bitmap;\n\tthis.nodes = nodes;\n};\nBitmapIndexedNode.prototype.get = function get(\n\tshift,\n\tkeyHash,\n\tkey,\n\tnotSetValue\n) {\n\tif (keyHash === undefined) {\n\t\tkeyHash = hash(key);\n\t}\n\tvar bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);\n\tvar bitmap = this.bitmap;\n\treturn (bitmap & bit) === 0\n\t\t? notSetValue\n\t\t: this.nodes[popCount(bitmap & (bit - 1))].get(\n\t\t\t\tshift + SHIFT,\n\t\t\t\tkeyHash,\n\t\t\t\tkey,\n\t\t\t\tnotSetValue\n\t\t  );\n};\nBitmapIndexedNode.prototype.update = function update$$1(\n\townerID,\n\tshift,\n\tkeyHash,\n\tkey,\n\tvalue,\n\tdidChangeSize,\n\tdidAlter\n) {\n\tif (keyHash === undefined) {\n\t\tkeyHash = hash(key);\n\t}\n\tvar keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\tvar bit = 1 << keyHashFrag;\n\tvar bitmap = this.bitmap;\n\tvar exists = (bitmap & bit) !== 0;\n\tif (!exists && value === NOT_SET) {\n\t\treturn this;\n\t}\n\tvar idx = popCount(bitmap & (bit - 1));\n\tvar nodes = this.nodes;\n\tvar node = exists ? nodes[idx] : undefined;\n\tvar newNode = updateNode(\n\t\tnode,\n\t\townerID,\n\t\tshift + SHIFT,\n\t\tkeyHash,\n\t\tkey,\n\t\tvalue,\n\t\tdidChangeSize,\n\t\tdidAlter\n\t);\n\tif (newNode === node) {\n\t\treturn this;\n\t}\n\tif (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n\t\treturn expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);\n\t}\n\tif (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {\n\t\treturn nodes[idx ^ 1];\n\t}\n\tif (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n\t\treturn newNode;\n\t}\n\tvar isEditable = ownerID && ownerID === this.ownerID;\n\tvar newBitmap = exists ? (newNode ? bitmap : bitmap ^ bit) : bitmap | bit;\n\tvar newNodes = exists\n\t\t? newNode\n\t\t\t? setAt(nodes, idx, newNode, isEditable)\n\t\t\t: spliceOut(nodes, idx, isEditable)\n\t\t: spliceIn(nodes, idx, newNode, isEditable);\n\tif (isEditable) {\n\t\tthis.bitmap = newBitmap;\n\t\tthis.nodes = newNodes;\n\t\treturn this;\n\t}\n\treturn new BitmapIndexedNode(ownerID, newBitmap, newNodes);\n};\nvar HashArrayMapNode = function HashArrayMapNode(ownerID, count, nodes) {\n\tthis.ownerID = ownerID;\n\tthis.count = count;\n\tthis.nodes = nodes;\n};\nHashArrayMapNode.prototype.get = function get(\n\tshift,\n\tkeyHash,\n\tkey,\n\tnotSetValue\n) {\n\tif (keyHash === undefined) {\n\t\tkeyHash = hash(key);\n\t}\n\tvar idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\tvar node = this.nodes[idx];\n\treturn node\n\t\t? node.get(shift + SHIFT, keyHash, key, notSetValue)\n\t\t: notSetValue;\n};\nHashArrayMapNode.prototype.update = function update$$1(\n\townerID,\n\tshift,\n\tkeyHash,\n\tkey,\n\tvalue,\n\tdidChangeSize,\n\tdidAlter\n) {\n\tif (keyHash === undefined) {\n\t\tkeyHash = hash(key);\n\t}\n\tvar idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\tvar removed = value === NOT_SET;\n\tvar nodes = this.nodes;\n\tvar node = nodes[idx];\n\tif (removed && !node) {\n\t\treturn this;\n\t}\n\tvar newNode = updateNode(\n\t\tnode,\n\t\townerID,\n\t\tshift + SHIFT,\n\t\tkeyHash,\n\t\tkey,\n\t\tvalue,\n\t\tdidChangeSize,\n\t\tdidAlter\n\t);\n\tif (newNode === node) {\n\t\treturn this;\n\t}\n\tvar newCount = this.count;\n\tif (!node) {\n\t\tnewCount++;\n\t} else if (!newNode) {\n\t\tnewCount--;\n\t\tif (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n\t\t\treturn packNodes(ownerID, nodes, newCount, idx);\n\t\t}\n\t}\n\tvar isEditable = ownerID && ownerID === this.ownerID;\n\tvar newNodes = setAt(nodes, idx, newNode, isEditable);\n\tif (isEditable) {\n\t\tthis.count = newCount;\n\t\tthis.nodes = newNodes;\n\t\treturn this;\n\t}\n\treturn new HashArrayMapNode(ownerID, newCount, newNodes);\n};\nvar HashCollisionNode = function HashCollisionNode(ownerID, keyHash, entries) {\n\tthis.ownerID = ownerID;\n\tthis.keyHash = keyHash;\n\tthis.entries = entries;\n};\nHashCollisionNode.prototype.get = function get(\n\tshift,\n\tkeyHash,\n\tkey,\n\tnotSetValue\n) {\n\tvar entries = this.entries;\n\tfor (var ii = 0, len = entries.length; ii < len; ii++) {\n\t\tif (is(key, entries[ii][0])) {\n\t\t\treturn entries[ii][1];\n\t\t}\n\t}\n\treturn notSetValue;\n};\nHashCollisionNode.prototype.update = function update$$1(\n\townerID,\n\tshift,\n\tkeyHash,\n\tkey,\n\tvalue,\n\tdidChangeSize,\n\tdidAlter\n) {\n\tif (keyHash === undefined) {\n\t\tkeyHash = hash(key);\n\t}\n\tvar removed = value === NOT_SET;\n\tif (keyHash !== this.keyHash) {\n\t\tif (removed) {\n\t\t\treturn this;\n\t\t}\n\t\tSetRef(didAlter);\n\t\tSetRef(didChangeSize);\n\t\treturn mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);\n\t}\n\tvar entries = this.entries;\n\tvar idx = 0;\n\tvar len = entries.length;\n\tfor (; idx < len; idx++) {\n\t\tif (is(key, entries[idx][0])) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tvar exists = idx < len;\n\tif (exists ? entries[idx][1] === value : removed) {\n\t\treturn this;\n\t}\n\tSetRef(didAlter);\n\t(removed || !exists) && SetRef(didChangeSize);\n\tif (removed && len === 2) {\n\t\treturn new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);\n\t}\n\tvar isEditable = ownerID && ownerID === this.ownerID;\n\tvar newEntries = isEditable ? entries : arrCopy(entries);\n\tif (exists) {\n\t\tif (removed) {\n\t\t\tidx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n\t\t} else {\n\t\t\tnewEntries[idx] = [key, value];\n\t\t}\n\t} else {\n\t\tnewEntries.push([key, value]);\n\t}\n\tif (isEditable) {\n\t\tthis.entries = newEntries;\n\t\treturn this;\n\t}\n\treturn new HashCollisionNode(ownerID, this.keyHash, newEntries);\n};\nvar ValueNode = function ValueNode(ownerID, keyHash, entry) {\n\tthis.ownerID = ownerID;\n\tthis.keyHash = keyHash;\n\tthis.entry = entry;\n};\nValueNode.prototype.get = function get(shift, keyHash, key, notSetValue) {\n\treturn is(key, this.entry[0]) ? this.entry[1] : notSetValue;\n};\nValueNode.prototype.update = function update$$1(\n\townerID,\n\tshift,\n\tkeyHash,\n\tkey,\n\tvalue,\n\tdidChangeSize,\n\tdidAlter\n) {\n\tvar removed = value === NOT_SET;\n\tvar keyMatch = is(key, this.entry[0]);\n\tif (keyMatch ? value === this.entry[1] : removed) {\n\t\treturn this;\n\t}\n\tSetRef(didAlter);\n\tif (removed) {\n\t\tSetRef(didChangeSize);\n\t\treturn; \n\t}\n\tif (keyMatch) {\n\t\tif (ownerID && ownerID === this.ownerID) {\n\t\t\tthis.entry[1] = value;\n\t\t\treturn this;\n\t\t}\n\t\treturn new ValueNode(ownerID, this.keyHash, [key, value]);\n\t}\n\tSetRef(didChangeSize);\n\treturn mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);\n};\n\nArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function(\n\tfn,\n\treverse\n) {\n\tvar entries = this.entries;\n\tfor (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {\n\t\tif (fn(entries[reverse ? maxIndex - ii : ii]) === false) {\n\t\t\treturn false;\n\t\t}\n\t}\n};\nBitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function(\n\tfn,\n\treverse\n) {\n\tvar nodes = this.nodes;\n\tfor (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {\n\t\tvar node = nodes[reverse ? maxIndex - ii : ii];\n\t\tif (node && node.iterate(fn, reverse) === false) {\n\t\t\treturn false;\n\t\t}\n\t}\n};\nValueNode.prototype.iterate = function(fn, reverse) {\n\treturn fn(this.entry);\n};\nvar MapIterator = (function(Iterator$$1) {\n\tfunction MapIterator(map, type, reverse) {\n\t\tthis._type = type;\n\t\tthis._reverse = reverse;\n\t\tthis._stack = map._root && mapIteratorFrame(map._root);\n\t}\n\tif (Iterator$$1) MapIterator.__proto__ = Iterator$$1;\n\tMapIterator.prototype = Object.create(Iterator$$1 && Iterator$$1.prototype);\n\tMapIterator.prototype.constructor = MapIterator;\n\tMapIterator.prototype.next = function next() {\n\t\tvar this$1 = this;\n\t\tvar type = this._type;\n\t\tvar stack = this._stack;\n\t\twhile (stack) {\n\t\t\tvar node = stack.node;\n\t\t\tvar index = stack.index++;\n\t\t\tvar maxIndex = void 0;\n\t\t\tif (node.entry) {\n\t\t\t\tif (index === 0) {\n\t\t\t\t\treturn mapIteratorValue(type, node.entry);\n\t\t\t\t}\n\t\t\t} else if (node.entries) {\n\t\t\t\tmaxIndex = node.entries.length - 1;\n\t\t\t\tif (index <= maxIndex) {\n\t\t\t\t\treturn mapIteratorValue(\n\t\t\t\t\t\ttype,\n\t\t\t\t\t\tnode.entries[this$1._reverse ? maxIndex - index : index]\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmaxIndex = node.nodes.length - 1;\n\t\t\t\tif (index <= maxIndex) {\n\t\t\t\t\tvar subNode = node.nodes[this$1._reverse ? maxIndex - index : index];\n\t\t\t\t\tif (subNode) {\n\t\t\t\t\t\tif (subNode.entry) {\n\t\t\t\t\t\t\treturn mapIteratorValue(type, subNode.entry);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstack = this$1._stack = mapIteratorFrame(subNode, stack);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstack = this$1._stack = this$1._stack.__prev;\n\t\t}\n\t\treturn iteratorDone();\n\t};\n\treturn MapIterator;\n})(Iterator);\nfunction mapIteratorValue(type, entry) {\n\treturn iteratorValue(type, entry[0], entry[1]);\n}\nfunction mapIteratorFrame(node, prev) {\n\treturn {\n\t\tnode: node,\n\t\tindex: 0,\n\t\t__prev: prev\n\t};\n}\nfunction makeMap(size, root, ownerID, hash$$1) {\n\tvar map = Object.create(MapPrototype);\n\tmap.size = size;\n\tmap._root = root;\n\tmap.__ownerID = ownerID;\n\tmap.__hash = hash$$1;\n\tmap.__altered = false;\n\treturn map;\n}\nvar EMPTY_MAP;\nfunction emptyMap() {\n\treturn EMPTY_MAP || (EMPTY_MAP = makeMap(0));\n}\nfunction updateMap(map, k, v) {\n\tvar newRoot;\n\tvar newSize;\n\tif (!map._root) {\n\t\tif (v === NOT_SET) {\n\t\t\treturn map;\n\t\t}\n\t\tnewSize = 1;\n\t\tnewRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);\n\t} else {\n\t\tvar didChangeSize = MakeRef(CHANGE_LENGTH);\n\t\tvar didAlter = MakeRef(DID_ALTER);\n\t\tnewRoot = updateNode(\n\t\t\tmap._root,\n\t\t\tmap.__ownerID,\n\t\t\t0,\n\t\t\tundefined,\n\t\t\tk,\n\t\t\tv,\n\t\t\tdidChangeSize,\n\t\t\tdidAlter\n\t\t);\n\t\tif (!didAlter.value) {\n\t\t\treturn map;\n\t\t}\n\t\tnewSize = map.size + (didChangeSize.value ? (v === NOT_SET ? -1 : 1) : 0);\n\t}\n\tif (map.__ownerID) {\n\t\tmap.size = newSize;\n\t\tmap._root = newRoot;\n\t\tmap.__hash = undefined;\n\t\tmap.__altered = true;\n\t\treturn map;\n\t}\n\treturn newRoot ? makeMap(newSize, newRoot) : emptyMap();\n}\nfunction updateNode(\n\tnode,\n\townerID,\n\tshift,\n\tkeyHash,\n\tkey,\n\tvalue,\n\tdidChangeSize,\n\tdidAlter\n) {\n\tif (!node) {\n\t\tif (value === NOT_SET) {\n\t\t\treturn node;\n\t\t}\n\t\tSetRef(didAlter);\n\t\tSetRef(didChangeSize);\n\t\treturn new ValueNode(ownerID, keyHash, [key, value]);\n\t}\n\treturn node.update(\n\t\townerID,\n\t\tshift,\n\t\tkeyHash,\n\t\tkey,\n\t\tvalue,\n\t\tdidChangeSize,\n\t\tdidAlter\n\t);\n}\nfunction isLeafNode(node) {\n\treturn (\n\t\tnode.constructor === ValueNode || node.constructor === HashCollisionNode\n\t);\n}\nfunction mergeIntoNode(node, ownerID, shift, keyHash, entry) {\n\tif (node.keyHash === keyHash) {\n\t\treturn new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);\n\t}\n\tvar idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;\n\tvar idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\tvar newNode;\n\tvar nodes =\n\t\tidx1 === idx2\n\t\t\t? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)]\n\t\t\t: ((newNode = new ValueNode(ownerID, keyHash, entry)),\n\t\t\t  idx1 < idx2 ? [node, newNode] : [newNode, node]);\n\treturn new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);\n}\nfunction createNodes(ownerID, entries, key, value) {\n\tif (!ownerID) {\n\t\townerID = new OwnerID();\n\t}\n\tvar node = new ValueNode(ownerID, hash(key), [key, value]);\n\tfor (var ii = 0; ii < entries.length; ii++) {\n\t\tvar entry = entries[ii];\n\t\tnode = node.update(ownerID, 0, undefined, entry[0], entry[1]);\n\t}\n\treturn node;\n}\nfunction packNodes(ownerID, nodes, count, excluding) {\n\tvar bitmap = 0;\n\tvar packedII = 0;\n\tvar packedNodes = new Array(count);\n\tfor (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {\n\t\tvar node = nodes[ii];\n\t\tif (node !== undefined && ii !== excluding) {\n\t\t\tbitmap |= bit;\n\t\t\tpackedNodes[packedII++] = node;\n\t\t}\n\t}\n\treturn new BitmapIndexedNode(ownerID, bitmap, packedNodes);\n}\nfunction expandNodes(ownerID, nodes, bitmap, including, node) {\n\tvar count = 0;\n\tvar expandedNodes = new Array(SIZE);\n\tfor (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {\n\t\texpandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;\n\t}\n\texpandedNodes[including] = node;\n\treturn new HashArrayMapNode(ownerID, count + 1, expandedNodes);\n}\nfunction popCount(x) {\n\tx -= (x >> 1) & 0x55555555;\n\tx = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n\tx = (x + (x >> 4)) & 0x0f0f0f0f;\n\tx += x >> 8;\n\tx += x >> 16;\n\treturn x & 0x7f;\n}\nfunction setAt(array, idx, val, canEdit) {\n\tvar newArray = canEdit ? array : arrCopy(array);\n\tnewArray[idx] = val;\n\treturn newArray;\n}\nfunction spliceIn(array, idx, val, canEdit) {\n\tvar newLen = array.length + 1;\n\tif (canEdit && idx + 1 === newLen) {\n\t\tarray[idx] = val;\n\t\treturn array;\n\t}\n\tvar newArray = new Array(newLen);\n\tvar after = 0;\n\tfor (var ii = 0; ii < newLen; ii++) {\n\t\tif (ii === idx) {\n\t\t\tnewArray[ii] = val;\n\t\t\tafter = -1;\n\t\t} else {\n\t\t\tnewArray[ii] = array[ii + after];\n\t\t}\n\t}\n\treturn newArray;\n}\nfunction spliceOut(array, idx, canEdit) {\n\tvar newLen = array.length - 1;\n\tif (canEdit && idx === newLen) {\n\t\tarray.pop();\n\t\treturn array;\n\t}\n\tvar newArray = new Array(newLen);\n\tvar after = 0;\n\tfor (var ii = 0; ii < newLen; ii++) {\n\t\tif (ii === idx) {\n\t\t\tafter = 1;\n\t\t}\n\t\tnewArray[ii] = array[ii + after];\n\t}\n\treturn newArray;\n}\nvar MAX_ARRAY_MAP_SIZE = SIZE / 4;\nvar MAX_BITMAP_INDEXED_SIZE = SIZE / 2;\nvar MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;\nvar List = (function(IndexedCollection$$1) {\n\tfunction List(value) {\n\t\tvar empty = emptyList();\n\t\tif (value === null || value === undefined) {\n\t\t\treturn empty;\n\t\t}\n\t\tif (isList(value)) {\n\t\t\treturn value;\n\t\t}\n\t\tvar iter = IndexedCollection$$1(value);\n\t\tvar size = iter.size;\n\t\tif (size === 0) {\n\t\t\treturn empty;\n\t\t}\n\t\tassertNotInfinite(size);\n\t\tif (size > 0 && size < SIZE) {\n\t\t\treturn makeList(0, size, SHIFT, null, new VNode(iter.toArray()));\n\t\t}\n\t\treturn empty.withMutations(function(list) {\n\t\t\tlist.setSize(size);\n\t\t\titer.forEach(function(v, i) {\n\t\t\t\treturn list.set(i, v);\n\t\t\t});\n\t\t});\n\t}\n\tif (IndexedCollection$$1) List.__proto__ = IndexedCollection$$1;\n\tList.prototype = Object.create(\n\t\tIndexedCollection$$1 && IndexedCollection$$1.prototype\n\t);\n\tList.prototype.constructor = List;\n\tList.of = function of() {\n\t\treturn this(arguments);\n\t};\n\tList.prototype.toString = function toString() {\n\t\treturn this.__toString('List [', ']');\n\t};\n\t\n\tList.prototype.get = function get(index, notSetValue) {\n\t\tindex = wrapIndex(this, index);\n\t\tif (index >= 0 && index < this.size) {\n\t\t\tindex += this._origin;\n\t\t\tvar node = listNodeFor(this, index);\n\t\t\treturn node && node.array[index & MASK];\n\t\t}\n\t\treturn notSetValue;\n\t};\n\t\n\tList.prototype.set = function set(index, value) {\n\t\treturn updateList(this, index, value);\n\t};\n\tList.prototype.remove = function remove(index) {\n\t\treturn !this.has(index)\n\t\t\t? this\n\t\t\t: index === 0\n\t\t\t\t? this.shift()\n\t\t\t\t: index === this.size - 1\n\t\t\t\t\t? this.pop()\n\t\t\t\t\t: this.splice(index, 1);\n\t};\n\tList.prototype.insert = function insert(index, value) {\n\t\treturn this.splice(index, 0, value);\n\t};\n\tList.prototype.clear = function clear() {\n\t\tif (this.size === 0) {\n\t\t\treturn this;\n\t\t}\n\t\tif (this.__ownerID) {\n\t\t\tthis.size = this._origin = this._capacity = 0;\n\t\t\tthis._level = SHIFT;\n\t\t\tthis._root = this._tail = null;\n\t\t\tthis.__hash = undefined;\n\t\t\tthis.__altered = true;\n\t\t\treturn this;\n\t\t}\n\t\treturn emptyList();\n\t};\n\tList.prototype.push = function push() {\n\t\tvar values = arguments;\n\t\tvar oldSize = this.size;\n\t\treturn this.withMutations(function(list) {\n\t\t\tsetListBounds(list, 0, oldSize + values.length);\n\t\t\tfor (var ii = 0; ii < values.length; ii++) {\n\t\t\t\tlist.set(oldSize + ii, values[ii]);\n\t\t\t}\n\t\t});\n\t};\n\tList.prototype.pop = function pop() {\n\t\treturn setListBounds(this, 0, -1);\n\t};\n\tList.prototype.unshift = function unshift() {\n\t\tvar values = arguments;\n\t\treturn this.withMutations(function(list) {\n\t\t\tsetListBounds(list, -values.length);\n\t\t\tfor (var ii = 0; ii < values.length; ii++) {\n\t\t\t\tlist.set(ii, values[ii]);\n\t\t\t}\n\t\t});\n\t};\n\tList.prototype.shift = function shift() {\n\t\treturn setListBounds(this, 1);\n\t};\n\t\n\tList.prototype.concat = function concat() {\n\t\tvar arguments$1 = arguments;\n\t\tvar seqs = [];\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar argument = arguments$1[i];\n\t\t\tvar seq = IndexedCollection$$1(\n\t\t\t\ttypeof argument !== 'string' && hasIterator(argument)\n\t\t\t\t\t? argument\n\t\t\t\t\t: [argument]\n\t\t\t);\n\t\t\tif (seq.size !== 0) {\n\t\t\t\tseqs.push(seq);\n\t\t\t}\n\t\t}\n\t\tif (seqs.length === 0) {\n\t\t\treturn this;\n\t\t}\n\t\tif (this.size === 0 && !this.__ownerID && seqs.length === 1) {\n\t\t\treturn this.constructor(seqs[0]);\n\t\t}\n\t\treturn this.withMutations(function(list) {\n\t\t\tseqs.forEach(function(seq) {\n\t\t\t\treturn seq.forEach(function(value) {\n\t\t\t\t\treturn list.push(value);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t};\n\tList.prototype.setSize = function setSize(size) {\n\t\treturn setListBounds(this, 0, size);\n\t};\n\t\n\tList.prototype.slice = function slice(begin, end) {\n\t\tvar size = this.size;\n\t\tif (wholeSlice(begin, end, size)) {\n\t\t\treturn this;\n\t\t}\n\t\treturn setListBounds(\n\t\t\tthis,\n\t\t\tresolveBegin(begin, size),\n\t\t\tresolveEnd(end, size)\n\t\t);\n\t};\n\tList.prototype.__iterator = function __iterator(type, reverse) {\n\t\tvar index = reverse ? this.size : 0;\n\t\tvar values = iterateList(this, reverse);\n\t\treturn new Iterator(function() {\n\t\t\tvar value = values();\n\t\t\treturn value === DONE\n\t\t\t\t? iteratorDone()\n\t\t\t\t: iteratorValue(type, reverse ? --index : index++, value);\n\t\t});\n\t};\n\tList.prototype.__iterate = function __iterate(fn, reverse) {\n\t\tvar this$1 = this;\n\t\tvar index = reverse ? this.size : 0;\n\t\tvar values = iterateList(this, reverse);\n\t\tvar value;\n\t\twhile ((value = values()) !== DONE) {\n\t\t\tif (fn(value, reverse ? --index : index++, this$1) === false) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t};\n\tList.prototype.__ensureOwner = function __ensureOwner(ownerID) {\n\t\tif (ownerID === this.__ownerID) {\n\t\t\treturn this;\n\t\t}\n\t\tif (!ownerID) {\n\t\t\tif (this.size === 0) {\n\t\t\t\treturn emptyList();\n\t\t\t}\n\t\t\tthis.__ownerID = ownerID;\n\t\t\tthis.__altered = false;\n\t\t\treturn this;\n\t\t}\n\t\treturn makeList(\n\t\t\tthis._origin,\n\t\t\tthis._capacity,\n\t\t\tthis._level,\n\t\t\tthis._root,\n\t\t\tthis._tail,\n\t\t\townerID,\n\t\t\tthis.__hash\n\t\t);\n\t};\n\treturn List;\n})(IndexedCollection);\nfunction isList(maybeList) {\n\treturn !!(maybeList && maybeList[IS_LIST_SENTINEL]);\n}\nList.isList = isList;\nvar IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';\nvar ListPrototype = List.prototype;\nListPrototype[IS_LIST_SENTINEL] = true;\nListPrototype[DELETE] = ListPrototype.remove;\nListPrototype.merge = ListPrototype.concat;\nListPrototype.setIn = setIn$$1;\nListPrototype.deleteIn = ListPrototype.removeIn = deleteIn;\nListPrototype.update = update$$1;\nListPrototype.updateIn = updateIn$1;\nListPrototype.mergeIn = mergeIn;\nListPrototype.mergeDeepIn = mergeDeepIn;\nListPrototype.withMutations = withMutations;\nListPrototype.wasAltered = wasAltered;\nListPrototype.asImmutable = asImmutable;\nListPrototype['@@transducer/init'] = ListPrototype.asMutable = asMutable;\nListPrototype['@@transducer/step'] = function(result, arr) {\n\treturn result.push(arr);\n};\nListPrototype['@@transducer/result'] = function(obj) {\n\treturn obj.asImmutable();\n};\nvar VNode = function VNode(array, ownerID) {\n\tthis.array = array;\n\tthis.ownerID = ownerID;\n};\n\nVNode.prototype.removeBefore = function removeBefore(ownerID, level, index) {\n\tif (index === level ? 1 << level : 0 || this.array.length === 0) {\n\t\treturn this;\n\t}\n\tvar originIndex = (index >>> level) & MASK;\n\tif (originIndex >= this.array.length) {\n\t\treturn new VNode([], ownerID);\n\t}\n\tvar removingFirst = originIndex === 0;\n\tvar newChild;\n\tif (level > 0) {\n\t\tvar oldChild = this.array[originIndex];\n\t\tnewChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);\n\t\tif (newChild === oldChild && removingFirst) {\n\t\t\treturn this;\n\t\t}\n\t}\n\tif (removingFirst && !newChild) {\n\t\treturn this;\n\t}\n\tvar editable = editableVNode(this, ownerID);\n\tif (!removingFirst) {\n\t\tfor (var ii = 0; ii < originIndex; ii++) {\n\t\t\teditable.array[ii] = undefined;\n\t\t}\n\t}\n\tif (newChild) {\n\t\teditable.array[originIndex] = newChild;\n\t}\n\treturn editable;\n};\nVNode.prototype.removeAfter = function removeAfter(ownerID, level, index) {\n\tif (index === (level ? 1 << level : 0) || this.array.length === 0) {\n\t\treturn this;\n\t}\n\tvar sizeIndex = ((index - 1) >>> level) & MASK;\n\tif (sizeIndex >= this.array.length) {\n\t\treturn this;\n\t}\n\tvar newChild;\n\tif (level > 0) {\n\t\tvar oldChild = this.array[sizeIndex];\n\t\tnewChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);\n\t\tif (newChild === oldChild && sizeIndex === this.array.length - 1) {\n\t\t\treturn this;\n\t\t}\n\t}\n\tvar editable = editableVNode(this, ownerID);\n\teditable.array.splice(sizeIndex + 1);\n\tif (newChild) {\n\t\teditable.array[sizeIndex] = newChild;\n\t}\n\treturn editable;\n};\nvar DONE = {};\nfunction iterateList(list, reverse) {\n\tvar left = list._origin;\n\tvar right = list._capacity;\n\tvar tailPos = getTailOffset(right);\n\tvar tail = list._tail;\n\treturn iterateNodeOrLeaf(list._root, list._level, 0);\n\tfunction iterateNodeOrLeaf(node, level, offset) {\n\t\treturn level === 0\n\t\t\t? iterateLeaf(node, offset)\n\t\t\t: iterateNode(node, level, offset);\n\t}\n\tfunction iterateLeaf(node, offset) {\n\t\tvar array = offset === tailPos ? tail && tail.array : node && node.array;\n\t\tvar from = offset > left ? 0 : left - offset;\n\t\tvar to = right - offset;\n\t\tif (to > SIZE) {\n\t\t\tto = SIZE;\n\t\t}\n\t\treturn function() {\n\t\t\tif (from === to) {\n\t\t\t\treturn DONE;\n\t\t\t}\n\t\t\tvar idx = reverse ? --to : from++;\n\t\t\treturn array && array[idx];\n\t\t};\n\t}\n\tfunction iterateNode(node, level, offset) {\n\t\tvar values;\n\t\tvar array = node && node.array;\n\t\tvar from = offset > left ? 0 : (left - offset) >> level;\n\t\tvar to = ((right - offset) >> level) + 1;\n\t\tif (to > SIZE) {\n\t\t\tto = SIZE;\n\t\t}\n\t\treturn function() {\n\t\t\twhile (true) {\n\t\t\t\tif (values) {\n\t\t\t\t\tvar value = values();\n\t\t\t\t\tif (value !== DONE) {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t\tvalues = null;\n\t\t\t\t}\n\t\t\t\tif (from === to) {\n\t\t\t\t\treturn DONE;\n\t\t\t\t}\n\t\t\t\tvar idx = reverse ? --to : from++;\n\t\t\t\tvalues = iterateNodeOrLeaf(\n\t\t\t\t\tarray && array[idx],\n\t\t\t\t\tlevel - SHIFT,\n\t\t\t\t\toffset + (idx << level)\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\t}\n}\nfunction makeList(origin, capacity, level, root, tail, ownerID, hash) {\n\tvar list = Object.create(ListPrototype);\n\tlist.size = capacity - origin;\n\tlist._origin = origin;\n\tlist._capacity = capacity;\n\tlist._level = level;\n\tlist._root = root;\n\tlist._tail = tail;\n\tlist.__ownerID = ownerID;\n\tlist.__hash = hash;\n\tlist.__altered = false;\n\treturn list;\n}\nvar EMPTY_LIST;\nfunction emptyList() {\n\treturn EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));\n}\nfunction updateList(list, index, value) {\n\tindex = wrapIndex(list, index);\n\tif (index !== index) {\n\t\treturn list;\n\t}\n\tif (index >= list.size || index < 0) {\n\t\treturn list.withMutations(function(list) {\n\t\t\tindex < 0\n\t\t\t\t? setListBounds(list, index).set(0, value)\n\t\t\t\t: setListBounds(list, 0, index + 1).set(index, value);\n\t\t});\n\t}\n\tindex += list._origin;\n\tvar newTail = list._tail;\n\tvar newRoot = list._root;\n\tvar didAlter = MakeRef(DID_ALTER);\n\tif (index >= getTailOffset(list._capacity)) {\n\t\tnewTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);\n\t} else {\n\t\tnewRoot = updateVNode(\n\t\t\tnewRoot,\n\t\t\tlist.__ownerID,\n\t\t\tlist._level,\n\t\t\tindex,\n\t\t\tvalue,\n\t\t\tdidAlter\n\t\t);\n\t}\n\tif (!didAlter.value) {\n\t\treturn list;\n\t}\n\tif (list.__ownerID) {\n\t\tlist._root = newRoot;\n\t\tlist._tail = newTail;\n\t\tlist.__hash = undefined;\n\t\tlist.__altered = true;\n\t\treturn list;\n\t}\n\treturn makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n}\nfunction updateVNode(node, ownerID, level, index, value, didAlter) {\n\tvar idx = (index >>> level) & MASK;\n\tvar nodeHas = node && idx < node.array.length;\n\tif (!nodeHas && value === undefined) {\n\t\treturn node;\n\t}\n\tvar newNode;\n\tif (level > 0) {\n\t\tvar lowerNode = node && node.array[idx];\n\t\tvar newLowerNode = updateVNode(\n\t\t\tlowerNode,\n\t\t\townerID,\n\t\t\tlevel - SHIFT,\n\t\t\tindex,\n\t\t\tvalue,\n\t\t\tdidAlter\n\t\t);\n\t\tif (newLowerNode === lowerNode) {\n\t\t\treturn node;\n\t\t}\n\t\tnewNode = editableVNode(node, ownerID);\n\t\tnewNode.array[idx] = newLowerNode;\n\t\treturn newNode;\n\t}\n\tif (nodeHas && node.array[idx] === value) {\n\t\treturn node;\n\t}\n\tSetRef(didAlter);\n\tnewNode = editableVNode(node, ownerID);\n\tif (value === undefined && idx === newNode.array.length - 1) {\n\t\tnewNode.array.pop();\n\t} else {\n\t\tnewNode.array[idx] = value;\n\t}\n\treturn newNode;\n}\nfunction editableVNode(node, ownerID) {\n\tif (ownerID && node && ownerID === node.ownerID) {\n\t\treturn node;\n\t}\n\treturn new VNode(node ? node.array.slice() : [], ownerID);\n}\nfunction listNodeFor(list, rawIndex) {\n\tif (rawIndex >= getTailOffset(list._capacity)) {\n\t\treturn list._tail;\n\t}\n\tif (rawIndex < 1 << (list._level + SHIFT)) {\n\t\tvar node = list._root;\n\t\tvar level = list._level;\n\t\twhile (node && level > 0) {\n\t\t\tnode = node.array[(rawIndex >>> level) & MASK];\n\t\t\tlevel -= SHIFT;\n\t\t}\n\t\treturn node;\n\t}\n}\nfunction setListBounds(list, begin, end) {\n\tif (begin !== undefined) {\n\t\tbegin |= 0;\n\t}\n\tif (end !== undefined) {\n\t\tend |= 0;\n\t}\n\tvar owner = list.__ownerID || new OwnerID();\n\tvar oldOrigin = list._origin;\n\tvar oldCapacity = list._capacity;\n\tvar newOrigin = oldOrigin + begin;\n\tvar newCapacity =\n\t\tend === undefined\n\t\t\t? oldCapacity\n\t\t\t: end < 0\n\t\t\t\t? oldCapacity + end\n\t\t\t\t: oldOrigin + end;\n\tif (newOrigin === oldOrigin && newCapacity === oldCapacity) {\n\t\treturn list;\n\t}\n\tif (newOrigin >= newCapacity) {\n\t\treturn list.clear();\n\t}\n\tvar newLevel = list._level;\n\tvar newRoot = list._root;\n\tvar offsetShift = 0;\n\twhile (newOrigin + offsetShift < 0) {\n\t\tnewRoot = new VNode(\n\t\t\tnewRoot && newRoot.array.length ? [undefined, newRoot] : [],\n\t\t\towner\n\t\t);\n\t\tnewLevel += SHIFT;\n\t\toffsetShift += 1 << newLevel;\n\t}\n\tif (offsetShift) {\n\t\tnewOrigin += offsetShift;\n\t\toldOrigin += offsetShift;\n\t\tnewCapacity += offsetShift;\n\t\toldCapacity += offsetShift;\n\t}\n\tvar oldTailOffset = getTailOffset(oldCapacity);\n\tvar newTailOffset = getTailOffset(newCapacity);\n\twhile (newTailOffset >= 1 << (newLevel + SHIFT)) {\n\t\tnewRoot = new VNode(\n\t\t\tnewRoot && newRoot.array.length ? [newRoot] : [],\n\t\t\towner\n\t\t);\n\t\tnewLevel += SHIFT;\n\t}\n\tvar oldTail = list._tail;\n\tvar newTail =\n\t\tnewTailOffset < oldTailOffset\n\t\t\t? listNodeFor(list, newCapacity - 1)\n\t\t\t: newTailOffset > oldTailOffset\n\t\t\t\t? new VNode([], owner)\n\t\t\t\t: oldTail;\n\tif (\n\t\toldTail &&\n\t\tnewTailOffset > oldTailOffset &&\n\t\tnewOrigin < oldCapacity &&\n\t\toldTail.array.length\n\t) {\n\t\tnewRoot = editableVNode(newRoot, owner);\n\t\tvar node = newRoot;\n\t\tfor (var level = newLevel; level > SHIFT; level -= SHIFT) {\n\t\t\tvar idx = (oldTailOffset >>> level) & MASK;\n\t\t\tnode = node.array[idx] = editableVNode(node.array[idx], owner);\n\t\t}\n\t\tnode.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;\n\t}\n\tif (newCapacity < oldCapacity) {\n\t\tnewTail = newTail && newTail.removeAfter(owner, 0, newCapacity);\n\t}\n\tif (newOrigin >= newTailOffset) {\n\t\tnewOrigin -= newTailOffset;\n\t\tnewCapacity -= newTailOffset;\n\t\tnewLevel = SHIFT;\n\t\tnewRoot = null;\n\t\tnewTail = newTail && newTail.removeBefore(owner, 0, newOrigin);\n\t} else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {\n\t\toffsetShift = 0;\n\t\twhile (newRoot) {\n\t\t\tvar beginIndex = (newOrigin >>> newLevel) & MASK;\n\t\t\tif ((beginIndex !== newTailOffset >>> newLevel) & MASK) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (beginIndex) {\n\t\t\t\toffsetShift += (1 << newLevel) * beginIndex;\n\t\t\t}\n\t\t\tnewLevel -= SHIFT;\n\t\t\tnewRoot = newRoot.array[beginIndex];\n\t\t}\n\t\tif (newRoot && newOrigin > oldOrigin) {\n\t\t\tnewRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);\n\t\t}\n\t\tif (newRoot && newTailOffset < oldTailOffset) {\n\t\t\tnewRoot = newRoot.removeAfter(\n\t\t\t\towner,\n\t\t\t\tnewLevel,\n\t\t\t\tnewTailOffset - offsetShift\n\t\t\t);\n\t\t}\n\t\tif (offsetShift) {\n\t\t\tnewOrigin -= offsetShift;\n\t\t\tnewCapacity -= offsetShift;\n\t\t}\n\t}\n\tif (list.__ownerID) {\n\t\tlist.size = newCapacity - newOrigin;\n\t\tlist._origin = newOrigin;\n\t\tlist._capacity = newCapacity;\n\t\tlist._level = newLevel;\n\t\tlist._root = newRoot;\n\t\tlist._tail = newTail;\n\t\tlist.__hash = undefined;\n\t\tlist.__altered = true;\n\t\treturn list;\n\t}\n\treturn makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);\n}\nfunction getTailOffset(size) {\n\treturn size < SIZE ? 0 : ((size - 1) >>> SHIFT) << SHIFT;\n}\nvar OrderedMap = (function(Map$$1) {\n\tfunction OrderedMap(value) {\n\t\treturn value === null || value === undefined\n\t\t\t? emptyOrderedMap()\n\t\t\t: isOrderedMap(value)\n\t\t\t\t? value\n\t\t\t\t: emptyOrderedMap().withMutations(function(map) {\n\t\t\t\t\t\tvar iter = KeyedCollection(value);\n\t\t\t\t\t\tassertNotInfinite(iter.size);\n\t\t\t\t\t\titer.forEach(function(v, k) {\n\t\t\t\t\t\t\treturn map.set(k, v);\n\t\t\t\t\t\t});\n\t\t\t\t  });\n\t}\n\tif (Map$$1) OrderedMap.__proto__ = Map$$1;\n\tOrderedMap.prototype = Object.create(Map$$1 && Map$$1.prototype);\n\tOrderedMap.prototype.constructor = OrderedMap;\n\tOrderedMap.of = function of() {\n\t\treturn this(arguments);\n\t};\n\tOrderedMap.prototype.toString = function toString() {\n\t\treturn this.__toString('OrderedMap {', '}');\n\t};\n\t\n\tOrderedMap.prototype.get = function get(k, notSetValue) {\n\t\tvar index = this._map.get(k);\n\t\treturn index !== undefined ? this._list.get(index)[1] : notSetValue;\n\t};\n\t\n\tOrderedMap.prototype.clear = function clear() {\n\t\tif (this.size === 0) {\n\t\t\treturn this;\n\t\t}\n\t\tif (this.__ownerID) {\n\t\t\tthis.size = 0;\n\t\t\tthis._map.clear();\n\t\t\tthis._list.clear();\n\t\t\treturn this;\n\t\t}\n\t\treturn emptyOrderedMap();\n\t};\n\tOrderedMap.prototype.set = function set(k, v) {\n\t\treturn updateOrderedMap(this, k, v);\n\t};\n\tOrderedMap.prototype.remove = function remove(k) {\n\t\treturn updateOrderedMap(this, k, NOT_SET);\n\t};\n\tOrderedMap.prototype.wasAltered = function wasAltered() {\n\t\treturn this._map.wasAltered() || this._list.wasAltered();\n\t};\n\tOrderedMap.prototype.__iterate = function __iterate(fn, reverse) {\n\t\tvar this$1 = this;\n\t\treturn this._list.__iterate(function(entry) {\n\t\t\treturn entry && fn(entry[1], entry[0], this$1);\n\t\t}, reverse);\n\t};\n\tOrderedMap.prototype.__iterator = function __iterator(type, reverse) {\n\t\treturn this._list.fromEntrySeq().__iterator(type, reverse);\n\t};\n\tOrderedMap.prototype.__ensureOwner = function __ensureOwner(ownerID) {\n\t\tif (ownerID === this.__ownerID) {\n\t\t\treturn this;\n\t\t}\n\t\tvar newMap = this._map.__ensureOwner(ownerID);\n\t\tvar newList = this._list.__ensureOwner(ownerID);\n\t\tif (!ownerID) {\n\t\t\tif (this.size === 0) {\n\t\t\t\treturn emptyOrderedMap();\n\t\t\t}\n\t\t\tthis.__ownerID = ownerID;\n\t\t\tthis._map = newMap;\n\t\t\tthis._list = newList;\n\t\t\treturn this;\n\t\t}\n\t\treturn makeOrderedMap(newMap, newList, ownerID, this.__hash);\n\t};\n\treturn OrderedMap;\n})(Map);\nfunction isOrderedMap(maybeOrderedMap) {\n\treturn isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);\n}\nOrderedMap.isOrderedMap = isOrderedMap;\nOrderedMap.prototype[IS_ORDERED_SENTINEL] = true;\nOrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;\nfunction makeOrderedMap(map, list, ownerID, hash) {\n\tvar omap = Object.create(OrderedMap.prototype);\n\tomap.size = map ? map.size : 0;\n\tomap._map = map;\n\tomap._list = list;\n\tomap.__ownerID = ownerID;\n\tomap.__hash = hash;\n\treturn omap;\n}\nvar EMPTY_ORDERED_MAP;\nfunction emptyOrderedMap() {\n\treturn (\n\t\tEMPTY_ORDERED_MAP ||\n\t\t(EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()))\n\t);\n}\nfunction updateOrderedMap(omap, k, v) {\n\tvar map = omap._map;\n\tvar list = omap._list;\n\tvar i = map.get(k);\n\tvar has = i !== undefined;\n\tvar newMap;\n\tvar newList;\n\tif (v === NOT_SET) {\n\t\tif (!has) {\n\t\t\treturn omap;\n\t\t}\n\t\tif (list.size >= SIZE && list.size >= map.size * 2) {\n\t\t\tnewList = list.filter(function(entry, idx) {\n\t\t\t\treturn entry !== undefined && i !== idx;\n\t\t\t});\n\t\t\tnewMap = newList\n\t\t\t\t.toKeyedSeq()\n\t\t\t\t.map(function(entry) {\n\t\t\t\t\treturn entry[0];\n\t\t\t\t})\n\t\t\t\t.flip()\n\t\t\t\t.toMap();\n\t\t\tif (omap.__ownerID) {\n\t\t\t\tnewMap.__ownerID = newList.__ownerID = omap.__ownerID;\n\t\t\t}\n\t\t} else {\n\t\t\tnewMap = map.remove(k);\n\t\t\tnewList = i === list.size - 1 ? list.pop() : list.set(i, undefined);\n\t\t}\n\t} else if (has) {\n\t\tif (v === list.get(i)[1]) {\n\t\t\treturn omap;\n\t\t}\n\t\tnewMap = map;\n\t\tnewList = list.set(i, [k, v]);\n\t} else {\n\t\tnewMap = map.set(k, list.size);\n\t\tnewList = list.set(list.size, [k, v]);\n\t}\n\tif (omap.__ownerID) {\n\t\tomap.size = newMap.size;\n\t\tomap._map = newMap;\n\t\tomap._list = newList;\n\t\tomap.__hash = undefined;\n\t\treturn omap;\n\t}\n\treturn makeOrderedMap(newMap, newList);\n}\nvar Stack = (function(IndexedCollection$$1) {\n\tfunction Stack(value) {\n\t\treturn value === null || value === undefined\n\t\t\t? emptyStack()\n\t\t\t: isStack(value)\n\t\t\t\t? value\n\t\t\t\t: emptyStack().pushAll(value);\n\t}\n\tif (IndexedCollection$$1) Stack.__proto__ = IndexedCollection$$1;\n\tStack.prototype = Object.create(\n\t\tIndexedCollection$$1 && IndexedCollection$$1.prototype\n\t);\n\tStack.prototype.constructor = Stack;\n\tStack.of = function of() {\n\t\treturn this(arguments);\n\t};\n\tStack.prototype.toString = function toString() {\n\t\treturn this.__toString('Stack [', ']');\n\t};\n\t\n\tStack.prototype.get = function get(index, notSetValue) {\n\t\tvar head = this._head;\n\t\tindex = wrapIndex(this, index);\n\t\twhile (head && index--) {\n\t\t\thead = head.next;\n\t\t}\n\t\treturn head ? head.value : notSetValue;\n\t};\n\tStack.prototype.peek = function peek() {\n\t\treturn this._head && this._head.value;\n\t};\n\t\n\tStack.prototype.push = function push() {\n\t\tvar arguments$1 = arguments;\n\t\tif (arguments.length === 0) {\n\t\t\treturn this;\n\t\t}\n\t\tvar newSize = this.size + arguments.length;\n\t\tvar head = this._head;\n\t\tfor (var ii = arguments.length - 1; ii >= 0; ii--) {\n\t\t\thead = {\n\t\t\t\tvalue: arguments$1[ii],\n\t\t\t\tnext: head\n\t\t\t};\n\t\t}\n\t\tif (this.__ownerID) {\n\t\t\tthis.size = newSize;\n\t\t\tthis._head = head;\n\t\t\tthis.__hash = undefined;\n\t\t\tthis.__altered = true;\n\t\t\treturn this;\n\t\t}\n\t\treturn makeStack(newSize, head);\n\t};\n\tStack.prototype.pushAll = function pushAll(iter) {\n\t\titer = IndexedCollection$$1(iter);\n\t\tif (iter.size === 0) {\n\t\t\treturn this;\n\t\t}\n\t\tif (this.size === 0 && isStack(iter)) {\n\t\t\treturn iter;\n\t\t}\n\t\tassertNotInfinite(iter.size);\n\t\tvar newSize = this.size;\n\t\tvar head = this._head;\n\t\titer.__iterate(function(value) {\n\t\t\tnewSize++;\n\t\t\thead = {\n\t\t\t\tvalue: value,\n\t\t\t\tnext: head\n\t\t\t};\n\t\t},  true);\n\t\tif (this.__ownerID) {\n\t\t\tthis.size = newSize;\n\t\t\tthis._head = head;\n\t\t\tthis.__hash = undefined;\n\t\t\tthis.__altered = true;\n\t\t\treturn this;\n\t\t}\n\t\treturn makeStack(newSize, head);\n\t};\n\tStack.prototype.pop = function pop() {\n\t\treturn this.slice(1);\n\t};\n\tStack.prototype.clear = function clear() {\n\t\tif (this.size === 0) {\n\t\t\treturn this;\n\t\t}\n\t\tif (this.__ownerID) {\n\t\t\tthis.size = 0;\n\t\t\tthis._head = undefined;\n\t\t\tthis.__hash = undefined;\n\t\t\tthis.__altered = true;\n\t\t\treturn this;\n\t\t}\n\t\treturn emptyStack();\n\t};\n\tStack.prototype.slice = function slice(begin, end) {\n\t\tif (wholeSlice(begin, end, this.size)) {\n\t\t\treturn this;\n\t\t}\n\t\tvar resolvedBegin = resolveBegin(begin, this.size);\n\t\tvar resolvedEnd = resolveEnd(end, this.size);\n\t\tif (resolvedEnd !== this.size) {\n\t\t\treturn IndexedCollection$$1.prototype.slice.call(this, begin, end);\n\t\t}\n\t\tvar newSize = this.size - resolvedBegin;\n\t\tvar head = this._head;\n\t\twhile (resolvedBegin--) {\n\t\t\thead = head.next;\n\t\t}\n\t\tif (this.__ownerID) {\n\t\t\tthis.size = newSize;\n\t\t\tthis._head = head;\n\t\t\tthis.__hash = undefined;\n\t\t\tthis.__altered = true;\n\t\t\treturn this;\n\t\t}\n\t\treturn makeStack(newSize, head);\n\t};\n\t\n\tStack.prototype.__ensureOwner = function __ensureOwner(ownerID) {\n\t\tif (ownerID === this.__ownerID) {\n\t\t\treturn this;\n\t\t}\n\t\tif (!ownerID) {\n\t\t\tif (this.size === 0) {\n\t\t\t\treturn emptyStack();\n\t\t\t}\n\t\t\tthis.__ownerID = ownerID;\n\t\t\tthis.__altered = false;\n\t\t\treturn this;\n\t\t}\n\t\treturn makeStack(this.size, this._head, ownerID, this.__hash);\n\t};\n\t\n\tStack.prototype.__iterate = function __iterate(fn, reverse) {\n\t\tvar this$1 = this;\n\t\tif (reverse) {\n\t\t\treturn new ArraySeq(this.toArray()).__iterate(function(v, k) {\n\t\t\t\treturn fn(v, k, this$1);\n\t\t\t}, reverse);\n\t\t}\n\t\tvar iterations = 0;\n\t\tvar node = this._head;\n\t\twhile (node) {\n\t\t\tif (fn(node.value, iterations++, this$1) === false) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnode = node.next;\n\t\t}\n\t\treturn iterations;\n\t};\n\tStack.prototype.__iterator = function __iterator(type, reverse) {\n\t\tif (reverse) {\n\t\t\treturn new ArraySeq(this.toArray()).__iterator(type, reverse);\n\t\t}\n\t\tvar iterations = 0;\n\t\tvar node = this._head;\n\t\treturn new Iterator(function() {\n\t\t\tif (node) {\n\t\t\t\tvar value = node.value;\n\t\t\t\tnode = node.next;\n\t\t\t\treturn iteratorValue(type, iterations++, value);\n\t\t\t}\n\t\t\treturn iteratorDone();\n\t\t});\n\t};\n\treturn Stack;\n})(IndexedCollection);\nfunction isStack(maybeStack) {\n\treturn !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);\n}\nStack.isStack = isStack;\nvar IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';\nvar StackPrototype = Stack.prototype;\nStackPrototype[IS_STACK_SENTINEL] = true;\nStackPrototype.shift = StackPrototype.pop;\nStackPrototype.unshift = StackPrototype.push;\nStackPrototype.unshiftAll = StackPrototype.pushAll;\nStackPrototype.withMutations = withMutations;\nStackPrototype.wasAltered = wasAltered;\nStackPrototype.asImmutable = asImmutable;\nStackPrototype['@@transducer/init'] = StackPrototype.asMutable = asMutable;\nStackPrototype['@@transducer/step'] = function(result, arr) {\n\treturn result.unshift(arr);\n};\nStackPrototype['@@transducer/result'] = function(obj) {\n\treturn obj.asImmutable();\n};\nfunction makeStack(size, head, ownerID, hash) {\n\tvar map = Object.create(StackPrototype);\n\tmap.size = size;\n\tmap._head = head;\n\tmap.__ownerID = ownerID;\n\tmap.__hash = hash;\n\tmap.__altered = false;\n\treturn map;\n}\nvar EMPTY_STACK;\nfunction emptyStack() {\n\treturn EMPTY_STACK || (EMPTY_STACK = makeStack(0));\n}\nfunction deepEqual(a, b) {\n\tif (a === b) {\n\t\treturn true;\n\t}\n\tif (\n\t\t!isCollection(b) ||\n\t\t(a.size !== undefined && b.size !== undefined && a.size !== b.size) ||\n\t\t(a.__hash !== undefined &&\n\t\t\tb.__hash !== undefined &&\n\t\t\ta.__hash !== b.__hash) ||\n\t\tisKeyed(a) !== isKeyed(b) ||\n\t\tisIndexed(a) !== isIndexed(b) ||\n\t\tisOrdered(a) !== isOrdered(b)\n\t) {\n\t\treturn false;\n\t}\n\tif (a.size === 0 && b.size === 0) {\n\t\treturn true;\n\t}\n\tvar notAssociative = !isAssociative(a);\n\tif (isOrdered(a)) {\n\t\tvar entries = a.entries();\n\t\treturn (\n\t\t\tb.every(function(v, k) {\n\t\t\t\tvar entry = entries.next().value;\n\t\t\t\treturn entry && is(entry[1], v) && (notAssociative || is(entry[0], k));\n\t\t\t}) && entries.next().done\n\t\t);\n\t}\n\tvar flipped = false;\n\tif (a.size === undefined) {\n\t\tif (b.size === undefined) {\n\t\t\tif (typeof a.cacheResult === 'function') {\n\t\t\t\ta.cacheResult();\n\t\t\t}\n\t\t} else {\n\t\t\tflipped = true;\n\t\t\tvar _ = a;\n\t\t\ta = b;\n\t\t\tb = _;\n\t\t}\n\t}\n\tvar allEqual = true;\n\tvar bSize = b.__iterate(function(v, k) {\n\t\tif (\n\t\t\tnotAssociative\n\t\t\t\t? !a.has(v)\n\t\t\t\t: flipped\n\t\t\t\t\t? !is(v, a.get(k, NOT_SET))\n\t\t\t\t\t: !is(a.get(k, NOT_SET), v)\n\t\t) {\n\t\t\tallEqual = false;\n\t\t\treturn false;\n\t\t}\n\t});\n\treturn allEqual && a.size === bSize;\n}\n"
						},
						{
							"line": 3738,
							"tags": [],
							"tabs": "",
							"desc": "Contributes additional methods to a constructor ",
							"code": "function mixin(ctor, methods) {\n\tvar keyCopier = function(key) {\n\t\tctor.prototype[key] = methods[key];\n\t};\n\tObject.keys(methods).forEach(keyCopier);\n\tObject.getOwnPropertySymbols &&\n\t\tObject.getOwnPropertySymbols(methods).forEach(keyCopier);\n\treturn ctor;\n}\nfunction toJS(value) {\n\treturn isDataStructure(value)\n\t\t? Seq(value)\n\t\t\t\t.map(toJS)\n\t\t\t\t.toJSON()\n\t\t: value;\n}\nvar Set = (function(SetCollection$$1) {\n\tfunction Set(value) {\n\t\treturn value === null || value === undefined\n\t\t\t? emptySet()\n\t\t\t: isSet(value) && !isOrdered(value)\n\t\t\t\t? value\n\t\t\t\t: emptySet().withMutations(function(set) {\n\t\t\t\t\t\tvar iter = SetCollection$$1(value);\n\t\t\t\t\t\tassertNotInfinite(iter.size);\n\t\t\t\t\t\titer.forEach(function(v) {\n\t\t\t\t\t\t\treturn set.add(v);\n\t\t\t\t\t\t});\n\t\t\t\t  });\n\t}\n\tif (SetCollection$$1) Set.__proto__ = SetCollection$$1;\n\tSet.prototype = Object.create(SetCollection$$1 && SetCollection$$1.prototype);\n\tSet.prototype.constructor = Set;\n\tSet.of = function of() {\n\t\treturn this(arguments);\n\t};\n\tSet.fromKeys = function fromKeys(value) {\n\t\treturn this(KeyedCollection(value).keySeq());\n\t};\n\tSet.intersect = function intersect(sets) {\n\t\tsets = Collection(sets).toArray();\n\t\treturn sets.length\n\t\t\t? SetPrototype.intersect.apply(Set(sets.pop()), sets)\n\t\t\t: emptySet();\n\t};\n\tSet.union = function union(sets) {\n\t\tsets = Collection(sets).toArray();\n\t\treturn sets.length\n\t\t\t? SetPrototype.union.apply(Set(sets.pop()), sets)\n\t\t\t: emptySet();\n\t};\n\tSet.prototype.toString = function toString() {\n\t\treturn this.__toString('Set {', '}');\n\t};\n\t\n\tSet.prototype.has = function has(value) {\n\t\treturn this._map.has(value);\n\t};\n\t\n\tSet.prototype.add = function add(value) {\n\t\treturn updateSet(this, this._map.set(value, value));\n\t};\n\tSet.prototype.remove = function remove(value) {\n\t\treturn updateSet(this, this._map.remove(value));\n\t};\n\tSet.prototype.clear = function clear() {\n\t\treturn updateSet(this, this._map.clear());\n\t};\n\t\n\tSet.prototype.union = function union() {\n\t\tvar iters = [],\n\t\t\tlen = arguments.length;\n\t\twhile (len--) iters[len] = arguments[len];\n\t\titers = iters.filter(function(x) {\n\t\t\treturn x.size !== 0;\n\t\t});\n\t\tif (iters.length === 0) {\n\t\t\treturn this;\n\t\t}\n\t\tif (this.size === 0 && !this.__ownerID && iters.length === 1) {\n\t\t\treturn this.constructor(iters[0]);\n\t\t}\n\t\treturn this.withMutations(function(set) {\n\t\t\tfor (var ii = 0; ii < iters.length; ii++) {\n\t\t\t\tSetCollection$$1(iters[ii]).forEach(function(value) {\n\t\t\t\t\treturn set.add(value);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t};\n\tSet.prototype.intersect = function intersect() {\n\t\tvar iters = [],\n\t\t\tlen = arguments.length;\n\t\twhile (len--) iters[len] = arguments[len];\n\t\tif (iters.length === 0) {\n\t\t\treturn this;\n\t\t}\n\t\titers = iters.map(function(iter) {\n\t\t\treturn SetCollection$$1(iter);\n\t\t});\n\t\tvar toRemove = [];\n\t\tthis.forEach(function(value) {\n\t\t\tif (\n\t\t\t\t!iters.every(function(iter) {\n\t\t\t\t\treturn iter.includes(value);\n\t\t\t\t})\n\t\t\t) {\n\t\t\t\ttoRemove.push(value);\n\t\t\t}\n\t\t});\n\t\treturn this.withMutations(function(set) {\n\t\t\ttoRemove.forEach(function(value) {\n\t\t\t\tset.remove(value);\n\t\t\t});\n\t\t});\n\t};\n\tSet.prototype.subtract = function subtract() {\n\t\tvar iters = [],\n\t\t\tlen = arguments.length;\n\t\twhile (len--) iters[len] = arguments[len];\n\t\tif (iters.length === 0) {\n\t\t\treturn this;\n\t\t}\n\t\titers = iters.map(function(iter) {\n\t\t\treturn SetCollection$$1(iter);\n\t\t});\n\t\tvar toRemove = [];\n\t\tthis.forEach(function(value) {\n\t\t\tif (\n\t\t\t\titers.some(function(iter) {\n\t\t\t\t\treturn iter.includes(value);\n\t\t\t\t})\n\t\t\t) {\n\t\t\t\ttoRemove.push(value);\n\t\t\t}\n\t\t});\n\t\treturn this.withMutations(function(set) {\n\t\t\ttoRemove.forEach(function(value) {\n\t\t\t\tset.remove(value);\n\t\t\t});\n\t\t});\n\t};\n\tSet.prototype.sort = function sort(comparator) {\n\t\treturn OrderedSet(sortFactory(this, comparator));\n\t};\n\tSet.prototype.sortBy = function sortBy(mapper, comparator) {\n\t\treturn OrderedSet(sortFactory(this, comparator, mapper));\n\t};\n\tSet.prototype.wasAltered = function wasAltered() {\n\t\treturn this._map.wasAltered();\n\t};\n\tSet.prototype.__iterate = function __iterate(fn, reverse) {\n\t\tvar this$1 = this;\n\t\treturn this._map.__iterate(function(k) {\n\t\t\treturn fn(k, k, this$1);\n\t\t}, reverse);\n\t};\n\tSet.prototype.__iterator = function __iterator(type, reverse) {\n\t\treturn this._map.__iterator(type, reverse);\n\t};\n\tSet.prototype.__ensureOwner = function __ensureOwner(ownerID) {\n\t\tif (ownerID === this.__ownerID) {\n\t\t\treturn this;\n\t\t}\n\t\tvar newMap = this._map.__ensureOwner(ownerID);\n\t\tif (!ownerID) {\n\t\t\tif (this.size === 0) {\n\t\t\t\treturn this.__empty();\n\t\t\t}\n\t\t\tthis.__ownerID = ownerID;\n\t\t\tthis._map = newMap;\n\t\t\treturn this;\n\t\t}\n\t\treturn this.__make(newMap, ownerID);\n\t};\n\treturn Set;\n})(SetCollection);\nfunction isSet(maybeSet) {\n\treturn !!(maybeSet && maybeSet[IS_SET_SENTINEL]);\n}\nSet.isSet = isSet;\nvar IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';\nvar SetPrototype = Set.prototype;\nSetPrototype[IS_SET_SENTINEL] = true;\nSetPrototype[DELETE] = SetPrototype.remove;\nSetPrototype.merge = SetPrototype.concat = SetPrototype.union;\nSetPrototype.withMutations = withMutations;\nSetPrototype.asImmutable = asImmutable;\nSetPrototype['@@transducer/init'] = SetPrototype.asMutable = asMutable;\nSetPrototype['@@transducer/step'] = function(result, arr) {\n\treturn result.add(arr);\n};\nSetPrototype['@@transducer/result'] = function(obj) {\n\treturn obj.asImmutable();\n};\nSetPrototype.__empty = emptySet;\nSetPrototype.__make = makeSet;\nfunction updateSet(set, newMap) {\n\tif (set.__ownerID) {\n\t\tset.size = newMap.size;\n\t\tset._map = newMap;\n\t\treturn set;\n\t}\n\treturn newMap === set._map\n\t\t? set\n\t\t: newMap.size === 0\n\t\t\t? set.__empty()\n\t\t\t: set.__make(newMap);\n}\nfunction makeSet(map, ownerID) {\n\tvar set = Object.create(SetPrototype);\n\tset.size = map ? map.size : 0;\n\tset._map = map;\n\tset.__ownerID = ownerID;\n\treturn set;\n}\nvar EMPTY_SET;\nfunction emptySet() {\n\treturn EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));\n}\n"
						},
						{
							"line": 3961,
							"tags": [],
							"tabs": "",
							"desc": "Returns a lazy seq of nums from start (inclusive) to end \n(exclusive), by step, where start defaults to 0, step to 1, and end to infinity. When start is equal to end, returns empty list. ",
							"code": "var Range = (function(IndexedSeq$$1) {\n\tfunction Range(start, end, step) {\n\t\tif (!(this instanceof Range)) {\n\t\t\treturn new Range(start, end, step);\n\t\t}\n\t\tinvariant(step !== 0, 'Cannot step a Range by 0');\n\t\tstart = start || 0;\n\t\tif (end === undefined) {\n\t\t\tend = Infinity;\n\t\t}\n\t\tstep = step === undefined ? 1 : Math.abs(step);\n\t\tif (end < start) {\n\t\t\tstep = -step;\n\t\t}\n\t\tthis._start = start;\n\t\tthis._end = end;\n\t\tthis._step = step;\n\t\tthis.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);\n\t\tif (this.size === 0) {\n\t\t\tif (EMPTY_RANGE) {\n\t\t\t\treturn EMPTY_RANGE;\n\t\t\t}\n\t\t\tEMPTY_RANGE = this;\n\t\t}\n\t}\n\tif (IndexedSeq$$1) Range.__proto__ = IndexedSeq$$1;\n\tRange.prototype = Object.create(IndexedSeq$$1 && IndexedSeq$$1.prototype);\n\tRange.prototype.constructor = Range;\n\tRange.prototype.toString = function toString() {\n\t\tif (this.size === 0) {\n\t\t\treturn 'Range []';\n\t\t}\n\t\treturn (\n\t\t\t'Range [ ' +\n\t\t\tthis._start +\n\t\t\t'...' +\n\t\t\tthis._end +\n\t\t\t(this._step !== 1 ? ' by ' + this._step : '') +\n\t\t\t' ]'\n\t\t);\n\t};\n\tRange.prototype.get = function get(index, notSetValue) {\n\t\treturn this.has(index)\n\t\t\t? this._start + wrapIndex(this, index) * this._step\n\t\t\t: notSetValue;\n\t};\n\tRange.prototype.includes = function includes(searchValue) {\n\t\tvar possibleIndex = (searchValue - this._start) / this._step;\n\t\treturn (\n\t\t\tpossibleIndex >= 0 &&\n\t\t\tpossibleIndex < this.size &&\n\t\t\tpossibleIndex === Math.floor(possibleIndex)\n\t\t);\n\t};\n\tRange.prototype.slice = function slice(begin, end) {\n\t\tif (wholeSlice(begin, end, this.size)) {\n\t\t\treturn this;\n\t\t}\n\t\tbegin = resolveBegin(begin, this.size);\n\t\tend = resolveEnd(end, this.size);\n\t\tif (end <= begin) {\n\t\t\treturn new Range(0, 0);\n\t\t}\n\t\treturn new Range(\n\t\t\tthis.get(begin, this._end),\n\t\t\tthis.get(end, this._end),\n\t\t\tthis._step\n\t\t);\n\t};\n\tRange.prototype.indexOf = function indexOf(searchValue) {\n\t\tvar offsetValue = searchValue - this._start;\n\t\tif (offsetValue % this._step === 0) {\n\t\t\tvar index = offsetValue / this._step;\n\t\t\tif (index >= 0 && index < this.size) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t};\n\tRange.prototype.lastIndexOf = function lastIndexOf(searchValue) {\n\t\treturn this.indexOf(searchValue);\n\t};\n\tRange.prototype.__iterate = function __iterate(fn, reverse) {\n\t\tvar this$1 = this;\n\t\tvar size = this.size;\n\t\tvar step = this._step;\n\t\tvar value = reverse ? this._start + (size - 1) * step : this._start;\n\t\tvar i = 0;\n\t\twhile (i !== size) {\n\t\t\tif (fn(value, reverse ? size - ++i : i++, this$1) === false) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvalue += reverse ? -step : step;\n\t\t}\n\t\treturn i;\n\t};\n\tRange.prototype.__iterator = function __iterator(type, reverse) {\n\t\tvar size = this.size;\n\t\tvar step = this._step;\n\t\tvar value = reverse ? this._start + (size - 1) * step : this._start;\n\t\tvar i = 0;\n\t\treturn new Iterator(function() {\n\t\t\tif (i === size) {\n\t\t\t\treturn iteratorDone();\n\t\t\t}\n\t\t\tvar v = value;\n\t\t\tvalue += reverse ? -step : step;\n\t\t\treturn iteratorValue(type, reverse ? size - ++i : i++, v);\n\t\t});\n\t};\n\tRange.prototype.equals = function equals(other) {\n\t\treturn other instanceof Range\n\t\t\t? this._start === other._start &&\n\t\t\t\t\tthis._end === other._end &&\n\t\t\t\t\tthis._step === other._step\n\t\t\t: deepEqual(this, other);\n\t};\n\treturn Range;\n})(IndexedSeq);\nvar EMPTY_RANGE;\nfunction getIn$1(collection, searchKeyPath, notSetValue) {\n\tvar keyPath = coerceKeyPath(searchKeyPath);\n\tvar i = 0;\n\twhile (i !== keyPath.length) {\n\t\tcollection = get(collection, keyPath[i++], NOT_SET);\n\t\tif (collection === NOT_SET) {\n\t\t\treturn notSetValue;\n\t\t}\n\t}\n\treturn collection;\n}\nfunction getIn$$1(searchKeyPath, notSetValue) {\n\treturn getIn$1(this, searchKeyPath, notSetValue);\n}\nfunction hasIn$1(collection, keyPath) {\n\treturn getIn$1(collection, keyPath, NOT_SET) !== NOT_SET;\n}\nfunction hasIn$$1(searchKeyPath) {\n\treturn hasIn$1(this, searchKeyPath);\n}\nfunction toObject() {\n\tassertNotInfinite(this.size);\n\tvar object = {};\n\tthis.__iterate(function(v, k) {\n\t\tobject[k] = v;\n\t});\n\treturn object;\n}\nCollection.isIterable = isCollection;\nCollection.isKeyed = isKeyed;\nCollection.isIndexed = isIndexed;\nCollection.isAssociative = isAssociative;\nCollection.isOrdered = isOrdered;\nCollection.Iterator = Iterator;\nmixin(Collection, {\n\ttoArray: function toArray() {\n\t\tassertNotInfinite(this.size);\n\t\tvar array = new Array(this.size || 0);\n\t\tvar useTuples = isKeyed(this);\n\t\tvar i = 0;\n\t\tthis.__iterate(function(v, k) {\n\t\t\tarray[i++] = useTuples ? [k, v] : v;\n\t\t});\n\t\treturn array;\n\t},\n\ttoIndexedSeq: function toIndexedSeq() {\n\t\treturn new ToIndexedSequence(this);\n\t},\n\ttoJS: function toJS$1() {\n\t\treturn toJS(this);\n\t},\n\ttoKeyedSeq: function toKeyedSeq() {\n\t\treturn new ToKeyedSequence(this, true);\n\t},\n\ttoMap: function toMap() {\n\t\treturn Map(this.toKeyedSeq());\n\t},\n\ttoObject: toObject,\n\ttoOrderedMap: function toOrderedMap() {\n\t\treturn OrderedMap(this.toKeyedSeq());\n\t},\n\ttoOrderedSet: function toOrderedSet() {\n\t\treturn OrderedSet(isKeyed(this) ? this.valueSeq() : this);\n\t},\n\ttoSet: function toSet() {\n\t\treturn Set(isKeyed(this) ? this.valueSeq() : this);\n\t},\n\ttoSetSeq: function toSetSeq() {\n\t\treturn new ToSetSequence(this);\n\t},\n\ttoSeq: function toSeq() {\n\t\treturn isIndexed(this)\n\t\t\t? this.toIndexedSeq()\n\t\t\t: isKeyed(this)\n\t\t\t\t? this.toKeyedSeq()\n\t\t\t\t: this.toSetSeq();\n\t},\n\ttoStack: function toStack() {\n\t\treturn Stack(isKeyed(this) ? this.valueSeq() : this);\n\t},\n\ttoList: function toList() {\n\t\treturn List(isKeyed(this) ? this.valueSeq() : this);\n\t},\n\t\n\ttoString: function toString() {\n\t\treturn '[Collection]';\n\t},\n\t__toString: function __toString(head, tail) {\n\t\tif (this.size === 0) {\n\t\t\treturn head + tail;\n\t\t}\n\t\treturn (\n\t\t\thead +\n\t\t\t' ' +\n\t\t\tthis.toSeq()\n\t\t\t\t.map(this.__toStringMapper)\n\t\t\t\t.join(', ') +\n\t\t\t' ' +\n\t\t\ttail\n\t\t);\n\t},\n\t\n\tconcat: function concat() {\n\t\tvar values = [],\n\t\t\tlen = arguments.length;\n\t\twhile (len--) values[len] = arguments[len];\n\t\treturn reify(this, concatFactory(this, values));\n\t},\n\tincludes: function includes(searchValue) {\n\t\treturn this.some(function(value) {\n\t\t\treturn is(value, searchValue);\n\t\t});\n\t},\n\tentries: function entries() {\n\t\treturn this.__iterator(ITERATE_ENTRIES);\n\t},\n\tevery: function every(predicate, context) {\n\t\tassertNotInfinite(this.size);\n\t\tvar returnValue = true;\n\t\tthis.__iterate(function(v, k, c) {\n\t\t\tif (!predicate.call(context, v, k, c)) {\n\t\t\t\treturnValue = false;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\treturn returnValue;\n\t},\n\tfilter: function filter(predicate, context) {\n\t\treturn reify(this, filterFactory(this, predicate, context, true));\n\t},\n\tfind: function find(predicate, context, notSetValue) {\n\t\tvar entry = this.findEntry(predicate, context);\n\t\treturn entry ? entry[1] : notSetValue;\n\t},\n\tforEach: function forEach(sideEffect, context) {\n\t\tassertNotInfinite(this.size);\n\t\treturn this.__iterate(context ? sideEffect.bind(context) : sideEffect);\n\t},\n\tjoin: function join(separator) {\n\t\tassertNotInfinite(this.size);\n\t\tseparator = separator !== undefined ? '' + separator : ',';\n\t\tvar joined = '';\n\t\tvar isFirst = true;\n\t\tthis.__iterate(function(v) {\n\t\t\tisFirst ? (isFirst = false) : (joined += separator);\n\t\t\tjoined += v !== null && v !== undefined ? v.toString() : '';\n\t\t});\n\t\treturn joined;\n\t},\n\tkeys: function keys() {\n\t\treturn this.__iterator(ITERATE_KEYS);\n\t},\n\tmap: function map(mapper, context) {\n\t\treturn reify(this, mapFactory(this, mapper, context));\n\t},\n\treduce: function(reducer, initialReduction, context) {\n\t\treturn reduce(\n\t\t\tthis,\n\t\t\treducer,\n\t\t\tinitialReduction,\n\t\t\tcontext,\n\t\t\targuments.length < 2,\n\t\t\tfalse\n\t\t);\n\t},\n\treduceRight: function reduceRight(reducer, initialReduction, context) {\n\t\treturn reduce(\n\t\t\tthis,\n\t\t\treducer,\n\t\t\tinitialReduction,\n\t\t\tcontext,\n\t\t\targuments.length < 2,\n\t\t\ttrue\n\t\t);\n\t},\n\treverse: function reverse() {\n\t\treturn reify(this, reverseFactory(this, true));\n\t},\n\tslice: function slice(begin, end) {\n\t\treturn reify(this, sliceFactory(this, begin, end, true));\n\t},\n\tsome: function some(predicate, context) {\n\t\treturn !this.every(not(predicate), context);\n\t},\n\tsort: function sort(comparator) {\n\t\treturn reify(this, sortFactory(this, comparator));\n\t},\n\tvalues: function values() {\n\t\treturn this.__iterator(ITERATE_VALUES);\n\t},\n\t\n\tbutLast: function butLast() {\n\t\treturn this.slice(0, -1);\n\t},\n\tisEmpty: function isEmpty() {\n\t\treturn this.size !== undefined\n\t\t\t? this.size === 0\n\t\t\t: !this.some(function() {\n\t\t\t\t\treturn true;\n\t\t\t  });\n\t},\n\tcount: function count(predicate, context) {\n\t\treturn ensureSize(\n\t\t\tpredicate ? this.toSeq().filter(predicate, context) : this\n\t\t);\n\t},\n\tcountBy: function countBy(grouper, context) {\n\t\treturn countByFactory(this, grouper, context);\n\t},\n\tequals: function equals(other) {\n\t\treturn deepEqual(this, other);\n\t},\n\tentrySeq: function entrySeq() {\n\t\tvar collection = this;\n\t\tif (collection._cache) {\n\t\t\treturn new ArraySeq(collection._cache);\n\t\t}\n\t\tvar entriesSequence = collection\n\t\t\t.toSeq()\n\t\t\t.map(entryMapper)\n\t\t\t.toIndexedSeq();\n\t\tentriesSequence.fromEntrySeq = function() {\n\t\t\treturn collection.toSeq();\n\t\t};\n\t\treturn entriesSequence;\n\t},\n\tfilterNot: function filterNot(predicate, context) {\n\t\treturn this.filter(not(predicate), context);\n\t},\n\tfindEntry: function findEntry(predicate, context, notSetValue) {\n\t\tvar found = notSetValue;\n\t\tthis.__iterate(function(v, k, c) {\n\t\t\tif (predicate.call(context, v, k, c)) {\n\t\t\t\tfound = [k, v];\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\treturn found;\n\t},\n\tfindKey: function findKey(predicate, context) {\n\t\tvar entry = this.findEntry(predicate, context);\n\t\treturn entry && entry[0];\n\t},\n\tfindLast: function findLast(predicate, context, notSetValue) {\n\t\treturn this.toKeyedSeq()\n\t\t\t.reverse()\n\t\t\t.find(predicate, context, notSetValue);\n\t},\n\tfindLastEntry: function findLastEntry(predicate, context, notSetValue) {\n\t\treturn this.toKeyedSeq()\n\t\t\t.reverse()\n\t\t\t.findEntry(predicate, context, notSetValue);\n\t},\n\tfindLastKey: function findLastKey(predicate, context) {\n\t\treturn this.toKeyedSeq()\n\t\t\t.reverse()\n\t\t\t.findKey(predicate, context);\n\t},\n\tfirst: function first() {\n\t\treturn this.find(returnTrue);\n\t},\n\tflatMap: function flatMap(mapper, context) {\n\t\treturn reify(this, flatMapFactory(this, mapper, context));\n\t},\n\tflatten: function flatten(depth) {\n\t\treturn reify(this, flattenFactory(this, depth, true));\n\t},\n\tfromEntrySeq: function fromEntrySeq() {\n\t\treturn new FromEntriesSequence(this);\n\t},\n\tget: function get(searchKey, notSetValue) {\n\t\treturn this.find(\n\t\t\tfunction(_, key) {\n\t\t\t\treturn is(key, searchKey);\n\t\t\t},\n\t\t\tundefined,\n\t\t\tnotSetValue\n\t\t);\n\t},\n\tgetIn: getIn$$1,\n\tgroupBy: function groupBy(grouper, context) {\n\t\treturn groupByFactory(this, grouper, context);\n\t},\n\thas: function has(searchKey) {\n\t\treturn this.get(searchKey, NOT_SET) !== NOT_SET;\n\t},\n\thasIn: hasIn$$1,\n\tisSubset: function isSubset(iter) {\n\t\titer = typeof iter.includes === 'function' ? iter : Collection(iter);\n\t\treturn this.every(function(value) {\n\t\t\treturn iter.includes(value);\n\t\t});\n\t},\n\tisSuperset: function isSuperset(iter) {\n\t\titer = typeof iter.isSubset === 'function' ? iter : Collection(iter);\n\t\treturn iter.isSubset(this);\n\t},\n\tkeyOf: function keyOf(searchValue) {\n\t\treturn this.findKey(function(value) {\n\t\t\treturn is(value, searchValue);\n\t\t});\n\t},\n\tkeySeq: function keySeq() {\n\t\treturn this.toSeq()\n\t\t\t.map(keyMapper)\n\t\t\t.toIndexedSeq();\n\t},\n\tlast: function last() {\n\t\treturn this.toSeq()\n\t\t\t.reverse()\n\t\t\t.first();\n\t},\n\tlastKeyOf: function lastKeyOf(searchValue) {\n\t\treturn this.toKeyedSeq()\n\t\t\t.reverse()\n\t\t\t.keyOf(searchValue);\n\t},\n\tmax: function max(comparator) {\n\t\treturn maxFactory(this, comparator);\n\t},\n\tmaxBy: function maxBy(mapper, comparator) {\n\t\treturn maxFactory(this, comparator, mapper);\n\t},\n\tmin: function min(comparator) {\n\t\treturn maxFactory(\n\t\t\tthis,\n\t\t\tcomparator ? neg(comparator) : defaultNegComparator\n\t\t);\n\t},\n\tminBy: function minBy(mapper, comparator) {\n\t\treturn maxFactory(\n\t\t\tthis,\n\t\t\tcomparator ? neg(comparator) : defaultNegComparator,\n\t\t\tmapper\n\t\t);\n\t},\n\trest: function rest() {\n\t\treturn this.slice(1);\n\t},\n\tskip: function skip(amount) {\n\t\treturn amount === 0 ? this : this.slice(Math.max(0, amount));\n\t},\n\tskipLast: function skipLast(amount) {\n\t\treturn amount === 0 ? this : this.slice(0, -Math.max(0, amount));\n\t},\n\tskipWhile: function skipWhile(predicate, context) {\n\t\treturn reify(this, skipWhileFactory(this, predicate, context, true));\n\t},\n\tskipUntil: function skipUntil(predicate, context) {\n\t\treturn this.skipWhile(not(predicate), context);\n\t},\n\tsortBy: function sortBy(mapper, comparator) {\n\t\treturn reify(this, sortFactory(this, comparator, mapper));\n\t},\n\ttake: function take(amount) {\n\t\treturn this.slice(0, Math.max(0, amount));\n\t},\n\ttakeLast: function takeLast(amount) {\n\t\treturn this.slice(-Math.max(0, amount));\n\t},\n\ttakeWhile: function takeWhile(predicate, context) {\n\t\treturn reify(this, takeWhileFactory(this, predicate, context));\n\t},\n\ttakeUntil: function takeUntil(predicate, context) {\n\t\treturn this.takeWhile(not(predicate), context);\n\t},\n\tupdate: function update(fn) {\n\t\treturn fn(this);\n\t},\n\tvalueSeq: function valueSeq() {\n\t\treturn this.toIndexedSeq();\n\t},\n\t\n\thashCode: function hashCode() {\n\t\treturn this.__hash || (this.__hash = hashCollection(this));\n\t}\n\t\n});\nvar CollectionPrototype = Collection.prototype;\nCollectionPrototype[IS_ITERABLE_SENTINEL] = true;\nCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;\nCollectionPrototype.toJSON = CollectionPrototype.toArray;\nCollectionPrototype.__toStringMapper = quoteString;\nCollectionPrototype.inspect = CollectionPrototype.toSource = function() {\n\treturn this.toString();\n};\nCollectionPrototype.chain = CollectionPrototype.flatMap;\nCollectionPrototype.contains = CollectionPrototype.includes;\nmixin(KeyedCollection, {\n\tflip: function flip() {\n\t\treturn reify(this, flipFactory(this));\n\t},\n\tmapEntries: function mapEntries(mapper, context) {\n\t\tvar this$1 = this;\n\t\tvar iterations = 0;\n\t\treturn reify(\n\t\t\tthis,\n\t\t\tthis.toSeq()\n\t\t\t\t.map(function(v, k) {\n\t\t\t\t\treturn mapper.call(context, [k, v], iterations++, this$1);\n\t\t\t\t})\n\t\t\t\t.fromEntrySeq()\n\t\t);\n\t},\n\tmapKeys: function mapKeys(mapper, context) {\n\t\tvar this$1 = this;\n\t\treturn reify(\n\t\t\tthis,\n\t\t\tthis.toSeq()\n\t\t\t\t.flip()\n\t\t\t\t.map(function(k, v) {\n\t\t\t\t\treturn mapper.call(context, k, v, this$1);\n\t\t\t\t})\n\t\t\t\t.flip()\n\t\t);\n\t}\n});\nvar KeyedCollectionPrototype = KeyedCollection.prototype;\nKeyedCollectionPrototype[IS_KEYED_SENTINEL] = true;\nKeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;\nKeyedCollectionPrototype.toJSON = toObject;\nKeyedCollectionPrototype.__toStringMapper = function(v, k) {\n\treturn quoteString(k) + ': ' + quoteString(v);\n};\nmixin(IndexedCollection, {\n\ttoKeyedSeq: function toKeyedSeq() {\n\t\treturn new ToKeyedSequence(this, false);\n\t},\n\t\n\tfilter: function filter(predicate, context) {\n\t\treturn reify(this, filterFactory(this, predicate, context, false));\n\t},\n\tfindIndex: function findIndex(predicate, context) {\n\t\tvar entry = this.findEntry(predicate, context);\n\t\treturn entry ? entry[0] : -1;\n\t},\n\tindexOf: function indexOf(searchValue) {\n\t\tvar key = this.keyOf(searchValue);\n\t\treturn key === undefined ? -1 : key;\n\t},\n\tlastIndexOf: function lastIndexOf(searchValue) {\n\t\tvar key = this.lastKeyOf(searchValue);\n\t\treturn key === undefined ? -1 : key;\n\t},\n\treverse: function reverse() {\n\t\treturn reify(this, reverseFactory(this, false));\n\t},\n\tslice: function slice(begin, end) {\n\t\treturn reify(this, sliceFactory(this, begin, end, false));\n\t},\n\tsplice: function splice(index, removeNum ) {\n\t\tvar numArgs = arguments.length;\n\t\tremoveNum = Math.max(removeNum || 0, 0);\n\t\tif (numArgs === 0 || (numArgs === 2 && !removeNum)) {\n\t\t\treturn this;\n\t\t}\n\t\tindex = resolveBegin(index, index < 0 ? this.count() : this.size);\n\t\tvar spliced = this.slice(0, index);\n\t\treturn reify(\n\t\t\tthis,\n\t\t\tnumArgs === 1\n\t\t\t\t? spliced\n\t\t\t\t: spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))\n\t\t);\n\t},\n\t\n\tfindLastIndex: function findLastIndex(predicate, context) {\n\t\tvar entry = this.findLastEntry(predicate, context);\n\t\treturn entry ? entry[0] : -1;\n\t},\n\tfirst: function first() {\n\t\treturn this.get(0);\n\t},\n\tflatten: function flatten(depth) {\n\t\treturn reify(this, flattenFactory(this, depth, false));\n\t},\n\tget: function get(index, notSetValue) {\n\t\tindex = wrapIndex(this, index);\n\t\treturn index < 0 ||\n\t\t\t(this.size === Infinity || (this.size !== undefined && index > this.size))\n\t\t\t? notSetValue\n\t\t\t: this.find(\n\t\t\t\t\tfunction(_, key) {\n\t\t\t\t\t\treturn key === index;\n\t\t\t\t\t},\n\t\t\t\t\tundefined,\n\t\t\t\t\tnotSetValue\n\t\t\t  );\n\t},\n\thas: function has(index) {\n\t\tindex = wrapIndex(this, index);\n\t\treturn (\n\t\t\tindex >= 0 &&\n\t\t\t(this.size !== undefined\n\t\t\t\t? this.size === Infinity || index < this.size\n\t\t\t\t: this.indexOf(index) !== -1)\n\t\t);\n\t},\n\tinterpose: function interpose(separator) {\n\t\treturn reify(this, interposeFactory(this, separator));\n\t},\n\tinterleave: function interleave() {\n\t\tvar collections = [this].concat(arrCopy(arguments));\n\t\tvar zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);\n\t\tvar interleaved = zipped.flatten(true);\n\t\tif (zipped.size) {\n\t\t\tinterleaved.size = zipped.size * collections.length;\n\t\t}\n\t\treturn reify(this, interleaved);\n\t},\n\tkeySeq: function keySeq() {\n\t\treturn Range(0, this.size);\n\t},\n\tlast: function last() {\n\t\treturn this.get(-1);\n\t},\n\tskipWhile: function skipWhile(predicate, context) {\n\t\treturn reify(this, skipWhileFactory(this, predicate, context, false));\n\t},\n\tzip: function zip() {\n\t\tvar collections = [this].concat(arrCopy(arguments));\n\t\treturn reify(this, zipWithFactory(this, defaultZipper, collections));\n\t},\n\tzipAll: function zipAll() {\n\t\tvar collections = [this].concat(arrCopy(arguments));\n\t\treturn reify(this, zipWithFactory(this, defaultZipper, collections, true));\n\t},\n\tzipWith: function zipWith(zipper ) {\n\t\tvar collections = arrCopy(arguments);\n\t\tcollections[0] = this;\n\t\treturn reify(this, zipWithFactory(this, zipper, collections));\n\t}\n});\nvar IndexedCollectionPrototype = IndexedCollection.prototype;\nIndexedCollectionPrototype[IS_INDEXED_SENTINEL] = true;\nIndexedCollectionPrototype[IS_ORDERED_SENTINEL] = true;\nmixin(SetCollection, {\n\tget: function get(value, notSetValue) {\n\t\treturn this.has(value) ? value : notSetValue;\n\t},\n\tincludes: function includes(value) {\n\t\treturn this.has(value);\n\t},\n\t\n\tkeySeq: function keySeq() {\n\t\treturn this.valueSeq();\n\t}\n});\nSetCollection.prototype.has = CollectionPrototype.includes;\nSetCollection.prototype.contains = SetCollection.prototype.includes;\n\nmixin(KeyedSeq, KeyedCollection.prototype);\nmixin(IndexedSeq, IndexedCollection.prototype);\nmixin(SetSeq, SetCollection.prototype);\n\nfunction reduce(collection, reducer, reduction, context, useFirst, reverse) {\n\tassertNotInfinite(collection.size);\n\tcollection.__iterate(function(v, k, c) {\n\t\tif (useFirst) {\n\t\t\tuseFirst = false;\n\t\t\treduction = v;\n\t\t} else {\n\t\t\treduction = reducer.call(context, reduction, v, k, c);\n\t\t}\n\t}, reverse);\n\treturn reduction;\n}\nfunction keyMapper(v, k) {\n\treturn k;\n}\nfunction entryMapper(v, k) {\n\treturn [k, v];\n}\nfunction not(predicate) {\n\treturn function() {\n\t\treturn !predicate.apply(this, arguments);\n\t};\n}\nfunction neg(predicate) {\n\treturn function() {\n\t\treturn -predicate.apply(this, arguments);\n\t};\n}\nfunction defaultZipper() {\n\treturn arrCopy(arguments);\n}\nfunction defaultNegComparator(a, b) {\n\treturn a < b ? 1 : a > b ? -1 : 0;\n}\nfunction hashCollection(collection) {\n\tif (collection.size === Infinity) {\n\t\treturn 0;\n\t}\n\tvar ordered = isOrdered(collection);\n\tvar keyed = isKeyed(collection);\n\tvar h = ordered ? 1 : 0;\n\tvar size = collection.__iterate(\n\t\tkeyed\n\t\t\t? ordered\n\t\t\t\t? function(v, k) {\n\t\t\t\t\t\th = (31 * h + hashMerge(hash(v), hash(k))) | 0;\n\t\t\t\t  }\n\t\t\t\t: function(v, k) {\n\t\t\t\t\t\th = (h + hashMerge(hash(v), hash(k))) | 0;\n\t\t\t\t  }\n\t\t\t: ordered\n\t\t\t\t? function(v) {\n\t\t\t\t\t\th = (31 * h + hash(v)) | 0;\n\t\t\t\t  }\n\t\t\t\t: function(v) {\n\t\t\t\t\t\th = (h + hash(v)) | 0;\n\t\t\t\t  }\n\t);\n\treturn murmurHashOfSize(size, h);\n}\nfunction murmurHashOfSize(size, h) {\n\th = imul(h, 0xcc9e2d51);\n\th = imul((h << 15) | (h >>> -15), 0x1b873593);\n\th = imul((h << 13) | (h >>> -13), 5);\n\th = ((h + 0xe6546b64) | 0) ^ size;\n\th = imul(h ^ (h >>> 16), 0x85ebca6b);\n\th = imul(h ^ (h >>> 13), 0xc2b2ae35);\n\th = smi(h ^ (h >>> 16));\n\treturn h;\n}\nfunction hashMerge(a, b) {\n\treturn (a ^ (b + 0x9e3779b9 + (a << 6) + (a >> 2))) | 0; \n}\nvar OrderedSet = (function(Set$$1) {\n\tfunction OrderedSet(value) {\n\t\treturn value === null || value === undefined\n\t\t\t? emptyOrderedSet()\n\t\t\t: isOrderedSet(value)\n\t\t\t\t? value\n\t\t\t\t: emptyOrderedSet().withMutations(function(set) {\n\t\t\t\t\t\tvar iter = SetCollection(value);\n\t\t\t\t\t\tassertNotInfinite(iter.size);\n\t\t\t\t\t\titer.forEach(function(v) {\n\t\t\t\t\t\t\treturn set.add(v);\n\t\t\t\t\t\t});\n\t\t\t\t  });\n\t}\n\tif (Set$$1) OrderedSet.__proto__ = Set$$1;\n\tOrderedSet.prototype = Object.create(Set$$1 && Set$$1.prototype);\n\tOrderedSet.prototype.constructor = OrderedSet;\n\tOrderedSet.of = function of() {\n\t\treturn this(arguments);\n\t};\n\tOrderedSet.fromKeys = function fromKeys(value) {\n\t\treturn this(KeyedCollection(value).keySeq());\n\t};\n\tOrderedSet.prototype.toString = function toString() {\n\t\treturn this.__toString('OrderedSet {', '}');\n\t};\n\treturn OrderedSet;\n})(Set);\nfunction isOrderedSet(maybeOrderedSet) {\n\treturn isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);\n}\nOrderedSet.isOrderedSet = isOrderedSet;\nvar OrderedSetPrototype = OrderedSet.prototype;\nOrderedSetPrototype[IS_ORDERED_SENTINEL] = true;\nOrderedSetPrototype.zip = IndexedCollectionPrototype.zip;\nOrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;\nOrderedSetPrototype.__empty = emptyOrderedSet;\nOrderedSetPrototype.__make = makeOrderedSet;\nfunction makeOrderedSet(map, ownerID) {\n\tvar set = Object.create(OrderedSetPrototype);\n\tset.size = map ? map.size : 0;\n\tset._map = map;\n\tset.__ownerID = ownerID;\n\treturn set;\n}\nvar EMPTY_ORDERED_SET;\nfunction emptyOrderedSet() {\n\treturn (\n\t\tEMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()))\n\t);\n}\nvar Record = function Record(defaultValues, name) {\n\tvar hasInitialized;\n\tvar RecordType = function Record(values) {\n\t\tvar this$1 = this;\n\t\tif (values instanceof RecordType) {\n\t\t\treturn values;\n\t\t}\n\t\tif (!(this instanceof RecordType)) {\n\t\t\treturn new RecordType(values);\n\t\t}\n\t\tif (!hasInitialized) {\n\t\t\thasInitialized = true;\n\t\t\tvar keys = Object.keys(defaultValues);\n\t\t\tvar indices = (RecordTypePrototype._indices = {});\n\t\t\tRecordTypePrototype._name = name;\n\t\t\tRecordTypePrototype._keys = keys;\n\t\t\tRecordTypePrototype._defaultValues = defaultValues;\n\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\tvar propName = keys[i];\n\t\t\t\tindices[propName] = i;\n\t\t\t\tif (RecordTypePrototype[propName]) {\n\t\t\t\t\ttypeof console === 'object' &&\n\t\t\t\t\t\tconsole.warn &&\n\t\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\t'Cannot define ' +\n\t\t\t\t\t\t\t\trecordName(this$1) +\n\t\t\t\t\t\t\t\t' with property \"' +\n\t\t\t\t\t\t\t\tpropName +\n\t\t\t\t\t\t\t\t'\" since that property name is part of the Record API.'\n\t\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tsetProp(RecordTypePrototype, propName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.__ownerID = undefined;\n\t\tthis._values = List().withMutations(function(l) {\n\t\t\tl.setSize(this$1._keys.length);\n\t\t\tKeyedCollection(values).forEach(function(v, k) {\n\t\t\t\tl.set(\n\t\t\t\t\tthis$1._indices[k],\n\t\t\t\t\tv === this$1._defaultValues[k] ? undefined : v\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\t};\n\tvar RecordTypePrototype = (RecordType.prototype = Object.create(\n\t\tRecordPrototype\n\t));\n\tRecordTypePrototype.constructor = RecordType;\n\treturn RecordType;\n};\nRecord.prototype.toString = function toString() {\n\tvar this$1 = this;\n\tvar str = recordName(this) + ' { ';\n\tvar keys = this._keys;\n\tvar k;\n\tfor (var i = 0, l = keys.length; i !== l; i++) {\n\t\tk = keys[i];\n\t\tstr += (i ? ', ' : '') + k + ': ' + quoteString(this$1.get(k));\n\t}\n\treturn str + ' }';\n};\nRecord.prototype.equals = function equals(other) {\n\treturn (\n\t\tthis === other ||\n\t\t(other &&\n\t\t\tthis._keys === other._keys &&\n\t\t\trecordSeq(this).equals(recordSeq(other)))\n\t);\n};\nRecord.prototype.hashCode = function hashCode() {\n\treturn recordSeq(this).hashCode();\n};\n\nRecord.prototype.has = function has(k) {\n\treturn this._indices.hasOwnProperty(k);\n};\nRecord.prototype.get = function get(k, notSetValue) {\n\tif (!this.has(k)) {\n\t\treturn notSetValue;\n\t}\n\tvar index = this._indices[k];\n\tvar value = this._values.get(index);\n\treturn value === undefined ? this._defaultValues[k] : value;\n};\n\nRecord.prototype.set = function set(k, v) {\n\tif (this.has(k)) {\n\t\tvar newValues = this._values.set(\n\t\t\tthis._indices[k],\n\t\t\tv === this._defaultValues[k] ? undefined : v\n\t\t);\n\t\tif (newValues !== this._values && !this.__ownerID) {\n\t\t\treturn makeRecord(this, newValues);\n\t\t}\n\t}\n\treturn this;\n};\nRecord.prototype.remove = function remove(k) {\n\treturn this.set(k);\n};\nRecord.prototype.clear = function clear() {\n\tvar newValues = this._values.clear().setSize(this._keys.length);\n\treturn this.__ownerID ? this : makeRecord(this, newValues);\n};\nRecord.prototype.wasAltered = function wasAltered() {\n\treturn this._values.wasAltered();\n};\nRecord.prototype.toSeq = function toSeq() {\n\treturn recordSeq(this);\n};\nRecord.prototype.toJS = function toJS$1() {\n\treturn toJS(this);\n};\nRecord.prototype.entries = function entries() {\n\treturn this.__iterator(ITERATE_ENTRIES);\n};\nRecord.prototype.__iterator = function __iterator(type, reverse) {\n\treturn recordSeq(this).__iterator(type, reverse);\n};\nRecord.prototype.__iterate = function __iterate(fn, reverse) {\n\treturn recordSeq(this).__iterate(fn, reverse);\n};\nRecord.prototype.__ensureOwner = function __ensureOwner(ownerID) {\n\tif (ownerID === this.__ownerID) {\n\t\treturn this;\n\t}\n\tvar newValues = this._values.__ensureOwner(ownerID);\n\tif (!ownerID) {\n\t\tthis.__ownerID = ownerID;\n\t\tthis._values = newValues;\n\t\treturn this;\n\t}\n\treturn makeRecord(this, newValues, ownerID);\n};\nRecord.isRecord = isRecord;\nRecord.getDescriptiveName = recordName;\nvar RecordPrototype = Record.prototype;\nRecordPrototype[IS_RECORD_SENTINEL] = true;\nRecordPrototype[DELETE] = RecordPrototype.remove;\nRecordPrototype.deleteIn = RecordPrototype.removeIn = deleteIn;\nRecordPrototype.getIn = getIn$$1;\nRecordPrototype.hasIn = CollectionPrototype.hasIn;\nRecordPrototype.merge = merge;\nRecordPrototype.mergeWith = mergeWith;\nRecordPrototype.mergeIn = mergeIn;\nRecordPrototype.mergeDeep = mergeDeep;\nRecordPrototype.mergeDeepWith = mergeDeepWith;\nRecordPrototype.mergeDeepIn = mergeDeepIn;\nRecordPrototype.setIn = setIn$$1;\nRecordPrototype.update = update$$1;\nRecordPrototype.updateIn = updateIn$1;\nRecordPrototype.withMutations = withMutations;\nRecordPrototype.asMutable = asMutable;\nRecordPrototype.asImmutable = asImmutable;\nRecordPrototype[ITERATOR_SYMBOL] = RecordPrototype.entries;\nRecordPrototype.toJSON = RecordPrototype.toObject =\n\tCollectionPrototype.toObject;\nRecordPrototype.inspect = RecordPrototype.toSource = function() {\n\treturn this.toString();\n};\nfunction makeRecord(likeRecord, values, ownerID) {\n\tvar record = Object.create(Object.getPrototypeOf(likeRecord));\n\trecord._values = values;\n\trecord.__ownerID = ownerID;\n\treturn record;\n}\nfunction recordName(record) {\n\treturn record._name || record.constructor.name || 'Record';\n}\nfunction recordSeq(record) {\n\treturn keyedSeqFromValue(\n\t\trecord._keys.map(function(k) {\n\t\t\treturn [k, record.get(k)];\n\t\t})\n\t);\n}\nfunction setProp(prototype, name) {\n\ttry {\n\t\tObject.defineProperty(prototype, name, {\n\t\t\tget: function() {\n\t\t\t\treturn this.get(name);\n\t\t\t},\n\t\t\tset: function(value) {\n\t\t\t\tinvariant(this.__ownerID, 'Cannot set on an immutable record.');\n\t\t\t\tthis.set(name, value);\n\t\t\t}\n\t\t});\n\t} catch (error) {\n\t}\n}\n"
						},
						{
							"line": 4957,
							"tags": [],
							"tabs": "",
							"desc": "Returns a lazy Seq of `value` repeated `times` times. When `times` is undefined, returns an infinite sequence of `value`. ",
							"code": "var Repeat = (function(IndexedSeq$$1) {\n\tfunction Repeat(value, times) {\n\t\tif (!(this instanceof Repeat)) {\n\t\t\treturn new Repeat(value, times);\n\t\t}\n\t\tthis._value = value;\n\t\tthis.size = times === undefined ? Infinity : Math.max(0, times);\n\t\tif (this.size === 0) {\n\t\t\tif (EMPTY_REPEAT) {\n\t\t\t\treturn EMPTY_REPEAT;\n\t\t\t}\n\t\t\tEMPTY_REPEAT = this;\n\t\t}\n\t}\n\tif (IndexedSeq$$1) Repeat.__proto__ = IndexedSeq$$1;\n\tRepeat.prototype = Object.create(IndexedSeq$$1 && IndexedSeq$$1.prototype);\n\tRepeat.prototype.constructor = Repeat;\n\tRepeat.prototype.toString = function toString() {\n\t\tif (this.size === 0) {\n\t\t\treturn 'Repeat []';\n\t\t}\n\t\treturn 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';\n\t};\n\tRepeat.prototype.get = function get(index, notSetValue) {\n\t\treturn this.has(index) ? this._value : notSetValue;\n\t};\n\tRepeat.prototype.includes = function includes(searchValue) {\n\t\treturn is(this._value, searchValue);\n\t};\n\tRepeat.prototype.slice = function slice(begin, end) {\n\t\tvar size = this.size;\n\t\treturn wholeSlice(begin, end, size)\n\t\t\t? this\n\t\t\t: new Repeat(\n\t\t\t\t\tthis._value,\n\t\t\t\t\tresolveEnd(end, size) - resolveBegin(begin, size)\n\t\t\t  );\n\t};\n\tRepeat.prototype.reverse = function reverse() {\n\t\treturn this;\n\t};\n\tRepeat.prototype.indexOf = function indexOf(searchValue) {\n\t\tif (is(this._value, searchValue)) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn -1;\n\t};\n\tRepeat.prototype.lastIndexOf = function lastIndexOf(searchValue) {\n\t\tif (is(this._value, searchValue)) {\n\t\t\treturn this.size;\n\t\t}\n\t\treturn -1;\n\t};\n\tRepeat.prototype.__iterate = function __iterate(fn, reverse) {\n\t\tvar this$1 = this;\n\t\tvar size = this.size;\n\t\tvar i = 0;\n\t\twhile (i !== size) {\n\t\t\tif (fn(this$1._value, reverse ? size - ++i : i++, this$1) === false) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn i;\n\t};\n\tRepeat.prototype.__iterator = function __iterator(type, reverse) {\n\t\tvar this$1 = this;\n\t\tvar size = this.size;\n\t\tvar i = 0;\n\t\treturn new Iterator(function() {\n\t\t\treturn i === size\n\t\t\t\t? iteratorDone()\n\t\t\t\t: iteratorValue(type, reverse ? size - ++i : i++, this$1._value);\n\t\t});\n\t};\n\tRepeat.prototype.equals = function equals(other) {\n\t\treturn other instanceof Repeat\n\t\t\t? is(this._value, other._value)\n\t\t\t: deepEqual(other);\n\t};\n\treturn Repeat;\n})(IndexedSeq);\nvar EMPTY_REPEAT;\nfunction fromJS(value, converter) {\n\treturn fromJSWith(\n\t\t[],\n\t\tconverter || defaultConverter,\n\t\tvalue,\n\t\t'',\n\t\tconverter && converter.length > 2 ? [] : undefined,\n\t\t{ '': value }\n\t);\n}\nfunction fromJSWith(stack, converter, value, key, keyPath, parentValue) {\n\tvar toSeq = Array.isArray(value)\n\t\t? IndexedSeq\n\t\t: isPlainObj(value)\n\t\t\t? KeyedSeq\n\t\t\t: null;\n\tif (toSeq) {\n\t\tif (~stack.indexOf(value)) {\n\t\t\tthrow new TypeError('Cannot convert circular structure to Immutable');\n\t\t}\n\t\tstack.push(value);\n\t\tkeyPath && key !== '' && keyPath.push(key);\n\t\tvar converted = converter.call(\n\t\t\tparentValue,\n\t\t\tkey,\n\t\t\ttoSeq(value).map(function(v, k) {\n\t\t\t\treturn fromJSWith(stack, converter, v, k, keyPath, value);\n\t\t\t}),\n\t\t\tkeyPath && keyPath.slice()\n\t\t);\n\t\tstack.pop();\n\t\tkeyPath && keyPath.pop();\n\t\treturn converted;\n\t}\n\treturn value;\n}\nfunction defaultConverter(k, v) {\n\treturn isKeyed(v) ? v.toMap() : v.toList();\n}\nvar version = '4.0.0-rc.9';\nvar Immutable = {\n\tversion: version,\n\tCollection: Collection,\n\tIterable: Collection,\n\tSeq: Seq,\n\tMap: Map,\n\tOrderedMap: OrderedMap,\n\tList: List,\n\tStack: Stack,\n\tSet: Set,\n\tOrderedSet: OrderedSet,\n\tRecord: Record,\n\tRange: Range,\n\tRepeat: Repeat,\n\tis: is,\n\tfromJS: fromJS,\n\thash: hash,\n\tisImmutable: isImmutable,\n\tisCollection: isCollection,\n\tisKeyed: isKeyed,\n\tisIndexed: isIndexed,\n\tisAssociative: isAssociative,\n\tisOrdered: isOrdered,\n\tisValueObject: isValueObject,\n\tget: get,\n\tgetIn: getIn$1,\n\thas: has,\n\thasIn: hasIn$1,\n\tmerge: merge$1,\n\tmergeDeep: mergeDeep$1,\n\tmergeWith: mergeWith$1,\n\tmergeDeepWith: mergeDeepWith$1,\n\tremove: remove,\n\tremoveIn: removeIn,\n\tset: set,\n\tsetIn: setIn$1,\n\tupdate: update$1,\n\tupdateIn: updateIn\n};\nvar Iterable = Collection;\nexport {\n\tversion,\n\tCollection,\n\tIterable,\n\tSeq,\n\tMap,\n\tOrderedMap,\n\tList,\n\tStack,\n\tSet,\n\tOrderedSet,\n\tRecord,\n\tRange,\n\tRepeat,\n\tis,\n\tfromJS,\n\thash,\n\tisImmutable,\n\tisCollection,\n\tisKeyed,\n\tisIndexed,\n\tisAssociative,\n\tisOrdered,\n\tisValueObject,\n\tget,\n\tgetIn$1 as getIn,\n\thas,\n\thasIn$1 as hasIn,\n\tmerge$1 as merge,\n\tmergeDeep$1 as mergeDeep,\n\tmergeWith$1 as mergeWith,\n\tmergeDeepWith$1 as mergeDeepWith,\n\tremove,\n\tremoveIn,\n\tset,\n\tsetIn$1 as setIn,\n\tupdate$1 as update,\n\tupdateIn\n};\nexport default Immutable;\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/util/src/errors/Custom.js": {
			"title": "Custom",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "Custom error base class. TODO: How much of this code is needed nowadays? ",
							"code": "class Custom extends Error {\n\tconstructor(message) {\n\t\tsuper(message);\n\t\tif (Error.hasOwnProperty('captureStackTrace')) {\n\t\t\tError['captureStackTrace'](this, this.constructor);\n\t\t} else {\n\t\t\tObject.defineProperty(this, 'stack', {\n\t\t\t\tvalue: new Error(message).stack\n\t\t\t});\n\t\t}\n\t\tthis.name = this.constructor.name;\n\t}\n}\nexport class NotFoundError extends Custom {}\nexport class MethodError extends Custom {}\nexport class NotAcceptableError extends Custom {}\nexport class UnsupportedError extends Custom {}\nexport class AccessError extends Custom {}\nexport class ConfigurationError extends Custom {}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/util/src/func/arrayutils.js": {
			"title": "arrayutils",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import { typeOf, isArrayLike } from '../Type';\n"
						},
						{
							"line": 1,
							"tags": [
								{
									"name": "@param",
									"type": "{Array}",
									"desc": "array",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Flatten that array. ",
							"code": "export function flatten(array) {\n\treturn array.reduce((result, next) => {\n\t\treturn result.concat(Array.isArray(next) ? flatten(next) : next);\n\t}, []);\n}\n"
						},
						{
							"line": 11,
							"tags": [
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "arg",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "[action]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array|void}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Resolve single argument into an array with one or more entries with special handling of single string argument: \n\n\n1. Strings to be split at spaces into an array \n3. Arrays are converted to a similar but fresh array \n2. Array-like objects transformed into real arrays. \n3. Other objects are pushed into a one entry array. \n\n",
							"code": "export function asarray(arg, action) {\n\tconst list = makearray(arg);\n\tif (action) {\n\t\tlist.forEach(action);\n\t} else {\n\t\treturn list;\n\t}\n}\n"
						}
					]
				},
				{
					"title": "Scoped ",
					"tabs": "",
					"sections": [
						{
							"line": 33,
							"tags": [
								{
									"name": "@param",
									"type": "{*}",
									"desc": "arg",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Resolve argument into array. ",
							"code": "function makearray(arg) {\n\tswitch (typeOf(arg)) {\n\t\tcase 'string':\n\t\t\treturn arg.split(' ');\n\t\tcase 'array':\n\t\t\treturn Array.from(arg);\n\t\tdefault:\n\t\t\tif (isArrayLike(arg)) {\n\t\t\t\treturn Array.from(arg);\n\t\t\t} else {\n\t\t\t\treturn [arg];\n\t\t\t}\n\t}\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/util/src/func/domutils.js": {
			"title": "domutils",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "const johnson = 'data-plastique-id';\nconst findall = (path, context) => Array.from(context.querySelectorAll(path));\nconst getguid = elm => elm.getAttribute(johnson);\n"
						},
						{
							"line": 3,
							"tags": [
								{
									"name": "@param",
									"type": "{Element}",
									"desc": "elm",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "[guid]",
									"text": "- The phantom guid associated to root element"
								},
								{
									"name": "@param",
									"type": "{boolean}",
									"desc": "[deep]",
									"text": "- TODO: No make sense with two optional params here :/"
								},
								{
									"name": "@returns",
									"type": "{Map<string,Element>}",
									"desc": "",
									"text": "- Mapping `guid` value to element"
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export function mapguids(elm, guid, deep = true) {\n\tconst fix = deep ? '' : ':scope > ';\n\tconst css = `${fix}[${johnson}]`;\n\tconst all = findall(css, elm);\n\tconst set = elm => [getguid(elm), elm];\n\tconst map = new Map(all.map(set));\n\tif (guid) {\n\t\tmap.set(guid, elm);\n\t}\n\treturn map;\n}\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/util/src/index.js": {
			"title": "index",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "export { default as Key } from './Key';\nexport { default as Tick } from './Tick';\nexport { default as Class } from './Class';\nexport { default as Mapping } from './data/Mapping';\nexport { default as IMapping } from './data/IMapping';\nexport { default as Environment } from './Environment';\nexport { AccessError } from './errors/Custom';\nexport { UnsupportedError } from './errors/Custom';\nexport { ConfigurationError } from './errors/Custom';\nexport * from './Type'; \nexport * from './func/arrayutils';\nexport * from './func/domutils';\nexport * from './decorators';\nexport * from './Immutable';\n"
						}
					]
				}
			],
			"type": "text/javascript"
		},
		"packages/util/src/trash/arguments.js": {
			"title": "arguments",
			"chapters": [
				{
					"title": "",
					"tabs": "",
					"sections": [
						{
							"line": 0,
							"tags": [],
							"tabs": "",
							"desc": "",
							"code": "import Type from './Type';\n"
						},
						{
							"line": 1,
							"tags": [
								{
									"name": "@deprecated",
									"type": "",
									"desc": "",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Function}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "",
							"code": "export function confirm(...types) {\n\treturn function(target, name, descriptor) {\n\t\treturn descriptor;\n\t};\n}\n"
						},
						{
							"line": 10,
							"tags": [
								{
									"name": "@returns",
									"type": "{Function}",
									"desc": "",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "a",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "b",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								},
								{
									"name": "@type",
									"type": "{Object<string,function>}",
									"desc": "",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "args",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array<string>}",
									"desc": "types",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "xpect",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "arg",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{number}",
									"desc": "index",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array}",
									"desc": "[report]",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{boolean}",
									"desc": "",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "xpect",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{boolean}",
									"desc": "optional",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Function}",
									"desc": "target",
									"text": "(constructor)"
								},
								{
									"name": "@param",
									"type": "{string}",
									"desc": "name",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "args",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array}",
									"desc": "types",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{string}",
									"desc": "",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Object}",
									"desc": "args",
									"text": ""
								},
								{
									"name": "@param",
									"type": "{Array}",
									"desc": "types",
									"text": ""
								},
								{
									"name": "@returns",
									"type": "{Array<string>}",
									"desc": "",
									"text": ""
								}
							],
							"tabs": "",
							"desc": "Confirm type of arguments. Takes an array of strings. TODO: Only in debug mode? TODO: Support confirm truthy! \n\nfunction confirm(...types) { \n\treturn function(target, name, descriptor) { \n\t\tlet base = descriptor.value; \n\t\tdescriptor.enumarable = false; \n\t\tdescriptor.value = function() { \n\t\t\tlet args = arguments; \n\t\t\tif (ok(args, types)) { \n\t\t\t\treturn base.apply(this, args); \n\t\t\t} else { \n\t\t\t\tthrow new TypeError(geterror(target, name, args, types)); \n\t\t\t} \n\t\t}; \n\t\treturn descriptor; \n\t}; \n} \n// Scoped ...................................................................... const WILDCARD = '*'; const UNDEFINED = 'undefined'; const STRING = 'string'; \n/** No polyfills here. \n\nconst startsWith = (a, b) =&gt; a.indexOf(b) === 0; \n/* TODO: Make this extensible. \n\nlet fixtypes = { \n\tnode: arg =&gt; arg &amp;&amp; arg.nodeType, \n\tconstructor: arg =&gt; arg &amp;&amp; Type.isConstructor(arg), \n\telement: arg =&gt; arg &amp;&amp; arg.nodeType === Node.ELEMENT_NODE, \n\tspirit: arg =&gt; arg &amp;&amp; arg.$instanceid &amp;&amp; arg.element // uarg! \n}; \n/** TODO: at some point, return true unless in development mode. \n\nfunction ok(args, types) { \n\treturn types.every((type, index) =&gt; matches(type, args[index], index)); \n} \n/** Check if argument matches expected type (very basic support here). \n\nfunction matches(xpect, arg, index, report = null) { \n\tlet needs = !startsWith(xpect, '('); \n\tlet split = xtract(xpect, !needs).split('|'); \n\tlet fixed = fixtypes[xpect]; \n\tlet input = Type.of(arg); \n\tlet match = \n\t\targ === WILDCARD || \n\t\t(fixed &amp;&amp; fixed(arg)) || \n\t\t(!needs &amp;&amp; input === UNDEFINED) || \n\t\t(!needs &amp;&amp; split.indexOf(WILDCARD) &gt; -1) || \n\t\tsplit.indexOf(input) &gt; -1; \n\tif (report &amp;&amp; !match) { \n\t\tif (input === STRING) { \n\t\t\targ = `\"${arg}\"`; \n\t\t} \n\t\treport = report.concat([index, xpect, input, arg]); \n\t} \n\treturn report || match; \n} \n/** Extract expected type of (optional) argument. \n\nfunction xtract(xpect, optional) { \n\treturn optional ? xpect.slice(1, -1) : xpect; \n} \n/** TODO: How would `target.constructor` turn out when decorating static method? \n\nfunction geterror(target, name, args, types) { \n\tlet rep = getreport(args, types); \n\tlet con = target.constructor; \n\tlet own = con === Function ? target.name : con.name; \n\treturn ( \n\t\t`${own}.${name} arguments[${rep.shift()}] ` + \n\t\t`expected ${rep.shift()}, got ${rep.shift()}: ${rep.shift()}` \n\t); \n} \n/** \n\nfunction getreport(args, types) { \n\treturn types.reduce((result, type, i) =&gt; { \n\t\tlet params = [type, args[i], i]; \n\t\tlet report = []; \n\t\tif (!result &amp;&amp; !matches(...params)) { \n\t\t\tresult = matches(...params, report); \n\t\t} \n\t\treturn result; \n\t}, null); \n} ",
							"code": ""
						}
					]
				}
			],
			"type": "text/javascript"
		}
	}
}